# 메인메뉴는 %%% 로 시작하고, 메뉴와 메뉴사이는 공백줄로 구분합니다.
# %%% 로 시작하지 않는 문단은 모두 주석처리가 됩니다.
# 즉 이글도 메뉴에 반영이 되지 않는 주석문에 해당됩니다.
# 메모등을 담을 수 있습니다.

# 메뉴의 서브 메뉴를 만들 수 있으며, 아래 예제문을 참조하여 직접 추가하실 수 있습니다.
# %%%e 는 한글환경이 아닌경우 영어메뉴가 출력될때 사용됩니다.
# 특정 메뉴에서 구성을 수정을 하고 싶을때, vi 로 go.env 를 직접열지 않고, 메뉴에서 conf [엔터] 로 바로 수정하실 수 있습니다.




%%% 시스템 정보 / 프로세스 관리 [p]
%%%e System Information / Process Management [p]
%% uname -a ;echo
%% echo "hostname: $(hostname) ; local_ip: $(hostname -i) ; public_ip: $(wget -q -O - http://icanhazip.com)";echo
%% w
: info; { echo -ne "$(date) ; LANG: $LANG\n\n hostname:$(hostname)\n ip:$(hostname -i)\n public_ip:$publicip\n\n" ; uname -a ; echo ; { lsb_release -a 2>/dev/null && echo ; }; who am i ; echo ; w ; } | cip
: memory/storage info; vmstat ;; iostat 2>/dev/null ;; free -m ;; df -h |cper|column -t
varCMD__env__top__htop__load__iotop__bashtop__neofetch__iftop__dfmonitor__vmstat@space@1__mpstat@space@-P@space@ALL@space@1__iostat@space@-xz@space@1__nethogs_inxi@space@-Fxz
# resource check (tmux window-chg ctrl-b n/p)
tmux -u new-session -d 'bashtop' \; new-window 'top' \; new-window 'iftop' \; new-window 'sh -c "pstree; exec bash"'; tmux attach
# pstree find PID -> ps -ef 
pstree ;; v="$( pstree -pl | grep -E -- "-varFind__bash\(|-\{varFind\}" )" ; p="$(echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s|", $i; print ""}' |sed 's/|$//g')" ; echo "$v"|column -t ; [ "$p" ] && echo "$p" && ps -ef|gfind 2 "$p" | cpipe
# pstree find PID -> lsof
pstree ;; v="$( pstree -pl | grep -E -- "-varFind__bash\(|-\{varFind\}" )" ; p="$(echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s|", $i; print ""}' |sed 's/|$//g')" ; echo "$v"|column -t ; [ "$p" ] && echo "$p" && lsof|gfind 2 "$p" | cpipe 
# pstree searched PID allkill // not PPID 1
!!! pstree -pl ;; v="$(pstree -pl | grep -E -- "-varFind__go.sh\(|-\{varFind\}")" ; p="$( echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s ", $i}{print ""}')" ; pg=$(echo $p|tr ' ' '|' |sed 's/|$//g') ; [ "$p" ] && echo "search: $p" && p="$( ps -ef | awk -v pg="$pg" '$2 ~ pg && $3 != 1 {printf "%s ",$2}')" && echo -n "match : $p" ; echo -n "---> kill? [Enter] " ; read x && echo $p | xargs kill
# top cpu rank 1~5 PID -> ps -ef
p="$(top -bn1 | head -n30 | grep -A30 "PID USER " | awk 'NR>=2 && NR<=6 && $1>999 {printf "%s|", $1}'|sed 's/|$/\n/g')" ; [ "$p" ] && echo "$p" && ps -ef|gfind 2 "$p"
ps -ef | cpipe | less -RX 
renice -n 19 -p varPID ; ionice -c2 -n7 -p varPID
pgrep -af varFind
!!! ps -ef | grep varFind | awk $3 != 1 '{printf "%s ",$2}' |xargs kill -9 
!!! kill -9 varPID
# last log
{ w ;echo; last ; } | cip24 | less -RX 
netstat -tulpn | grep -v :::|grep LISTEN|sort -k4 
nmap varHost__localhost 
yyay varPKG__psmisc__bashtop__htop__neofetch__iftop__tmux__screen__bsdextrautils
yyay varPKG__net-tools__nmap__ncurses__sysstat__iotop__nethogs__inxi
: system load check ; load


%%% 서버 데몬 관리 [d]
%%%e Server Daemon Management [d]
%% pstree | grep -E "httpd|apache|mysql|named|mail" | awk -F '-' '!seen[$2]++ {print $0}' | sort -u
systemctl status | cpipe | less -RX
systemctl status $( systemctl list-unit-files --type=service|grep able|awk -F'.service' '{print $1}'|pipemenu1) 
systemctl --all --type=service
systemctl --all --type=socket
systemctl list-unit-files
systemctl list-unit-files --type=service
systemctl list-unit-files --type=service | grep varFind
systemctl list-unit-files --type=service --state=enabled 
systemctl list-unit-files --type=service --state=disabled
# daemon stat chg
daemon=$( systemctl list-unit-files --type=service|grep able|awk -F'.service' '{print $1}'|pipemenu1) ;; systemctl varMode__start__stop__restart__status__enable__disable__enable@space@--now__disable@space@--now $daemon ; [ "varMode" != "status" ] && systemctl status $daemon
service $( ls -1 /etc/init.d/ | pipemenu ) $( echo restart start stop status | pipemenu )
#
systemctl start varDaemon && systemctl enable varDaemon ; systemctl status varDaemon
systemctl stop varDaemon && systemctl disable varDaemon ; systemctl status varDaemon
systemctl restart $( systemctl list-unit-files --type=service|grep able|awk -F'.service' '{print $1}'|pipemenu1) 
systemctl status varDaemon
# firewall port open 
firewall-cmd --permanent --add-service=varDaemon__ssh && firewall-cmd --reload
ufw allow varDaemon__ssh ;; ufw status 
ufw $(echo "enable disable status"|pipemenu)
netstat -tulpn | grep -v :::|grep LISTEN|sort -k4
# daemon on/ off app
: Systemd  ; systemctl-ui 
: SysVinit ; sysv-rc-conf 
: SysVinit ; ntsysv 
# 
explorer $( ls -d /etc/systemd/  /etc/systemd/system/ /etc/rc.d/init.d/ /etc/init.d/ /lib/systemd/system 2>/dev/null | pipemenu ) 
# target mode
systemctl get-default
!!! systemctl set-default multi-user.target
!!! systemctl set-default graphical.target
!!! systemctl isolate graphical.target
yyay varPKG__systemctl-ui__sysv-rc-conf__ntsysv
: systemctl status function ; ss 
: systemctl status functions ; varS__ssa__ssn__sss__ssd__ssf__ssu__ssc__ssm__ssp__ssv


%%% 패키지 관리 yum/apt [a] etc (aa)
%%%e Package Management yum/apt [a] etc (aa)
%% echo -n "Able:" ; { which yum ; which dnf ; which apt ; which pkginfo ; which dpkg ; which rpm ; } 2>/dev/null | tr "\n" " " ; echo
# yum ####################################
yum install -y varPKG
!!! yum -y remove varPKG
yum list updates |less -RX 
yum update -y
# search && install
yum search varPKG 
yum list varPKG* 
yum list installed|less -RX
yum install -y "$( yum search varPKG|awk -F: '{print $1}' |grep varPKG |pipemenu)"
# search installed PACKAGE
yum whatprovides $(which varCMD)
repoquery -qf */varCMD
rpm -qf $(which varCMD__find)
rpm -qa | grep varPKG
rpm -ql varPKG
# apt ###################################
apt update -y && apt upgrade -y
apt install -y varPKG
!!! apt remove varPKG
# search command and install
apt search varPKG__php8.3 | cgrep varPKG | less -RX
apt install software-properties-common ;; add-apt-repository universe ;; apt update -y
apt-file search varCMD | grep 'bin/' | cgrep varCMD | less -RX || apt-file update
apt install "$(apt-file search varCMD|grep "/varCMD$"|awk -F: '{print $1}'|seen|pipemenu1cancel)"
# search installed PACKAGE / PACKAGE file list
dpkg -S $(which varCMD__find) # 명령어로 패키시 설치 검토
dpkg-query -S varPath__@@etc@@ssh # path 로 설치 검토
dpkg -L varPKG__openssh-server | cgrepl etc bin | less -RX # 설치된 패키지의 리스트 출력
dpkg -l | grep varPKG__sql # 설치된 패키지 필터 검색
# lamp check
yum list installed| grep -E "php|maria|mysql|apache|httpd"|sort
apt list --installed| grep -E '^php[0-9]|^maria|^mysql|^apache|httpd'|sort
pkginfo -l|grep -E "apache|maria|mysql|php|httpd"|sort
rpm -qa|egrep -E "php|maria|mysql|apache|httpd"|sort
# install
apt install -y varPKG__lynx__screen__bat__at__net-tools__apt-file && apt-file update
yum install -y yum-utils epel-release && yum repolist && yum update
vi3 $( ls -1 /etc/apt/sources.list /etc/apt/sources.list.d/* /etc/yum.conf 2>/dev/null ) 
explorer $( ls -1d /etc/apt /etc/yum.repos.d yum 2>/dev/null |pipemenu1 )




%%% 사용자 관리 [u] / 환경변수 설정 (en)
%%%e User Management [u] / Environment Variable Settings (en)
cd /etc/skel ; ls -al /etc/skel 
vi3 /etc/passwd /etc/shadow /etc/group /etc/pam.d/password-auth
# useradd
useradd varID ; passwd varID
useradd varID -md /home/varID -c varComment__www__pro -s varShell__@@bin@@bash__@@bin@@nologin ;; cat /etc/passwd|grep varID
!!! userdel -r -f varID ; groupdel varID
# varID 그룹에 www-data 를 추가하여, webroot 에 webserver 가 접근하게 설정 
# 권한을 rwxr-s---으로 설정: 2: setgid ? 하위 디렉토리/파일이 이 그룹을 상속함
webroot="/home/varID/public_html" ; usermod -aG varID www-data ; mkdir -p $webroot ; chown -R varID:www-data $webroot ; chmod 2750 $webroot ; chmod 711 /home/varID ; cat /etc/group | grep varID
id varID ;; ls -al ~varID
# passwd
echo "varID:varPW" | chpasswd || echo varPW | passwd varID --stdin 2>/dev/null
# id/pw auth check
idpw varID varPW varHost__localhost varPort__22
: userinfo_func ; userinfo varID
# usermod
: idchg ; groupmod -n varNewID varID ;; usermod -l varNewID -md /home/varNewID -g varNewID varID
: Group - id add ; cat /etc/group|egrep  ",|sudo|wheel|www-data" ;; id -un ; echo "user: varID" ;; usermod -aG varGroup__sudo__wheel varID
: lock ; passwd -l varID
: unlock ; passwd -u varID
: unban ; pam_tally2 --user varID --reset
: users list; awk -F: '$3 > 999' /etc/passwd
: systems list; awk -F: '$3 < 1000' /etc/passwd ; echo ; awk -F: '$2 ~ /^[\*!]+$/' /etc/shadow ; echo; awk -F: '$3 < 1000' /etc/group
: setfacl ; setfacl -dR -m u:varID:rwx /home/varID
: getfacl ; getfacl /home/varID
# lock users list
awk -F: 'BEGIN { while (getline < "/etc/passwd") if ($3 > 999) uid[$1]=1 } { if ($2 ~ /^!/ && uid[$1]) print $1 }' /etc/shadow
awk -F: 'FNR==NR { if ($3 > 999) uid[$1]=1; next } { if ($2 ~ /^!/ && uid[$1]) print $0 }' /etc/passwd /etc/shadow
[ -f /etc/passwd.merged ] && awk -F: '($3 > 999) && ($2 ~ /^[\*!]/) {print $1}' /etc/passwd.merged
# install
yyay varPKG__expect__sshpass__pamtester__acl


# trash
# passwd.merged 
sh -c 'cp /etc/passwd /etc/passwd.bak && cp /etc/shadow /etc/shadow.bak && pwunconv && cp /etc/passwd /etc/passwd.merged && pwconv && chmod 600 /etc/passwd.merged && chown root:root /etc/passwd.merged'



%%% 시스템 로그 / 열린파일 관리 [l]
%%%e System Log / Open File Management [l]
%% echo "find /var/log/ -maxdepth 1 -type f -mmin -60"
%% echo $(find /var/log/ -maxdepth 1 -type f -mmin -60)
: kernel msg; dmesg | cpipe | less -r 
: last 1000 line; journalctl -e # end 1000 line
: realtime; journalctl -f # realtime
: realtiem kernel; journalctl -fk # realtime kernel log
: unit; journalctl -r -u $( systemctl list-unit-files --type=service|grep enable|awk -F'.service' '{print $1}'|pipemenu ) # unit log reverse
: boot; journalctl $( echo -e "-b\n-b -1\n-rb -1\n-b -2\n-rb -2\n-b -3\n-rb -3" |pipemenulist)	# booting log
: since; journalctl --since $( echo -e "-1hour\n-2hour\n-3hour\n-12hour\n-1day\n-7day" | pipemenulist ) 
: level; journalctl -rp $( echo "info warning err" |pipemenu ) # log level
: resoning; journalctl -rx # 문제가 발생한 부분과 부가 정보를 포함한 로그
tail -f /var/log/syslog |cpipe 
tail -f $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) |cpipe 
tail -f /var/log/xferlog
: 60m-log ; s=$( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) ;; tac $s |cpipe|less -RX
: 60m-log ; s=$( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) ;; cat $s |cpipe|less -RX +G
tac $( ls -1 /var/log/cron /var/log/auth.log /var/log/daemon.log /var/log/kern.log /var/log/messages /var/log/secure /var/log/maillog /var/log/pveam.log /var/log/httpd/access_log /var/log/httpd/error_log  2>/dev/null | pipemenu ) |cpipe|less -RX
explorer /var/log/
# ipban func
varOPT__ipban__ipban24__ipban16__ipallow varIPs
ipbanlist
ipbanlog 
# 
# List open files
lsof -i		 | cpipe
lsof -i tcp  | cpipe
lsof -i udp  | cpipe
# port
lsof -i:varPort__22 | cpipe
lsof -i:varPort__23__25__80__443 | cpipe
for pid in $(lsof -i:varPort | awk 'NR>1 {print $2}'); do ps -p $pid -o pid,user,%cpu,%mem,comm,args; done | cpipe
# path
lsof +D varPath__@@etc@@ | cpipe 
lsof +D varPath__@@root@@ | cpipe 
lsof +D varPath__@@script@@__@@var__@@usr | cpipe | less -RX
# install
yyay lsof 
: log-view function ; logsff
: log-view function list ; logsfff


# trash
iftop -n -P -t -s varSec__10
stdbuf -oL iftop -n -P -t -L5 | cip24
!!! systemctl restart network
hostname; [ ! -f /tmp/go_route.txt ] && route > /tmp/go_route.txt && chmod 600 /tmp/go_route.txt ; cat /tmp/go_route.txt |awk 'NR>1 1' 





%%% 네트워크 관리 [n] / DDoS 점검 (dd)
%%%e Network Management [n] / DDoS Check (dd)
%% [ -z "$offline" ] && echo "$(hostname)($([ -x timeout ] && timeout 1s hostname -i || hostname -i ))" || echo "offline" && echo "local_ip_v4:$localip// public_ip_v4:$publicip"
# ip setting
vi3 $( ls -1 /etc/sysconfig/network /etc/sysconfig/network-scripts/ifcfg-* /etc/netplan/*.yaml /etc/network/interfaces /etc/network/interfaces.new /etc/network/interfaces.org  /etc/resolv.conf /etc/hosts /etc/hostname /etc/sysctl.conf /etc/udev/rules.d/70-persistent-net.rules /etc/NetworkManager/NetworkManager.conf /run/systemd/resolve/stub-resolv.conf /etc/dhcp/dhclient.conf /etc/dhcpcd.conf 2>/dev/null )
# net restart ( safe restart? -> [rnet gosh.menu] )
!!! : debian9 ; which ifreload && ifreload -a || systemctl restart networking.service 
!!! : centos9 ; systemctl restart NetworkManager
!!! : ubuntu ; netplan $( echo try apply | pipemenu )
!!! : redhat ; /etc/init.d/network restart
# 
ping varHost__168.126.63.1
traceroute varHost__google.com || yyay traceroute
{ ip a ; echo ; ip a |gipa ; echo ; ip a | gip2 ; echo ; ip a | gip2 | awknr2; } |cip
ifconfig -a |cip
route |cip
{ ip -4 a ;echo; ip r ;echo; ip l ;echo; ip -4 n; } | cip
# iface top / iface speed check  
iftop
iftop -n -P -t || yyay iftop
nload $(shopt -s nullglob; basename -a /sys/class/net/e{n,t}*) || ay nload
bmon -p "$( (shopt -s nullglob; basename -a /sys/class/net/e{n,t}*) | paste -sd ',' )" || ay bmon
ethtool $( ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | pipemenu ) | cgrep "Speed:"
ethtool -s $( ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | pipemenu ) autoneg on
# firewall / iptables
!!! ufw $(echo "enable disable"|pipemenu)
!!! iptables -F
iptables-save > ~/_iptables_save.$(datetag2) && tail ~/_iptables_save.$(datetag2)
iptables -L -v -n 
# dig
host -a varHost varDNS__168.126.63.1 | cip 
# my ip
who am i|awk -F'[():]' '{print $3}'
# interface
ip -br a | awk '$3 != "" {print $1, $3}' | cip
ip l | awk -F ': ' '/^[0-9]+:/ {gsub(/:$/, "", $2); if ($2 != "lo") print $2}'
# public_ip 
curl -m1 -s icanhazip.com || wget -qO- icanhazip.com || curl -m1 -s checkip.amazonaws.com
# subnetcalc 
subnetcalc varIPCIDR__192.168.0.1@@26 || yyay subnetcalc




# trash
# nmtui network-manager 
nmcli || { yyay network-manager || yyay NetworkManager ; nmcli ; }
nmtui || { yyay network-manager net-tools NetworkManager-tui wget curl ; nmtui ; }
# ipv6 off
echo -e "net.ipv6.conf.all.disable_ipv6 = 1\nnet.ipv6.conf.default.disable_ipv6 = 1\nnet.ipv6.conf.lo.disable_ipv6 = 1\n" >> /etc/sysctl.conf && vi2 /etc/sysctl.conf && sysctl -p




%%% {submenu_hidden}DDoS 공격 관리 [dd]
%%%e {submenu_hidden}DDoS Attack Management [dd]
# IP 추출/차단시 제외할 아이피 목록을 설정 (/tmp/go_exceptips.private.txt or go.env)
# ex) 127.0.0.0|123.123.123.0|255.255.255.0
%% nobanip="127.0.0.0|61.111.255.0|61.111.254.0|210.118.193.0" ; ( [ -s /tmp/go_exceptips.private.txt ] && cat /tmp/go_exceptips.private.txt || echo "$nobanip" ) | tr '|' '\n' > /tmp/go_exceptips.txt ; chmod 600 /tmp/go_exceptips.txt
%% [ ! -f /tmp/go_route.txt ] && route > /tmp/go_route.txt && chmod 600 /tmp/go_route.txt ; cat /tmp/go_route.txt | awk '{while(match($0, /[0-9]+\.[0-9]+\.[0-9]+/)) {print substr($0, RSTART, RLENGTH) ".0"; $0 = substr($0, RSTART+RLENGTH)}}' | sort -u >> /tmp/go_exceptips.txt
%% who am i|awk -F'[()]' '{print $2}' | awk -F. '{print $1"."$2"."$3".0"}' >> /tmp/go_exceptips.txt
%% grep -v '^\s*$' /tmp/go_exceptips.txt | sed -e 's/\([0-9]*\.[0-9]*\.[0-9]*\.\)[0-9]*/\1/' > /tmp/go_exceptips_grep.txt ; chmod 600 /tmp/go_exceptips_grep.txt # 아이피세자리 
%% echo "Exceptips(/24): $(cat /tmp/go_exceptips.txt|grep -v '^\s*$'|sort -u|tr "\n" " ")"
# 아이피 랭킹 port 22~25 / 53 / 80 ---> ip & port count
na="$(netstat -anp)" ; { echo "$na" | gip | eip5 | sort -k5 ; echo ; ip_ranking="$(echo "$na" | awk '($4 ~ /:(443|80|22|23|24|25|53)$/) && ($5 ~ /:/) { split($4, svr_ip_port, ":"); split($5, ip_port, ":"); if (ip_port[2] > 999) { split(ip_port[1], ip_parts, "."); print ip_parts[1] "." ip_parts[2] "." ip_parts[3] ".0", svr_ip_port[2] } }' | sort | uniq -c| sort -nr | eip )" ; sorted_ip_ranking="$(echo -e "$ip_ranking" | sort -k2)" ; paste <(echo -e "$ip_ranking") <(echo -e "$sorted_ip_ranking") | column -t ; } | cip16
# 제한치(hit) 보다 상회하는 아이피 추출 ( >= $hit )
hit=varHIT ; netstat -anp | awk '($4 ~ /:(443|80|22|23|24|25|53)$/) && ($5 ~ /:/) { split($5, ip_port, ":"); if (ip_port[2] > 999) { split(ip_port[1], ip_parts, "."); print ip_parts[1] "." ip_parts[2] "." ip_parts[3] ".0" } }'|sort|eip|uniq -c|sort -nr | awk -v hit=$hit '{if($1>=hit) print $2}' > /tmp/go_ddosips.txt ; chmod 600 /tmp/go_ddosips.txt ; cat /tmp/go_ddosips.txt | tee /dev/tty | sed -e 's/.0$/./g' > /tmp/go_ddosips_grep.txt ; chmod 600 /tmp/go_ddosips_grep.txt
# 추출 아이피 차단 (추출한지 5분 이내)
!!! [ -s /tmp/go_ddosips.txt ] && [ "$(find /tmp/go_ddosips.txt -mmin -5)" ] && for i in $( cat /tmp/go_ddosips.txt ) ; do echo "iptables -A INPUT -s ${i%/*}/24 -j DROP" ; done > /tmp/go_ddosipsban.txt && for i in $( cat /tmp/go_ddosips.txt ) ; do echo "iptables -D INPUT -s ${i%/*}/24 -j DROP" ; done > /tmp/go_ddosipsbanrev.txt && chmod 600 /tmp/go_ddosipsban.txt /tmp/go_ddosipsbanrev.txt && echo && bash /tmp/go_ddosipsban.txt && echo ">>> 차단완료" &&  cat /tmp/go_ddosipsban.txt && echo ">>> 방화벽 차단내역 조회" && iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | grep -Ef /tmp/go_ddosips.txt
# 추출한 아이피 whois 조회 
for i in $( cat /tmp/go_ddosips.txt ) ; do echo "$i" ; whois -h whois.nic.or.kr $i ; readx ; echo ; done 
# 추출 아이피 차단 해제 
bash /tmp/go_ddosipsbanrev.txt && echo -e  ">>> 해제완료" && cat /tmp/go_ddosipsbanrev.txt
# 최근 차단 아이피 조회 // 추출 아이피 차단 조회
iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | gip | cip
iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | grep -Ef /tmp/go_ddosips.txt | gip | cip
# 예외 설정 아이피 확인 
cat /tmp/go_exceptips.txt ; echo ; cat /tmp/go_exceptips_grep.txt ; 
# 아이피 수동 차단 (다수 아이피 가능) 
ips="varIPS" ;"$( echo ipban ipban24 ipban16 | pipemenu )" $ips
# 아이피 수동 해제 (다수 아이피 가능)
iptables -L -v -n | tail -n20 | gip | cip16 ;; "$( echo ipallow ipallow24 ipallow16 | pipemenu )" "varIPS"
# 웹로그 server-status // dom sort
while :; do weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip24 ; echo ; printf "5초후 리프래시 or 종료시 -> [Enter] " && read -t5 -n1 x && break ; echo ; done
# 웹로그에서 추출 아이피 검색 및 차단
weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip16 |grep -Ef /tmp/go_ddosips_grep.txt
weblogresult="$(weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip16 |grep -Ef /tmp/go_ddosips_grep.txt)" ; echo -e "$weblogresult" ; ipban24 "$(echo "$weblogresult" | awk '{print $11}'| noansi| seen |pipemenu1cancel)" 









%%% {submenu_lamp}>Linux 기본 명령어 & 시스템 관리 [flow_linux_basic]
%%%e {submenu_lamp}>Linux Basic Commands & System Mgmt [flow_linux_basic]
%% echo "기본적인 파일/시스템/네트워크 관리 및 진단 명령어 모음입니다."
%% echo "각 항목을 선택하여 작업을 수행하고, 엔터 또는 'b'로 돌아오세요."
%% echo "서버 운영 및 개발 관련 도구는 [flow_linux_adv] 메뉴를 이용하세요."
#----------------------------------------------------------------------
: === 파일 및 디렉토리 ===
:   (탐색) 텍스트 파일 탐색기 실행 ; ex
:   (검색) 파일/폴더 검색 상세 옵션 ; find
:   (권한) Sticky bit, SetGID, SetUID 이해 ; stbit
:   (임시) 임시 파일/폴더 생성 및 난수 활용 ; tmp
#----------------------------------------------------------------------
: === 시스템 상태 및 프로세스 === ; p
:   (정보) 시스템 기본 정보 종합 확인
:   (프로세스) 실행 중 프로세스 확인 및 제어 (top, ps, kill...)
:   (성능) 시스템 부하 및 성능 지표 확인 (vmstat, iostat...)
:   (로그인) 현재/과거 사용자 접속 이력 확인 (who, w, last...)
#----------------------------------------------------------------------
: === 네트워크 기본 확인 === ; n
:   (설정) IP 주소, 라우팅 테이블, 인터페이스 상태 확인/설정
:   (연결) 대상 호스트 연결 테스트 (ping, traceroute)
:   (포트) 현재 열려있는 네트워크 포트 확인 (netstat, ss)
:   (DNS) 도메인 네임서버 정보 조회 (dig, nslookup, host) ; dig
#----------------------------------------------------------------------
: === 디스크 및 파일 시스템 === ; f
:   (용량) 디스크 사용량 및 마운트 정보 확인 (fstab 편집)
:   (상태) 하드 디스크 건강 상태 점검 (S.M.A.R.T.)
:   (Swap) 스왑 메모리 공간 확인 및 관리 ; swap
:   (파티션) 디스크 파티션 정보 확인/관리 (fdisk, parted) ; varS__f__sgdisk
#----------------------------------------------------------------------
: === 사용자 및 패키지 === ; u
:   (사용자) 계정 생성/수정/삭제, 그룹 및 권한 관리
:   (패키지) 기본 패키지 설치/삭제/검색 (apt/yum) ; a
#----------------------------------------------------------------------
: === 쉘 환경 및 기본 유틸 ===
:   (환경변수) 현재 환경변수 확인 및 설정 파일 편집 ; en
:   (편집기) Vim 환경 설정 및 vi/vim 별칭 사용 ; vi
:   (터미널세션) Screen / Tmux 사용법 (세션 유지/분할) ; varS__x__xx
:   (작업예약) At (일회성) / Cron (반복성) 작업 스케줄링 ; at
:   (인코딩 등) URL/Base64, 암호화/복호화 유틸 ; enc
:   (TUI 생성) Dialog/Whiptail 사용 예제 ; dia
#----------------------------------------------------------------------
: (다음) 서버 운영 & 개발 도구 메뉴로 이동 ; flow_linux_adv




%%% {submenu_lamp}>서버 운영 & 개발 관련 도구 [flow_linux_adv]
%%%e {submenu_lamp}>Server Ops & Development Tools [flow_linux_adv]
%% echo "서버 운영, 백업, 보안 및 개발 관련 도구 모음입니다."
%% echo "각 항목을 선택하여 작업을 수행하고, 엔터 또는 'b'로 돌아오세요."
%% echo "기본 명령어 및 시스템 관리는 [flow_linux_basic] 메뉴를 이용하세요."
: === 서버 데몬 및 서비스 === 
:   (상태/제어) 시스템 서비스(데몬) 관리 (systemctl, service) ; d
:   (UFW 방화벽 관리) 간단한 UFW 기반 설정 및 로그 ; ufw  
:   (FirewallD 고급 설정) 영역 기반 서비스/포트 제어 ; firewalld
#----------------------------------------------------------------------
: === 데이터베이스 관리 ===
:   (MySQL/MariaDB) DB 접속 및 기본 관리 명령어 ; mysql
:   (PostgreSQL) DB 접속 및 기본 관리 명령어 ; psql
#----------------------------------------------------------------------
: === 백업, 동기화, 스토리지 === ; lb
:   (원격백업) 대용량 원격 백업 스크립트 (ncp 등) ; rb
:   (버전백업) 변경 이력 추적 백업 (rdiff-backup) ; rdiff
:   (클라우드) Rclone 클라우드 스토리지 연동/관리 ; varS__cc__rclone__rclones
:   (NFS) 네트워크 파일 시스템 설정 ; nfs
:   (AutoFS) NFS 자동 마운트 설정 ; afs
:   (iSCSI) 블록 스토리지 네트워크 공유 설정 ; varS__iss__isc
:   (LVM) 고급 디스크 볼륨 관리 ; lvm
#----------------------------------------------------------------------
: === 보안 강화 === 
:   (Fail2ban) 침입 시도 자동 IP 차단 설정 ; ban
:   (SSH 보안) SSH 접속 설정 및 키 페어 관리 ; s
:   (DDoS 방어) DDoS 공격 관리 도구 (IP 차단 등) ; dd
:   (SSL/TLS) LetsEncrypt SSL 인증서 발급/관리 ; ssl
#----------------------------------------------------------------------
: === 네트워크 고급 기능 ===
:   (대역폭조절) 네트워크 속도 제한 설정 (Wondershaper) ; band
:   (네트워크스캔) 내부 네트워크 장비 탐색 (arp-scan) ; nn
:   (SSH터널링) 역방향/포워드 터널링 활용 ; tn
#----------------------------------------------------------------------
: === 개발 및 버전 관리 === 
:   (Git) Git/GitHub 기본 사용법 ; git
:   (패키지 확장) snap_Pip 패키지 관리 ; varS__aa__js
:   (자동화) Ansible 서버 관리 자동화 기초 ; ansible
#----------------------------------------------------------------------
: === 기타 서버 유틸리티 ===
:   (모바일Linux) Termux 환경 설정 (Android) ; ter
:   (채팅) 콘솔 IRC 클라이언트 사용 ; irc
:   (인코딩변환) 터미널 인코딩 변환 도구 (luit) ; luit
:   (메신저) Telegram CLI (명령줄 텔레그램) ; tg
:   (모니터링) Nagios 호환 CLI 모니터링 도구 ; na
#----------------------------------------------------------------------
: (이전) 기본 명령어 & 시스템 관리 메뉴로 이동 ; flow_linux_basic



%%% {submenu_lamp_ext}UFW 방화벽 관리 [ufw]
%%%e {submenu_lamp_ext}UFW Firewall Management [ufw]
: Status and enable ; ufw status verbose
: Set default policy ; ufw default allow outgoing && ufw default deny incoming
: Allow basic ports 22, 80, 443 ; ufw allow 22 && ufw allow 80 && ufw allow 443
: Allow custom port ; ufw allow varPort__8080
: Allow from specific IP ; ufw allow from varIP
: Deny from specific IP ; ufw deny from varIP
: Allow with proto,IP,port ; ufw allow proto varProto__tcp__udp from varIP to any port varPort__10000
: Delete allow rule (by port) ; ufw delete allow varPort__22
: Delete deny rule (by IP) ; ufw delete deny from varIP
: Enable and disable ; ufw enable && ufw disable
: Reset all rules ; ufw reset
: Reload and show numbered rules ; ufw reload && ufw status numbered
: Show UFW logs ; tail -n 200 /var/log/ufw.log | cpipe | less -RX


%%% {submenu_lamp_ext}firewalld 방화벽 관리 [firewalld]
%%%e {submenu_lamp_ext}FirewallD Management [firewalld]
: Status and default zone ; firewall-cmd --state && firewall-cmd --get-default-zone
: Show active zones ; firewall-cmd --get-active-zones
: Show current zone config ; firewall-cmd --list-all
: Show all zones ; firewall-cmd --list-all-zones | less
: Add service to firewall ; firewall-cmd --permanent --add-service=varSvc__http__https__ssh
: Add custom port ; firewall-cmd --permanent --add-port=varPort__1234/tcp
: Remove custom port ; firewall-cmd --permanent --remove-port=varPort__1234/tcp
: Add IP reject rule ; firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="varIP" reject'
: Remove IP reject rule ; firewall-cmd --permanent --remove-rich-rule='rule family="ipv4" source address="varIP" reject'
: Reload config ; firewall-cmd --reload
: Save runtime to permanent ; firewall-cmd --runtime-to-permanent
: Show firewalld logs ; journalctl -u firewalld -n 200 | cpipe | less -RX



%%% 파일시스템 관리 [f] / (lvm) (swap)
%%%e File System Management [f] / (lvm) (swap)
%% echo -n "HDD: " ; lsblk -d -n -o name | oneline
mount | cpipe
# mount all from fstab
vi2 /etc/fstab
mount -a ; df -h | cper 
df -h | cper
fdisk -l | cpipe | less -RX ;; parted -l | cpipe | cgrepline Model | less -RX ;; { lsblk ; echo ; blkid ; } | less -RX
fdisk -l /dev/varHDD__sda__sdb__sdc__nvme0n1__nvme0n1
sgdisk -p /dev/varHDD
lsblk ;; fdisk /dev/varHDD
blkid | grep varFind
blkid /dev/varPart__sda1__sda2__sdb1__sdb2__nbme0n1p1
# S.M.A.R.T. 
smartctl -a /dev/$( lsblk -d -n -o name | pipemenu ) | cgrep1 "Size/Capacity" "Model Number" PASSED FAILED UNKNOWN | cgrep Reallocated_Sector_Ct Power_On_Hours Reported_Uncorrect Reallocated_Event_Count "Critical Warning" "Percentage Used" Temperature | less -RX
yyay smartmontools 
# uuid -> tee -a fstab 
cat /etc/fstab ;; blkid ;; blkid2fstab /dev/varPARTITION varDIR && mkdir -p varDIR && vi2 /etc/fstab
# mkfs
!!! fdisk -l ;; "$( ls -1 /usr/sbin/mkfs* |pipemenu1 )" /dev/varPARTITION
# mkfs.ext4 all/selected Linux partition
!!! fdisk -l ;; echo ; for i in $( fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}' ) ; do mkfs.ext4 $i ; done
!!! fdisk -l ;; echo ; mkfs.ext4 $(fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}' |pipemenu1)
# mkfs.seleted any partition
!!! fdisk -l ;; mkfs=$( basename -a /usr/sbin/mkfs.* | pipemenu ) ; $mkfs /dev/$(lsblk -l -o name,type|grep part| pipemenu1 )
# umount /tmp force
!!! fuser -km /tmp ; umount /tmp
# pid kill -> fsck
!!! df ;; fuser -km varMountDIR ; umount varMountDIR ; e2fsck -jp -y /dev/varPATITION ; mount /dev/varPARTITION varMountDIR ;
!!! umount /dev/varPARTITION ; e2fsck -jp -y /dev/varPARTITION
# hdd speed test
hdparm -t /dev/varHDD
# mount all Liuux part /dev/sdb1 -> /mnt/sdb1 
for i in $( fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}'|awk -F/ '{print $3}' ); do mkdir /mnt/$i; mount /dev/$i /mnt/$i; done ; df
# growpart /dev/sda 3 
!!! growpart /dev/varDEV varPARTNO || ay cloud-guest-utils
# fdisk -> reboot -> resize2fs /dev/sda3
!!! resize2fs /dev/varPARTNO
# install
yyay varPkg__exfat-fuse__exfatprogs__dosfstools__ntfs-3g



%%% >시스템 초기설정과 기타 [i]
%%%e >System Initial Settings and Others [i]
{submenu_sys}





%%% 로컬백업 [lb] / 원격백업 (rb)
%%%e Local Backup [lb] / Remote Backup (rb)
mkdir -p varBackupDIR__@@backup ; chmod 700 varBackupDIR__@@backup
# etc backup
rbackup /etc/passwd /etc/shadow /etc/group /etc/crontab /etc/named.conf /etc/fstab /etc/hosts 
# /etc /root 압축백업 
rbackup varBackupDIR__@@backup/etc_daily.tgz ; tar cvzf varBackupDIR__@@backup/etc_daily.tgz /etc/ 
rbackup varBackupDIR__@@backup/root_daily.tgz ; tar cvzf varBackupDIR__@@backup/root_daily.tgz --exclude=/root/.cache /root/
# 지정폴더 압축백업 
f="$(basename varDestFolder)" ; rbackup varBackupDIR__@@backup/$f.tgz ; tar -cvzf varBackupDIR__@@backup/$f.tgz varDestFolder ; ls -al varBackupDIR__@@backup/$f.tgz ; push
f="$(basename varDestFolder)" ; rbackup varBackupDIR__@@backup/$f.tgz ; tar -I zstd -cvf varBackupDIR__@@backup/$f.zst varDestFolder ; ls -al varBackupDIR__@@backup/$f.zst ; push
#
# rsync 증분백업 로컬 (삭제/변경된파일 원본유지) 백업본1,백업본7*24
# cron 에 삽입시에는 % 앞에 역슬래시 추가 
rsync -ar --backup --suffix=.bak --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@ ; push
rsync -ar --backup --suffix=.bak_$(date +%w%H) --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@ ; push
# rsync 동기화백업 로컬
rsync -arz --delete --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@ ; push
# rsync 증분백업 로컬->원격(압축전송) // (삭제/변경된파일 원본유지)
rsync -arz --backup --suffix=.bak --exclude='varExclude__@@.err@@' varRhost:varSource__@@home varBackupDIR__@@backup@@ ; push
rsync -arz --backup --suffix=.bak_$(date +%w%H) --exclude='varExclude__@@.err@@' varRhost:varSource__@@home varBackupDIR__@@backup@@ ; push
# rsync 동기화백업 로컬->원격(압축전송)
rsync -arz --delete --exclude='varExclude__@@.err@@' varSource__@@home varRhost:varBackupDIR__@@backup@@ ; push
#
# lftp 증분백업 로컬->원격 (s?ftps?,https?,fish,torrent)
lftp -u varUsername,varPassword ftp://varRhost -e "set ftp:list-options -a; lcd varSource__@@home; cd varBackupDIR__@@backup@@home ; mirror --exclude-glob varExclude__@@.err@@ ; bye"
# lftp 동기화백업 로컬->원격 
lftp -u varUsername,varPassword ftp://varRhost -e "set ftp:list-options -a; lcd varSource__@@home; cd varBackupDIR__@@backup@@home ; mirror --delete --exclude-glob varExclude__@@.err@@ ; bye"
#
# dbs all dump
mkdir -p varBackupDIR__@@backup@@mysqldump/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1'); do echo "$i DB dumping..." ; mysqldump -Q $i | gzip > varBackupDIR__@@backup/${i}.$(datetag1).sql.gz; done ;  chmod 600 varBackupDIR__@@backup@@mysqldump/*.sql.gz
# dbs all dump // week rotate
mkdir -p varBackupDIR__@@backup@@mysqldump/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1'); do echo "$i DB dumping..." ; mysqldump -Q $i | gzip > varBackupDIR__@@backup/${i}.$(datetagw).sql.gz; done ;  chmod 600 varBackupDIR__@@backup@@mysqldump/*.sql.gz
#
yyay lftp rsync



%%% {submenu_hidden}원격 백업 관리 [rb]
%%%e {submenu_hidden}Remote Backup Management [rb]
%% (( $(screen -ls|grep -c tached) == 0 )) && unset -v $STY
%% [ -z "$STY" ] && screen -S "remote_backup_longtime_task" bash -c "echo && echo \"$(RED1)remote_backup_longtime_task 작업을 screen 세션으로 전환합니다...$(RST)\" && sleep 2 && screen -list && sleep 1 && $0 $scut ; exec bash"
# !!! 작업이 오래 걸리는 경우, screen 사용 / 간헐적 네트웍 단절로 중단 방지
# 이 메뉴는 screen 실행후, 진입하여 실행됩니다. 종료는 ctrlC + ctrlD
# 이미 screen 속인 경우, 중복 진입은 하지 않습니다.
# 
# 원격지 홈폴더 select 백업 (ncp) // pv 진행바 // zstd 네트워크 효율 좋음 
trap "echo 'Interrupted. Exiting...'; exit 1" INT ; list="$( ssh varRhost "find / -maxdepth 2 -type d \( -regex \"/home[^/]*\" -o -regex \"/home.*/.*\" -o -regex \"/backup/mysqldump/.*\"  \)" )" ; d="$(echo "$list"|pipemenu1cancel)" ; [ "$d" ] && [[ ! "$d" == *Cancel* ]] && { echo -n "Execute: ncp varRhost $d varLocalPath varPort__22 [Enter] " && read x && mkdir -p varLocalPath && time ncp varRhost $d varLocalPath varPort__22 && ls -al varLocalPath ; } ; bell
# 
# 원격지 선택 폴더 하부의 숨김폴더 제외 하고 각각 백업 ex) /home/{all but .hide} 
# 제외할 폴더 다수개 입력 가능 var1 var2 -> */var1* */var2*
# 로컬에 복사할 폴더가 있는 경우 skip (이어받기 가능)
trap "echo 'Interrupted. Exiting...'; exit 1" INT ; pwd;; h="varRhost"; d="varRBackupFolderPath"; l="varLocalPath"; except="varExcept"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : " ; echo $list ; echo ; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list ; do [ ! -d $l$i ] && { CYN ; echo "[$count/$total_count] $i copying... " && ncp $h $(realpathf $i) $l$d varPort__22 ; } || { RED1 ; echo "[$count/$total_count] $i skipped... " ; } ; count=$((count+1)); echo ; done ; } ; cd $l ; push1
#
# 원격지 폴더 로컬에 압축파일로 저장 // 기존재 파일 skip 지원 // ex) /home 계정별 압축 
trap "echo 'Interrupted. Exiting...'; exit 1" INT ; pwd;; h="varRhost"; d="varRBackupFolderPath"; l="varLocalPath"; except="varExcept"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : "; echo $list; echo; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list; do [ ! -f "${l}${d}/$h.$(basename "$i").tar.zst" ] && [ ! -f "${l}${d}/$h.$(basename "$i").tgz" ] && { CYN ; echo "[$count/$total_count] $i copying... " && ncpzip $h $(realpathf $i) $l$d varPort__22 ; } || { RED1 ; echo "[$count/$total_count] $i skipped... " ; } ; count=$((count+1)); echo; done ; } ; cd $l ; push1
#
# 업데이트된 파일만 추가 백업 // 기존 백업 tar.zst or tgz 파일을 참조함 
trap "echo 'Interrupted. Exiting...'; exit 1" INT ; pwd;; h="varRhost"; d="varRBackupFolderPath"; l="varLocalPath"; except="varExcept"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : "; echo $list; echo; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list; do [ -f "${l}${d}/$h.$(basename "$i").tar.zst" ] || [ -f "${l}${d}/$h.$(basename "$i").tgz" ] && { CYN ; echo "[$count/$total_count] $i update checking... " && ncpzipupdate $h $(realpathf $i) $l$d varPort__22 ;RST; } || { RED ; echo "[$count/$total_count] $i skipped... ";RST ; } ; count=$((count+1)); echo; done ; } ; cd $l ; find ./ -type f -size 0 -exec rm {} \; push1;
# ncp -> zstd scp
ncp varRHost varRPath varLocalPath varPort__22 ; bell ; explorer varLocalPath 
ncpr varLocalPath varRHost varRPath varPort__22 ; bell ;
ncpzip varRHost varRPath varLocalPath__@@backup varPort__22 ; bell;
ncpzipupdate varRHost varRPath varLocalPath__@@backup varPort__22 ; bell;
# 하드 I/O (df) && process monitor 
dfmonitor
# 네트워크 모니터 bmon func
bm
# 네트워크 속도 제한(TX/RX)
eth=$( basename -a /sys/class/net/e* | pipemenu ) ;; wondershaper -c -a $eth ; wondershaper -a $eth -d $(( varDownMbps__40__50__60__70__80__100 * 1024 )) -u $(( varUpMbps__40__50__60__70__80__100 * 1024 ))





%%% 클라우드 관리 [cl] / rclone (cc)
%%%e Cloud Management [cl] / rclone (cc)
# ncp 서버간 압축(tar/zstd) 전송(ssh) 함수 
# ncp(원격지파일폴더->로컬로복사)// ncpr(로컬파일폴더->원격지서버로복사)// ncpzip(tgz저장)
ncp varRHost varRPath varLocalPath varPort__22 ; push ; explorer varLocalPath
ncpr varLocalPath varRHost varRPath varPort__22 ; push
ncpzip varRHost varRPath varLocalPath__@@backup varPort__22 ; push
ncpzipupdate varRHost varRPath varLocalPath__@@backup varPort__22 ; push
# mount point 
mkdir -p /mnt/varLocalDIR; ls -al /mnt/varLocalDIR
#
# 원격지(ssh) 폴더를 로컬 폴더로 마운트 (sshfs:sftp)
sshfs root@varRhost:varRDIR /mnt/varLocalDIR 
# screen 내에서 계속 마운트 유지 --> go.sh 종료되도 유지 
scserver "sshfs root@varRhost:varRDIR /mnt/varLocalDIR" ;; df |grep /mnt|cgrep varLocalDIR ; sleep 1 ; ls -ltr /mnt/varLocalDIR |tail -n10
# 원격지(ftp) 폴더를 로컬 폴더로 마운트 (curlftpfs:ftp)
# curlftpfs ftp://[FTP_계정]:[FTP_비밀번호]@[FTP_서버_주소]:[FTP_포트]/[원격_FTP_경로] [로컬_마운트_디렉토리]
curlftpfs varFTPid:varFTPpw@varRhost:varPort__21/varRDIR /mnt/varLocalDIR 
scserver "curlftpfs varFTPid:varFTPpw@varRhost:varPort__21/varRDIR /mnt/varLocalDIR" ;; df |grep /mnt |cgrep varLocalDIR ; sleep 1 ; ls -ltr /mnt/varLocalDIR |tail -n1
# nfs mount 
: go nfs; nfs
mount -t nfs -o nolock varRhost:varRDIR/ /mnt/varLocalDIR
# nfs fstab add
echo "varRhost:varRDIR/ /mnt/varLocalDIR nfs nolock,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab
# smb mount
mount -t cifs -o "username=varSMBusername,password=varSMBpassword" "//varSMBhost/varRDIR/" /mnt/varLocalDIR
# smb fstab add
echo "//varSMBhost/varRDIR/ /mnt/varLocalDIR cifs credentials=/root/.smbcredentials,noperm,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab
echo -e "username=varSMBusername\npassword=varSMBpassword" >> /root/.smbcredentials && vi2 /root/.smbcredentials
#
# 언마운트 /mnt/MountPoint
df |grep "/mnt" ;; umount $(df |grep /mnt|awk99|pipemenu1) ; df|grep mnt
screen -list
# install
yyay varPKG__sshfs__fuse3__zstd__pv__smbclient__curlftpfs__nfs-common__nfs-utils
: install curlftps; curlftps




%%% {submenu_hidden}curlftps install [curlftps]
%%%e {submenu_hidden}curlftps install [curlftps]
# ftp fs --- old ubuntu 
apt install fuse libcurl4
wget http://mirrors.edge.kernel.org/ubuntu/pool/universe/c/curlftpfs/curlftpfs_0.9.2-10_amd64.deb
dpkg -i curlftpfs_0.9.2-10_amd64.deb
apt --fix-broken install





%%% {submenu_sys}한글화 / 타임존 [han]
%%%e {submenu_sys}Koreanization / Timezone [han]
# LANG 
env ; echo $LANG ; locale
locale -a
: direct ; export LANG=ko_KR.UTF-8 LC_ALL=ko_KR.UTF-8 ; env 
# apt
ay locales fonts-nanum fonts-noto-cjk
: debian ; dpkg-reconfigure locales 
# locale-gen
vi2 /etc/locale.gen
hash_add /etc/locale.gen en_US.UTF-8
hash_remove /etc/locale.gen ko_Knum fonts-noto-cjkR.UTF-8
locale-gen varLocale__ko_KR.UTF-8
update-locale
# 기본 locale 변경후 재접속시 반영 
localedef -i ko_KR -f UTF-8 ko_KR.UTF-8
localectl set-locale LANG=ko_KR.UTF-8
# /etc/default/locale edit
vi2 /etc/default/locale 
sed -i '/LANG=.*$/c\LANG=ko_KR.UTF-8' /etc/default/locale ; vi2 /etc/default/locale
echo "LC_ALL=ko_KR.UTF-8" >> /etc/default/locale ; vi2 /etc/default/locale
echo "_JAVA_OPTIONS=\"-Duser.timezone=Asia/Seoul\"" >> /etc/environment ; vi2 /etc/environment
vi3 $( ls -1 /etc/default/locale /etc/sysconfig/i18n /etc/profile.d/tmout.sh /etc/environment 2>/dev/null )
# timezone
timedatectl 
timedatectl set-timezone Asia/Seoul ; date
rdate -s $( echo zero.bora.net time.nist.gov | pipemenu ) && hwclock --systohc
ntpdate time.nist.gov || { yyay ntpdate && ntpdate time.nist.gov ; } ; hwclock --systohc
tzselect
date
echo $(date "+%Y%m%d.%H%M%S")
echo $(date "+%Y%m%d.%H%M%S")$(($RANDOM%9000+1000))
# hostname set
hostnamectl ;; hostnamectl set-hostname varNEWHostName
#
vi3 $( ls -1 /etc/hosts /etc/hostname /etc/sysconfig/hwconf /etc/modules.conf /etc/modprobe.d/modprobe.conf /etc/fstab /etc/rc.d/rc.local /etc/crontab /etc/motd /etc/resolv.conf /root/.vimrc /root/.bashrc 2>/dev/null )






%%% {submenu_sys}환경변수 설정 [en]
%%%e {submenu_sys}Environment Variable Settings [en]
%% echo "TERM: $TERM"
env
# 운용서버에서 환경파일 가져오기
scp varHost:/root/.bashrc /root/ || scp -v -oKexAlgorithms=diffie-hellman-group-exchange-sha1 -oHostKeyAlgorithms=ssh-rsa,ssh-dss varHost:/root/.bashrc /root/
vi3 $( ls -1 /root/.bashrc /etc/profile.d/tmout.sh /etc/profile /etc/systemd/system.conf ) 
# 서버 모니터 tty1 로 커널 메세지 출력 -> 레벨 조절 
cat /proc/sys/kernel/printk
# shell timemout set
grep "TMOUT" /etc/profile /etc/profile.d/*
echo "[ -z \"\$TMOUT\" ] && export TMOUT=3600" >> /etc/profile.d/tmout.sh
echo "[ -z \"\$TMOUT\" ] && export TMOUT=0" >> /etc/profile.d/tmout.sh
# 경고 이상만 출력(임시/영구)
echo "3 4 1 7" > /proc/sys/kernel/printk
echo "kernel.printk = \"3 4 1 7\"" >> /etc/sysctl.conf
# systemed 종료시 timeout 단축  
sed -i "s/\#DefaultTimeoutStopSec=90s/DefaultTimeoutStopSec=5s/" /etc/systemd/system.conf
# PS1 터미널 창제목 고정 
echo "PS1='\[\033]0;\u@\h:\w\a\] '\$PS1" >> ~/.bashrc
# 사용자가 직접 로그인한 경우에만 소스 {불러오기,실행,!break} (scp//sftp제외)
sed -i '1i [[ $- != *i* ]] && return' ~/.bashrc
echo "[[ \$- == *i* ]] && source varSourcePATH" >> ~/.bashrc
echo "[[ \$- == *i* ]] && varCommand" >> ~/.bashrc
#
# PS1 프롬프트 설정
export PS1="\[\033[1;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]$ "
export PS1="\n\033[1;33m\t \d \033[0m\033[0;32m[\u@\h \w]\033[0m\n\\$ "
# 프롬프트 적용
echo 'PS1="\[\033[1;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]$ "' >> /root/.bashrc ; vi2 /root/.bashrc
echo 'PS1="\n\033[1;33m\t \d \033[0m\033[0;32m[\u@\h \w]\033[0m\n\\$ "' >> /root/.bashrc ; vi2 /root/.bashrc
# 멀티라인 프롬프트 설정
export PS2=">"
# PS3 셀렉트 프롬프트 설정
export PS3="Select No. : "
# PS4 디버그 모드 프롬프트 설정
export PS4="+ Line \$LINENO: " ; set -x 
#
# ssh sha1 err in alma
update-crypto-policies --set DEFAULT:SHA1



%%% {submenu_sys}리눅스 최초 설치 셋업 [init]
%%%e {submenu_sys}Initial Linux Setup [init]
# 리눅스 최초 설치시 하는 작업들
# su - 과정중 쉘이 일반계정에서 root 로 바뀌면서 go.sh 를 다시 실행해야함
sudo su
sudo passwd root
su -
# ssh server
sudo apt update & sudo apt upgrade
ntpdate time.windows.com || yyay ntpdate && ntpdate time.windows.com
sudo apt install openssh-server
sudo systemctl status ssh
sudo systemctl enable --now ssh
# ssh remote -> root id/pw login
sed -i 's/^#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config
sed -i 's/^#PasswordAuthentication.*/PasswordAuthentication yes/' /etc/ssh/sshd_config
systemctl restart sshd
# port / root allow/ban set
vi2 /etc/ssh/sshd_config Root
sudo systemctl restart ssh
# ufw
sudo ufw status
sudo ufw enable
sudo ufw allow ssh
# go.sh start
wget -O go.sh http://byus.net/go.sh && bash go.sh
ln -s ${PWD}/go.sh varGO__@@bin@@g__@@bin@@go__@@bin@@gosh ;; ls -al varGO
# 
hostnamectl ;; sudo hostnamectl set-hostname varHostname
timedatectl ;; sudo timedatectl set-timezone $( timedatectl list-timezones | pipemenu )
# wheel user (sudo)
adduser varUser
passwd varUser
usermod -aG wheel varUser
usermod -aG sudo varUser
id varUser



%%% {submenu_sys}루트 로그인 설정 [root]
%%%e {submenu_sys}root login set [root]
# Ubuntu desktop // gui root login
vi2 /etc/pam.d/gdm-password
# auth required pam_succeed_if.so user != root quiet_success
hash_add /etc/pam.d/gdm-password "pam_succeed_if.so user != root quiet_success" 
hash_remove /etc/pam.d/gdm-password "pam_succeed_if.so user != root quiet_success" 
vi2 /etc/gdm3/custom.conf
echo "AllowRoot=true" | insert /etc/gdm3/custom.conf "[security]" 
systemctl restart gdm3



%%% {submenu_sys}모듈설정 [mod]
%%%e {submenu_sys}Module Settings [mod]
# pci info
lspci
lspci -v | cgrep VGA Ethernet SCSI SATA CPU | less -RX
lspci | grep -E 'VGA|Ethernet|SCSI|SATA|Audio|USB'
lsusb 
lshw | cpipe | less -RX
dmidecode | cgrepn "Type:" 1 | cgrepn GB MB -2 | less -RX
udevadm info -q all -n /dev/varDev__sda__sdb__nvme0n1__nvme1n1
: event monitor ; trapf udevadm monitor
dmesg | cpipe | less -RX
inxi -Fxz
hwinfo
# module add/remove
lsmod
depmmod
modprobe varModule
insmod varModule
rmmod varModule
modinfo varModule
modinfo $(lsmod|awk1|pipemenu) | cpipe |less -RX -G
kudzu
explorer /etc/
# install
yyay varPKG__lshw__hwinfo__inxi 






%%% {submenu_sys}메일 클라이언트와 SMTP [mailc]
%%%e {submenu_sys}mail client & local smtp [mailc]
%% echo "myemail:$myemail"
yyay varPkg__neomutt__bsd-mailx__aerc
# 기능성과 유연성 중시: neomutt // q // i 
: mail client ; neomutt ; [ ! -e /usr/bin/mutt ] && ln -s /usr/bin/neomutt /usr/bin/mutt
echo "set editor = \"vim\"" >> ~/.neomuttrc
: test ; echo "syslog" | neomutt -s "syslog file add" -a /var/log/syslog -- root
: test ; echo "varMsg" | neomutt -s "varSubject" varMailadd__root 
neomutt -s "varSubject" varMailadd__root 
# 스크립트 자동화 중심: mailx / 메일을 ~/mbox 로 이동금지 
echo -ne "set hold\nset keep\n" >> ~/.mailrc
: mail clinet ; mail
export myemail="varEmail"
: test ; echo "test mail from relay account $(hostname)" | mail -s "testmail" $myemail
: test ; echo "test mail to root local account $(hostname)" | mail -s "testmail" root ;; ls -al /var/spool/mail/
: mail log ; grep "postfix/local" /var/log/mail.log | tail -n 20
# 외부 메일계정을 cli 환경에서 체크 (default: gmail)
: mail client ; aerc
# #####################################
# localhost smtp relay ----> gmail smtp
# #####################################
yyay varPkg__postfix__mailutils
template_edit smtp.relay.cf
template_view smtp.relay.cf
!!! template_insert smtp.relay.cf /etc/postfix/main.cf  ;; cat "$lastarg"
vi3 /etc/postfix/main.cf /etc/aliases $HOME/.forward $HOME/.mailrc
# alias / forward set
: alias add; echo "root: root, varEmail" >> /etc/aliases ;; cat "$lastarg" ; newaliases
: forward toggle; [ -f /root/.forward.disabled ] && mv /root/.forward.disabled /root/.forward || mv /root/.forward /root/.forward.disabled ; ls -al /root/.forward*
# 구글 계정 관리 > 보안 > 2단계 인증 > 앱 비밀번호 설정
echo "[smtp.gmail.com]:587 varGmailid@gmail.com:varGmailAppPW" >> /etc/postfix/sasl_passwd
postmap /etc/postfix/sasl_passwd && chown root:root /etc/postfix/sasl_passwd /etc/postfix/sasl_passwd.db && chmod 600 /etc/postfix/sasl_passwd /etc/postfix/sasl_passwd.db
vi2 /etc/postfix/sasl_passwd
systemctl reload postfix
: relayhost view; postconf relayhost
: relay local; grep mydestination /etc/postfix/main.cf
# ###################
# cf. self smtp relay
: go postfix set; m1






%%% {submenu_sys}서버 셋업 보안/퍼미션 관리 [se]
%%%e {submenu_sys}Server Setup Security/Permission Management [se]
# file perm
chmod 700 /usr/bin/chage /usr/bin/wall /usr/bin/write /bin/dd /bin/mount /bin/umount /bin/rpm /usr/bin/finger
chmod 700 /usr/bin/top /usr/bin/uptime /usr/bin/whereis /usr/bin/which /usr/bin/lwp-download /usr/bin/nslookup /usr/bin/lsof
chmod 700 /usr/bin/cc /usr/bin/gcc /usr/bin/make /usr/bin/pstree /usr/bin/rlogin /usr/bin/rlog /bin/mount /bin/umount
# wheel perm
chmod 750 /bin/ps /bin/netstat /bin/dmesg /bin/df /usr/bin/who /usr/bin/finger /usr/bin/last /usr/bin/lastlog /usr/bin/top /usr/bin/w /bin/uname
chgrp wheel /bin/ps /bin/netstat /bin/dmesg /bin/df /usr/bin/who /usr/bin/finger /usr/bin/last /usr/bin/lastlog /usr/bin/top /usr/bin/w /bin/uname
#
cat /etc/group|grep  "," ;; usermod -aG varGroup__wheel varSudoUSER
# folder perm
chmod 711 / /dev /etc /home* /initrd /lib /var/log /var/log/httpd /var /usr
chmod 700 /boot /mnt /root
# service folder create
mkdir -p /backup /ban /script /scriptuser /homein/expire /home1/expire /home/expire /clone
chmod 700 /backup /ban /script /home1/expire /homein/expire /home/expire /clone
#
# 주요 실행 명령 변조대비 백업
[ ! -d /root/bin/ ] && mkdir -p /root/bin/ && cp -a /bin/netstat /usr/bin/top /bin/login /usr/bin/dir /usr/bin/find /usr/bin/pstree /usr/bin/md5sum /bin/ls /bin/ps /sbin/ifconfig /root/bin/ && chattr +i /root/bin/
[ ! -d /bin.backup ] && cp -a /bin/ /bin.backup && chmod 700 /bin.backup && chattr +i /bin.backup
[ ! -d /sbin.backup ] && cp -a /sbin/ /sbin.backup && chmod 700 /sbin.backup && chattr +i /usr/bin.backup
[ ! -d /usr/bin.backup ] && cp -a /usr/bin/ /usr/bin.backup && chmod 700 /usr/bin.backup && chattr +i /usr/bin.backup



%%% {submenu_sys}서버 웹관리 솔루션 설치 (webmin/perl) [webmin]
%%%e {submenu_sys}Server Web Management Solution Installation (webmin/perl) [webmin]
%% echo "https://$publicip:10000" ; [ "$publicip" == "$(hostname -i)" ] && echo "https://$(hostname):10000"
# webmin_ubuutu repo
curl -s http://www.webmin.com/jcameron-key.asc | apt-key add -
add-apt-repository "deb [arch=amd64] http://download.webmin.com/download/repository sarge contrib" || ay software-properties-common && add-apt-repository "deb [arch=amd64] http://download.webmin.com/download/repository sarge contrib"
# webmin_centos repo
curl -O http://www.webmin.com/jcameron-key.asc
rpm --import jcameron-key.asc
vi2 /etc/yum.repos.d/webmin.repo
printf "[Webmin] \nname=Webmin Distribution Neutral\nbaseurl=http://download.webmin.com/download/yum\nenabled=1\ngpgcheck=1\ngpgkey=http://www.webmin.com/jcameron-key.asc" >> /etc/yum.repos.d/webmin.repo
# webmin install
yyay webmin
# firewall port open
ufw allow 10000 || firewall-cmd --add-port=10000/tcp --permanent && firewall-cmd --reload
# website (guide: http://www.webmin.com)
systemctl status webmin
systemctl start webmin && systemctl enable webmin
systemctl stop webmin && systemctl disable webmin






%%% {submenu_sys}서버 웹관리 솔루션 설치 (cockpit/perl) [cockpit]
%%%e {submenu_sys}Server Web Management Solution Installation (cockpit/perl) [cockpit]
%% echo https://$publicip:9090 ; [ "$publicip" == "$(hostname -i)" ] && echo https://$(hostname):9090
yy epel-release 
yyay cockpit
# firewall port open
ufw allow 9090
firewall-cmd --add-service=cockpit &&  firewall-cmd --add-service=cockpit --permanent
# centos repo add
curl -O /etc/yum.repos.d/cockpit.repo https://copr.fedorainfracloud.org/coprs/g/cockpit/cockpit-preview/repo/epel-7/group_cockpit-cockpit-preview-epel-7.repo
systemctl start cockpit ; systemctl enable cockpit
# website (guide: https://cockpit-project.org)
dpkg-query -l cockpit-system || yyay cockpit-system
# AllowUnencrypted = true
vi2 /etc/cockpit/disallowed-users
systemctl restart cockpit 
#
systemctl status cockpit
systemctl start cockpit && systemctl enable cockpit
systemctl stop cockpit && systemctl disable cockpit
lsof -i:9090



%%% {submenu_sys}응급 복구 / 시동 [r]
%%%e {submenu_sys}Emergency Recovery / Booting [r]
fdisk -l
fdisk -l /dev/varD
fdisk -l ;; fdisk /dev/varD
# mount
vi2 /etc/fstab
mount
mount -a
mount /tmp -o remount,$( echo exec noexec | pipemenu ) 
chmod 1777 /tmp/
# chroot 
mount /dev/varROOTPARTITION /mnt/sysimage
mount /dev/varBOOTPARTITION /mnt/sysimage/boot
!!! chroot /mnt/sysimage
# lilo
vi2 /etc/lilo.conf
!!! lilo
# grub
ls -al /etc/default/ ;readx; explorer /etc/default/
ls -al /boot/ ;readx; explorer /boot/
vi2 $( ls -1 /etc/default/grub /etc/grub.conf /boot/grub/grub.cfg /etc/default/grub.d/proxmox-ve.cfg 2>/dev/null |pipemenu ) 
!!! grub
!!! update-grub
# grub2
grub2-mkconfig -o /boot/grub2/grub.cfg
# kernel 
grubby --default-kernel
# kernel add
grubby --add-kernel=/boot/vmlinuz-varVER --initrd=/boot/initramfs-varVER.img --title "varTITLE"
# kernel chg
grubby --set-default=/boot/vmlinuz-varVER
# kernel del
grubby --remove-kernel=/boot/vmlinuz-varVER
# os probe ( instlled win or etc ) 
os-prober || { yyay os-prober && os-prober ; }
efibootmgr || { yyay efibootmgr && efibootmgr ; }
update-grub
#
vi2 /root/.bashrc
explorer /boot/



%%% {submenu_sys}원격 네트워크 재시작 debian [rnet]
%%%e {submenu_sys}Remote Net restart debian [rnet]
# 원격지에서 네트워크 재시작 할경우, 네트웍 단절 방지
# debian
# /etc/network/interfaces.1.bak 백업본으로 복구 재시작
# /etc/network/interfaces.org 로 최종 재시작 
cp -a /etc/network/interfaces /etc/network/interfaces.org
# vi2 는 file.1.bak 백업후, 수정모드진입
vi2 /etc/network/interfaces
vi /etc/network/interfaces
vi /etc/network/interfaces.1.bak
vi /etc/network/interfaces.org
ping 8.8.8.8 -c 3
# interface 가 여러개 일개 각각 핑 체크 
ping -I vmbr0 varIP_8.8.8.8 -c 3
ping -I vmbr1 varIP_8.8.8.8 -c 3
ping -I vmbr2 varIP_8.8.8.8 -c 3
#
route 
ip -br a | awk '$3 != "" {print $1, $3}' | cip
# 재시작 || 실패시 백업파일로 복구후 재시작 
systemctl restart networking ; ping 8.8.8.8 -c 3 || (cp /etc/network/interfaces.1.bak /etc/network/interfaces && systemctl restart networking) ; ping 8.8.8.8 -c 3 || (cp /etc/network/interfaces.org /etc/network/interfaces && systemctl restart networking)
# proxmox or debina9 ifupdown2 
ifreload -a ; ping 8.8.8.8 -c 3 || (cp /etc/network/interfaces.1.bak /etc/network/interfaces && ifreload -a) ; ping 8.8.8.8 -c 3 || (cp /etc/network/interfaces.org /etc/network/interfaces && ifreload -a )
#
# cron add
echo "#*/5 * * * * root ping -c 1 -W 1 8.8.8.8 > /dev/null 2>&1 || { sleep 30; ping -c 1 -W 1 168.126.63.1 > /dev/null 2>&1 || { cp /etc/network/interfaces.org /etc/network/interfaces && systemctl restart networking.service ; }; }" | tee -a /etc/crontab
vi2 /etc/crontab
vi2 /etc/network/interfaces.org



%%% {submenu_sys}원격 네트워크 재시작 centos [rnetc]
%%%e {submenu_sys}Remote Net restart [rnetc]
# 원격지에서 네트워크 재시작 할경우, 네트웍 단절 방지
# centos
# /etc/sysconfig/network-scripts/ifcfg-eth0.1.bak 백업본으로 복구 재시작
# /etc/sysconfig/network-scripts/ifcfg-eth0.org 로 최종 재시작 
cp -a /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0.org
# vi2 는 file.1.bak 백업후, 수정모드진입
vi2 /etc/sysconfig/network-scripts/ifcfg-eth0
vi /etc/sysconfig/network-scripts/ifcfg-eth0
vi /etc/sysconfig/network-scripts/ifcfg-eth0.1.bak
vi /etc/sysconfig/network-scripts/ifcfg-eth0.org
ping 8.8.8.8 -c 3
# interface 가 여러개 일개 각각 핑 체크 
ping -I eth0 varIP_8.8.8.8 -c 3
ping -I eth1 varIP_8.8.8.8 -c 3
ping -I eth2 varIP_8.8.8.8 -c 3
#
route 
ip -br a | awk '$3 != "" {print $1, $3}' | cip
# 재시작 || 실패시 백업파일로 복구후 재시작 
!!! systemctl restart network ; ping 8.8.8.8 -c 3 || (cp /etc/sysconfig/network-scripts/ifcfg-eth0.1.bak /etc/sysconfig/network-scripts/ifcfg-eth0 && systemctl restart network) ; ping 8.8.8.8 -c 3 || (cp /etc/sysconfig/network-scripts/ifcfg-eth0.org /etc/sysconfig/network-scripts/ifcfg-eth0 && systemctl restart network)
#
# cron add
echo "#*/5 * * * * root ping -c 1 -W 1 8.8.8.8 > /dev/null 2>&1 || { sleep 30; ping -c 1 -W 1 168.126.63.1 > /dev/null 2>&1 || { cp /etc/sysconfig/network-scripts/ifcfg-eth0.org /etc/sysconfig/network-scripts/ifcfg-eth0 && systemctl restart network.service ; }; }" | tee -a /etc/crontab
vi2 /etc/crontab
vi2 /etc/sysconfig/network-scripts/ifcfg-eth0.org



%%% {submenu_sys}원격 네트워크 재시작 ubuntu [rnetu]
%%%e {submenu_sys}Remote Net restart [rnetu]
# 원격지에서 네트워크 재시작 할경우, 네트웍 단절 방지
# ubuntu
# /etc/netplan/01-netcfg.yaml.1.bak 백업본으로 복구 재시작
# /etc/netplan/01-netcfg.yaml.org 로 최종 재시작 
cp -a /etc/netplan/01-netcfg.yaml /etc/netplan/01-netcfg.yaml.org
# vi2 는 file.1.bak 백업후, 수정모드진입
vi2 /etc/netplan/01-netcfg.yaml
vi /etc/netplan/01-netcfg.yaml
vi /etc/netplan/01-netcfg.yaml.1.bak
vi /etc/netplan/01-netcfg.yaml.org
ping 8.8.8.8 -c 3
# interface 가 여러개 일개 각각 핑 체크 
ping -I vmbr0 varIP_8.8.8.8 -c 3
ping -I vmbr1 varIP_8.8.8.8 -c 3
ping -I vmbr2 varIP_8.8.8.8 -c 3
#
route 
ip -br a | awk '$3 != "" {print $1, $3}' | cip
# 재시작 || 실패시 백업파일로 복구후 재시작 
netplan apply ; ping 8.8.8.8 -c 3 || (cp /etc/netplan/01-netcfg.yaml.1.bak /etc/netplan/01-netcfg.yaml && netplan apply) ; ping 8.8.8.8 -c 3 || (cp /etc/netplan/01-netcfg.yaml.org /etc/netplan/01-netcfg.yaml && netplan apply)
#
# cron add
echo "#*/5 * * * * root ping -c 1 -W 1 8.8.8.8 > /dev/null 2>&1 || { sleep 30; ping -c 1 -W 1 168.126.63.1 > /dev/null 2>&1 || { cp /etc/netplan/01-netcfg.yaml.org /etc/netplan/01-netcfg.yaml && netplan apply ; }; }" | tee -a /etc/crontab
vi2 /etc/crontab
vi2 /etc/netplan/01-netcfg.yaml.org









%%% {submenu_com}file explorer - ranger [ex]
%%%e {submenu_com}file explorer - ranger [ex]
# file explorer install 
ranger || yyay ranger 
lfm || yyay lfm
mc || yyay mc
vifm || yyay vifm
nnn || yyay nnn
fzf || yyay fzf
yazi || snap install yazi --classic
# ranger (python stg install)
pip install ranger-fm
# centos6 git ranger make install (python2 base)
cd ~ ; git clone https://github.com/ranger/ranger.git ; cd ranger ; git checkout v1.8.1 ; make install
########################
# ranger configure
# ######################
mkdir -p $HOME/.config/ranger/ ; [ ! -f $HOME/.config/ranger/rc.conf ] && cp /etc/ranger/config/rc.conf $HOME/.config/ranger/
vi2 $HOME/.config/ranger/rc.conf
# hidden file view (ctrl+h or zh)
sed -i 's/#\?set show_hidden false/set show_hidden true/g' ~/.config/ranger/rc.conf
echo "set show_hidden true" >> $HOME/.config/ranger/rc.conf
# 
# editor vi set .bashrc
export EDITOR=vim ; echo "export EDITOR=vim" >> $HOME/.bashrc
# ranger 종료시점 작업 dir 저장후, 바로 이동
ranger --choosedir=$HOME/.rangerdir; cd $(cat ~/.rangerdir) ; rm -f ~/.rangerdir
ranger --choosedir=$(tmp=$(mktemp); echo $tmp); cd "$(cat $tmp)"; rm -f $tmp
## 
yyay varPKG__git__snapd


%%% {submenu_com}ranger hook (save dir to /dev/shm/pwd) [rangerhook]
%%%e {submenu_com}ranger hook (save dir to /dev/shm/pwd) [rangerhook]
%% echo "pwdpath: $pwdpath"
%% [ -f /dev/shm/pwd  ] && echo -n "cat /dev/shm/pwd: " && cat /dev/shm/pwd
# ranger hook
# 실시간 디렉토리 추적하여 /dev/shm/pwd 에 저장하는 hook 추가
mkdir -p ~/.config/ranger
ls -al ~/.config/ranger
ranger --copy-config=all
export pwdpath="varPWDpath__@@dev@@shm@@pwd" ; touch $pwdpath ; chmod 666 $pwdpath
ls -al $pwdpath
template_edit commands.py
template_view commands.py
template_copy commands.py ~/.config/ranger/commands.py ;; cat ~/.config/ranger/commands.py
# 이미 commands.py 를 이용중인경우 내용추가 
template_insert commands.py ~/.config/ranger/commands.py ;; cat ~/.config/ranger/commands.py
cat ~/.config/ranger/commands.py | cgrep /dev/shm/pwd
vi2 ~/.config/ranger/commands.py
rm -f ~/.config/ranger/commands.py
# ranger hook 설정 완료. 디렉토리 이동 시 /dev/shm/pwd 파일에 경로가 저장
cat /dev/shm/pwd
cat /tmp/ranger_commands.log
# 저장된 경로에서 시작
# e -> ranger $1 
# ee -> ranger /etc/ 
# eee -> ranger $(</dev/shm/pwd)
# cdr -> cd $(</dev/shm/pwd)
# cd path -> path > /dev/shm/pwd
ranger $(</dev/shm/pwd)
explorer ~/.config/ranger


%%% {submenu_sys}ethx ip setting centos6 [ipset]
%%%e {submenu_sys}ethx ip setting centos6 [ipset]
# ifcfg-ethx 파일이 없거나, IP (static/dhcp) 갱신이 필요할때 
# centos 기준 작성 
vi2 $( ls -1 /etc/sysconfig/network-scripts/ifcfg-* /etc/sysconfig/network 2>/dev/null |pipemenu ) 
declare -f ifcfgset
ifcfgset
#
explorer /etc/sysconfig/network-scripts/
#
!!! systemctl restart networking
!!! systemctl restart network
!!! service network restart
!!! /etc/init.d/network restart
ip a ; echo ; route
ping 168.126.63.1
# recover
diff /etc/sysconfig/network-scripts/ifcfg-eth0.bak /etc/sysconfig/network-scripts/ifcfg-eth0
cp -a /etc/sysconfig/network-scripts/ifcfg-eth0.bak /etc/sysconfig/network-scripts/ifcfg-eth0


%%% {submenu_sys}ethx bonding setting [bond]
%%%e {submenu_sys}ethx bonding setting [bond]
# ubuntu/debian 기준
yyay ifenslave ethtool
modprobe bonding
echo 'bonding' >> /etc/modules 
vi2 /etc/modules
vi2 /etc/network/interfaces
cp -a /etc/network/interfaces /etc/network/interfaces.$(datetag2).bak ; ls -al /etc/network
export ifaces=$(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | grep -E "^e") ; echo "$ifaces"
export ifaces=$(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | grep -E "^e|^w") ; echo "$ifaces"
{ ip a ;echo;echo localip:$localip pubip:$publicip gateway:$gateway; }|cip ;; export bondip="varIPADDR" ; export bondgateway="varGATEWAY"
# 아래 갈무리후 수정
# 서버 단독 ip 사용시
echo -e "auto lo\niface lo inet loopback\n"; echo "$ifaces" | while IFS= read -r line; do echo -e "auto $line\niface $line inet manual\n  bond-master bond0\n" ; done ; echo -e "auto bond0\niface bond0 inet static\n  address $bondip/24\n  netmask 255.255.255.0\n  gateway $bondgateway\n  bond-slaves $(echo $ifaces)\n  bond-mode balance-rr\n  bond-miimon 100\n  bond-downdelay 200\n  bond-updelay 200"
# 브리지 사용시 
echo -e "auto lo\niface lo inet loopback\n"; echo "$ifaces" | while IFS= read -r line; do echo -e "iface $line inet manual\n  bond-master bond0\n" ; done ; echo -e "auto bond0\niface bond0 inet manual\n  bond-slaves $(echo $ifaces)\n  bond-mode balance-rr\n\nauto vmbr0\niface vmbr0 inet static\n\taddress $bondip/24\n\tnetmask 255.255.255.0\n\tgateway $bondgateway\n\tbridge_ports bond0"
!!! systemctl restart networking
ip a | cip
lsmod | grep bond
# bond0 체크하여 eth0 eth1 합산 대역폭이 나오는지 확인 
for i in $(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'| grep -E "^e|^w" ) ; do ethtool $i |grep -E 'detect|nego|Setting|Duplex|Speed' ; done| cgrep Speed
# ethX speed chg // 랜이 죽을수 있으니 백업라인 확보/콘솔에서 작업 
!!! eth=$(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu) ;; ethtool -s $eth speed $(echo 10 100 1000|pipemenu) duplex full autoneg off ; [ $(pingcheck) == "n" ] && ethtool -s $eth autoneg on && echo "$eth autoneg on" | push
!!! eth=$(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu) ;; ethtool -s $eth autoneg on ; ethtool $eth |cgrep speed 
# old speed chg
mii-tool $(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu)
!!! mii-tool -F $( echo 10 100 1000 |pipemenu)baseTx-FD  $(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu)
# 속도측정
yyay iperf
# 서버 side
ip a |grep bond;echo; ip a|gipa ;; iperf -s
# 클라이언트 side
iperf -c varServerIP





%%% {submenu_sys}ethx wireless setting [wifi]
%%%e {submenu_sys}ethx wireless setting [wifi]
# module up?
lsmod | grep -E '80211|wl|wifi|wlan'
lshw -c network | cgrepline1 description | cgrepline vendor
# install
yyay wpasupplicant wireless-tools
# on / off
ip link set wlp1s0 up
nmcli radio wifi on
ip link set wlp1s0 down
nmcli radio wifi off
# check ESSID
iwconfig 2>/dev/null | grep ESSID
iwlist $( iwconfig 2>/dev/null | grep ESSID | awk1 ) scan | cgrepline1 ESSID
# ssid psk set
echo -e 'network={\n     ssid="varSSID"\n     psk="varPassword"\n}' >> /etc/wpa_supplicant/wpa_supplicant.conf
vi2 /etc/wpa_supplicant/wpa_supplicant.conf
# connect 
wpa_supplicant -i $(iwconfig 2>/dev/null | grep ESSID | awk '{print $1}') -c /etc/wpa_supplicant/wpa_supplicant.conf -B 
# check
iwconfig 2>/dev/null
ifconfig | cip
ip a | cip
# 아래 내역 갈무리 후 수정
echo -e "auto $(iwconfig 2>/dev/null | grep ESSID | awk '{print $1}')\niface $(iwconfig 2>/dev/null | grep ESSID | awk '{print $1}') inet dhcp" 
vi2 /etc/network/interfaces
!!! systemctl restart networking
# 아이피 받아오기
dhclient $(iwconfig 2>/dev/null | grep ESSID | awk '{print $1}') ; ip a| cip



%%% {submenu_sys}ethx nmcli network-manager [nmcli]
%%%e {submenu_sys}ethx nmcli network-manager [nmcli]
# 기존 네트워크 관리자와 별도 작동 주의 
nmcli || { systemctl enable --now NetworkManager ; nmcli ; }
nmcli general $(echo status hostname permissions logging | pipemenu ) 
nmcli device status
nmcli device show
nmcli -g NAME con show ; echo ; nmcli con show ; echo ; nmcli con show --active
# ipset add / modify / up / down
nmcli con add con-name varConName ifname $(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu) type ethernet ipv4.method manual ipv4.address "varIP/24" ipv4.gateway "varGateWay" 
nmcli con mod "$(nmcli -g NAME con show|pipemenulist)" ipv4.address "varIP/24" ipv4.gateway "varGateWay"
nmcli con up $(nmcli -g NAME con show|pipemenulist)
nmcli con down $(nmcli -g NAME con show|pipemenulist)
# bridge net add
nmcli con add type bridge autoconnect yes con-name varConName__br0 ifname varConName__br0
nmcli con add type bridge-slave autoconnect yes con-name "$(nmcli -g NAME con show|pipemenulist)" ifname "$(nmcli -g NAME con show|pipemenulist)" master varConName
nmcli con mod varConName ipv4.method auto
nmcli con down varConName ; nmcli con up varConName
nmcli con show
# ifcfg mod -> reload
nmcli con reload
# dhcp
nmcli device modify "$(nmcli -g NAME con show|pipemenulist)" ipv4.method auto
# nmcli - wifi connect on / off / status
nmcli radio wifi varOPT__on__off ;;  nmcli radio wifi
nmcli radio wifi
nmcli device wifi list
export ssid=$( nmcli -f SSID device wifi list |awknr2|head -n5 |pipemenu) ;; nmcli device wifi connect $ssid password varPassword
#
explorer /etc/NetworkManager/
# install
nmcli || { yyay network-manager || yyay NetworkManager ; nmcli ; }
nmtui || { yyay network-manager net-tools NetworkManager-tui wget curl ; nmtui ; }
# resolv.conf 수정 못하게 설정후 재시작
FILE=/etc/NetworkManager/NetworkManager.conf ;grep -q "^dns=" $FILE && sed -i 's/^dns=.*/dns=none/' $FILE || sed -i '/\[main\]/a dns=none' $FILE
# 
systemctl status NetworkManager
systemctl restart NetworkManager
systemctl enable --now NetworkManager
systemctl disable --now NetworkManager
lshw -class network || { yyay lshw ; lshw -class network ; }








%%% {submenu_com}rdiff-backup 롤백지원 백업 [rdiff]
%%%e {submenu_com}rdiff-backup Rollback Support Backup [rdiff]
# backup
rdiff-backup /root /backup/root_rdiff_backup
rdiff-backup /script /backup/script_rdiff_backup
rdiff-backup varLpath varBackupPath
# chg check
rdiff-backup --list-increments /backup/root_rdiff_backup
rdiff-backup --list-increments /backup/root_rdiff_backup|grep "increments."| awk -F. '{print $2}'
rdiff-backup --list-increments varBackupPath
explorer /backup/root_rdiff_backup/rdiff-backup-data/
# restore now(최신) 3D(3일전) 1W(1주전) 2M(2달전)
rdiff-backup --restore-as-of "varAGO" --force /backup/root_rdiff_backup /root
rdiff-backup --restore-as-of "$(rdiff-backup --list-increments /backup/root_rdiff_backup|grep "increments."| awk -F. '{print $2}'|pipemenu)" --force /backup/root_rdiff_backup /root
rdiff-backup --restore-as-of "$(rdiff-backup --list-increments varBackupPath|grep "increments."| awk -F. '{print $2}'|pipemenu)" --force varBackupPath varLpath
# delete 1M (한달지난 백업본 삭제)
rdiff-backup --remove-older-than 1M varBackupPath
# 로컬 디렉터리를 원격 서버에 백업
rdiff-backup varLpath varID__root@varRhost::varBackupPath
# 원격 서버의 디렉터리를 로컬에 복구
rdiff-backup --restore-as-of varAGO__now varID__root@varRhost::varBackupPath varLpath
# cron add example (2am)
echo "#0 2 * * * root rdiff-backup /root /backup/root_rdiff_backup" >> /etc/crontab
#
# install
yyay rdiff-backup





%%% {submenu_lamp}>LAMP 설치/설정 가이드 (Debian/Ubuntu) [flow_lamp_deb]
%%%e {submenu_lamp}>LAMP Setup Guide (Debian/Ubuntu) [flow_lamp_deb]
%% echo "Debian/Ubuntu 기준 LAMP 스택 설치 및 설정 가이드입니다."
%% echo "각 단계를 완료하고 엔터 또는 'b'를 눌러 다음 단계로 이동하세요."
#----------------------------------------------------------------------
: 1단계: Apache 웹서버 & PHP 기본 설치 ; a1
:   (선택) mod_php 방식 설정/확인 ; a2
#----------------------------------------------------------------------
: 2단계: MariaDB (MySQL) 데이터베이스 설치 ; a2
:   (선택) phpMyAdmin 설치 ; db
:   (참고) MySQL 명령어 직접 실행 ; mysql
#----------------------------------------------------------------------
: 3단계: PHP-FPM 설정 (권장) ; a3
:   (고급) 사용자별 FPM Pool 설정 ; a4
#----------------------------------------------------------------------
: 4단계: 가상 호스트 및 웹사이트 설정 ; web
:   (참고) Apache 가상호스트 수동 설정 ; a1
:   (선택) WordPress 설치 ; word
#----------------------------------------------------------------------
: 5단계: DNS 설정 (필요시) ; b1
:   (참고) 네임서버 리버스 존 설정 ; b2
:   (참고) 호스팅 도메인 Zone 설정 ; b3
:   (테스트) DNS 쿼리 확인 ; dig
#----------------------------------------------------------------------
: 6단계: 메일 서버 설정 (선택) ; m1
:   (참고) Postfix (SMTP) 설정 ; m1
:   (참고) Dovecot (IMAP/POP3) 설정 ; m2
:   (참고) Roundcube 웹메일 설치 ; m3
:   (참고) 가상호스트/webmail 접근 설정 ; m4
:   (참고) SquirrelMail 웹메일 (대안) ; sq
#----------------------------------------------------------------------
: 7단계: 보안 및 추가 설정 ; cert
:   (참고) SSL 인증서 확인/적용 ; ssl
:   (참고) vsftpd & 방화벽(UFW) 설정 ; f1
:   (참고) Fail2ban (자동 IP 차단) 설정 ; ban
:   (참고) Apache 트래픽 제한 모듈 ; cband




%%% {submenu_lamp}>LAMP 심화 설정 & 진단 흐름 [flow_lamp_adv]
%%%e {submenu_lamp}>Advanced LAMP Setup & Diagnostics [flow_lamp_adv]
%% echo "LAMP 설치 후 관리/진단 전용 메뉴임. 문제 생기면 여기서 조지면 됨."
%% echo "Apache, PHP, MariaDB 설정 확인, 로그 까보기, 최적화 등등 다 있음."
%% echo "설치는 [flow_lamp_deb] 고고."
# ====[ 종합 진단 & 상태 확인 ]====
: (서비스 상태) 주요 데몬(Apache, PHP, DB) 상태 일괄 확인 ; all_stat
: (핵심 로그) 주요 데몬 로그(Error 위주) 통합 조회 ; log_all
: (기본 접속) 로컬 웹서버(80포트) 응답 확인 ; web_ping
: (보안 상태) SSL 인증서, Fail2ban 상태 요약 ; sec_check
# ====[ Apache (웹서버) 관리 ]====
: (Apache 상세) 상태, 설정, 로그, 모듈 상세 점검 ; apache
: (사이트 Conf) 가상호스트 설정(.conf) 탐색 및 편집 ; siteconf
# ====[ PHP (엔진) 관리 ]====
: (PHP-FPM 상세) 상태, 소켓, Pool, 설정 상세 점검 ; phpfpm
: (PHP 정보) phpinfo() 테스트 페이지 생성, 확인, 삭제 ; test_phpinfo
: (소켓 경로) Site Conf 내 PHP-FPM 소켓 검색 ; grep_siteconf
# ====[ MariaDB/MySQL (DB) 관리 ]====
: (DB 상세) 유저, 권한 확인 및 DB 직접 접속 ; sql_user
: (DB 관리툴) phpMyAdmin 접속 및 설정 확인 ; phpmyadmin
# ====[ 권한 및 기타 점검 ]====
: (권한 점검) 웹루트 퍼미션 확인 (업로드, 쓰기 문제) ; perm_webroot
# ====[ 시스템 레벨 도구 연계 ]====
: (시스템 모니터링) 실시간 부하, 프로세스, 네트워크 ; p
: (디스크/파일시스템) 용량, 마운트, 파티션 확인 ; f
: (네트워크 방화벽) UFW, FirewallD 규칙 확인, 관리 ; ufw
# ====[ 이전 메뉴 이동 ]====
: (돌아가기) LAMP 설치 플로우 메뉴로 ; flow_lamp_deb






%%% {submenu_lamp_ext}로컬 웹서버(80포트) 응답 확인 [web_ping]
%%%e {submenu_lamp_ext}Local Web Server (Port 80) Response Check [web_ping]
%% echo "Apache나 Nginx가 80포트로 응답하는지 간단하게 확인."
%% echo "사이트 접속 안 될 때 가장 먼저 체크해볼 만함."
# === curl 로 헤더 확인 ===
curl -I http://localhost | head -n 1
curl -I http://127.0.0.1 | head -n 1
# === lynx 로 내용 확인 ===
lynx http://localhost
lynx http://127.0.0.1
# === 포트 리슨 확인 ===
ss -tlpn | grep ':80 ' | cpipe
lsof -i :80 | cpipe
# === 관련 서비스 상태 ===
systemctl status apache2 | head -n 5
systemctl status nginx | head -n 5




%%% {submenu_lamp_ext}Apache 관련 통합 관리 [apache]
%%%e {submenu_lamp_ext}Apache Service Deep Management [apache]
%% echo "아파치 상태 점검, 설정 확인, 로그 추적 등등 싹 다 여기서 함."
%% echo "가상호스트, 모듈 활성화 상태도 보고, PHP-FPM 연동 문제도 여기서 실마리 찾기 ㄱㄱ"
# === 서비스 상태 및 제어 ===
systemctl status apache2 | cgrepline "(running|dead|failed)" | less -RX
systemctl try-reload-or-restart apache2 ;; echo "Reload or Restart 시도 완료"
apachectl configtest ; echo $? | { grep -q 0 && echo "$(GRN1)Syntax OK$(RST)" || echo "$(RED1)Syntax Error!$(RST)"; }
apachectl -V | grep -Ei 'version|mpm|httpd'
# === 설정 및 구성 확인 ===
apachectl -S | cgrep "default server" | cgrepn namevhost 1 | cpipe # 가상호스트 로딩 상태 핵심!
ls -l /etc/apache2/sites-enabled/
ls -l /etc/apache2/mods-enabled/ | head
vi2 /etc/apache2/apache2.conf ;; apachectl configtest
explorer /etc/apache2/sites-available/
# === apache 00-default 조정 ===
cd /etc/apache2
# :80 default selected mv 000- set
f=$( basename -a sites-available/*.conf | grep -v le-ssl | pipemenu ) ; mv sites-available/$f sites-available/000-${f}
# :443 default selected mv  000- set
f=$( basename -a sites-available/*.conf | grep le-ssl | pipemenu ) ; mv sites-available/$f sites-available/000-${f}
a2dissite $f ; unlink sites-enabled/$f 
a2ensite $( basename -a sites-available/*.conf | grep le-ssl | pipemenu )
systemctl reload apache2
apachectl -S |  cgrep "default server" | cgrepn namevhost 1 | cpipe
# === 로그 확인 ===
tail -n 50 /var/log/apache2/error.log | cgrepl error warn critical emerg alert | cgrep1 notice info debug | less -RX
tail -f /var/log/apache2/error.log | cgrepl error warn critical emerg alert | cgrep1 notice info debug
tail -n 50 /var/log/apache2/access.log | cpipe | less -RX
tail -f /var/log/apache2/access.log | cpipe
journalctl -u apache2 -n 100 --no-pager | cpipe | less -RX
# === 프로세스 및 연결 ===
ps aux | grep apache2 | grep -v grep | cpipe
lsof -i :80 | cpipe
lsof -i :443 | cpipe
# === 모듈/사이트 활성화/비활성화 ===
a2query -s ;; varSetSite__a2ensite__a2dissite $( a2query -s | awk1 | pipemenu ) ;; apachectl configtest && systemctl try-reload-or-restart apache2
a2query -m ;; varSetMode__a2enmod__a2dismod $( a2query -m | awk1 | pipemenu ) ;; apachectl configtest && systemctl try-reload-or-restart apache2





%%% {submenu_lamp_ext}사이트 conf 설정 / 탐색 [siteconf]
%%%e {submenu_lamp_ext}Apache VirtualHost Config Explore [siteconf]
%% echo "가상호스트(사이트별) 설정 파일(.conf) 쉽게 찾고 편집하는 곳."
%% echo "도메인, 웹루트, PHP 소켓 연동 같은 거 여기서 확인/수정 ㄱㄱ"
# === conf 파일 목록 및 탐색 ===
ls -l /etc/apache2/sites-available/*.conf
ls -l /etc/apache2/sites-enabled/*.conf
explorer /etc/apache2/sites-available/
# === 특정 사이트 conf 열기 ===
vi2 $(ls -1 /etc/apache2/sites-available/*.conf | pipemenu1cancel)
# === 설정 내용 빠르게 grep ===
grep -Hn 'DocumentRoot' /etc/apache2/sites-available/*.conf 2>/dev/null | cgrepn DocumentRoot 1
grep -Hn 'ServerName' /etc/apache2/sites-available/*.conf 2>/dev/null | cgrepn ServerName 1
grep -Hn 'ServerAlias' /etc/apache2/sites-available/*.conf 2>/dev/null 
grep -Hn 'php.*sock' /etc/apache2/sites-available/*.conf 2>/dev/null | cpipe # PHP-FPM 소켓 경로 확인
grep -Hn 'SSLCertificateFile' /etc/apache2/sites-available/*.conf 2>/dev/null | cpipe # SSL 인증서 경로 확인
# === 설정 테스트 및 적용 ===
apachectl configtest
apachectl -S | cpipe
systemctl try-reload-or-restart apache2



%%% {submenu_lamp_ext}phpinfo 테스트 페이지 생성/확인 [test_phpinfo]
%%%e {submenu_lamp_ext}phpinfo Test Page Setup & Access [test_phpinfo]
%% echo "PHP 설정값 한눈에 보는 phpinfo() 페이지 만들고 확인하는 곳. 보안상 쓰고 바로 지우셈!"
%% echo "웹루트: $(grep -m1 DocumentRoot /etc/apache2/sites-enabled/* | head -n1 | awk '{print $2}')"
export WEBROOT=$(grep -m1 DocumentRoot /etc/apache2/sites-enabled/* | head -n1 | awk '{print $2}' | sed 's/"//g') ; echo "Detected Webroot: $WEBROOT"
# === info.php 생성 ===
echo '<?php phpinfo(); ?>' > ${WEBROOT:-/var/www/html}/info.php && chmod 644 ${WEBROOT:-/var/www/html}/info.php && echo "info.php 생성 완료." || echo "$(RED1)생성 실패! 웹루트 확인 필요.$(RST)"
ls -l ${WEBROOT:-/var/www/html}/info.php
# === 브라우저 확인용 주소 ===
echo "http://$(hostname -f)/info.php"
# === 로컬 curl/lynx 테스트 ===
curl -s http://localhost/info.php | head -n 20
lynx http://localhost/info.php
# === 생성 여부 확인 ===
[ -f "${WEBROOT:-/var/www/html}/info.php" ] && echo "$(GRN1)info.php 존재함.$(RST)" || echo "$(RED1)info.php 없음.$(RST)"
# === 삭제 (중요!) ===
rm -i ${WEBROOT:-/var/www/html}/info.php && echo "info.php 삭제 완료."

%%% {submenu_lamp_ext}PHP-FPM 소켓 및 설정 점검 [phpfpm]
%%%e {submenu_lamp_ext}PHP-FPM Socket & Pool Configuration [phpfpm]
%% echo "PHP-FPM 잘 도는지, 소켓 연결은 됐는지, pool 설정은 뭔지 확인 ㄱㄱ"
%% echo "사이트별 FPM 쓸 때 소켓 경로 매칭되는지 여기서 보면 편함."
# === 서비스 상태 및 제어 ===
systemctl status $( systemctl list-unit-files --type=service | grep php.*-fpm ) | cgrep1 running dead failed | less -RX
systemctl try-reload-or-restart php*-fpm ;; echo "Reload or Restart 시도 완료"
# === 소켓 확인 ===
ls -al /run/php/php*-fpm*.sock # 소켓 파일 권한 및 존재 여부
ss -lx | grep php # 리슨 중인 소켓 확인
# === php-fpm 프로세스 ===
ps aux | grep php-fpm | grep -v grep | cpipe # 마스터/워커 프로세스 확인
pgrep -af php-fpm # 간단히 PID 확인
# === 설정파일 열람 (주요 설정 위주) ===
vi2 /etc/php/*/fpm/php-fpm.conf ;; echo "Global FPM Conf"
vi2 /etc/php/*/fpm/pool.d/www.conf ;; echo "Default Pool Conf (www)"
grep -H 'listen =\|user =\|group =\|pm =\|pm\.max_children' /etc/php/*/fpm/pool.d/*.conf | cpipe # Pool 설정 핵심 요약
# === php.ini 확인 (FPM용) ===
php --ini | grep "Loaded Configuration File" # 현재 사용 중인 php.ini 경로
vi2 $(php --ini | grep "Loaded Configuration File" | awk '{print $NF}') # FPM용 php.ini 열기
php -i | grep -E 'memory_limit|upload_max_filesize|post_max_size|max_execution_time|error_reporting|display_errors' # 주요 설정값 확인
# === PHP 모듈 확인 ===
php -m | less -r

%%% {submenu_lamp_ext}MariaDB 유저 및 권한 확인 [sql_user]
%%%e {submenu_lamp_ext}MariaDB User & Privilege Check [sql_user]
%% echo "MariaDB(MySQL) 유저 계정, 권한, DB 목록 같은 거 SQL 몰라도 여기서 쉽게 봄."
# === 서버 접속 및 상태 확인 ===
mysqladmin ping && echo "$(GRN1)DB 서버 응답 OK$(RST)" || echo "$(RED1)DB 서버 응답 없음!$(RST)"
systemctl status mariadb | cgrepline "(running|dead|failed)" | less -RX
# === 사용자 목록 및 호스트 ===
echo 'SELECT User, Host FROM mysql.user;' | mysql -uroot -pvarDBRootPW
# === 특정 사용자 권한 확인 ===
echo 'SHOW GRANTS FOR '\''varUser'\''@'\''varHost__localhost'\'';' | mysql -uroot -pvarDBRootPW
# === 모든 사용자 권한 보기 (간략) ===
echo 'SELECT User, Host, Select_priv, Insert_priv, Update_priv, Delete_priv, Grant_priv FROM mysql.user;' | mysql -uroot -pvarDBRootPW | less -S
# === 데이터베이스 목록 ===
echo 'SHOW DATABASES;' | mysql -uroot -pvarDBRootPW
# === 프로세스 목록 (현재 연결/쿼리) ===
echo 'SHOW PROCESSLIST;' | mysql -uroot -pvarDBRootPW
mysqladmin processlist -uroot -pvarDBRootPW
# === 에러 로그 확인 ===
tail -n 50 /var/log/mysql/error.log | cgrepl ERROR WARN | less -RX
tail -f /var/log/mysql/error.log | cgrepl ERROR WARN
# === mysql 콘솔 직접 접속 ===
mysql -uroot -pvarDBRootPW



%%% {submenu_lamp_ext}phpMyAdmin 접속 및 설정 테스트 [phpmyadmin]
%%%e {submenu_lamp_ext}phpMyAdmin Access & Config Test [phpmyadmin]
%% echo "phpMyAdmin 설치됐는지, 웹 접속은 되는지, 설정 파일은 어딨는지 확인."
# === 설치 확인 및 경로 추적 ===
dpkg -l | grep phpmyadmin # Debian/Ubuntu
# find /usr/share/ /var/lib/ -type d -name phpmyadmin 2>/dev/null | head # 느릴 수 있음
which phpmyadmin # 경로에 있다면 (드뭄)
# === Apache 설정 확인 (Alias/VirtualHost) ===
grep -Ri 'phpmyadmin' /etc/apache2/sites-enabled/ /etc/apache2/conf-enabled/ | cgrep1 Alias | cpipe
# === 접속 URL 출력 (가장 일반적인 경우) ===
echo "http://$(hostname -f)/phpmyadmin"
echo "http://localhost/phpmyadmin"
# === 로컬 접속 테스트 ===
curl -I http://localhost/phpmyadmin | head -n 1 # HTTP 상태 코드 확인
lynx http://localhost/phpmyadmin
# === 설정 파일 확인 및 편집 ===
vi2 /etc/phpmyadmin/config.inc.php
vi2 /etc/phpmyadmin/apache.conf
# === 인증 방식 확인 ===
grep 'auth_type' /etc/phpmyadmin/config.inc.php | cpipe



%%% {submenu_lamp_ext}Apache/PHP/MariaDB 서비스 상태 통합 확인 [all_stat]
%%%e {submenu_lamp_ext}Systemctl Status: Apache / PHP-FPM / MariaDB [all_stat]
%% echo "아파치, PHP-FPM, 마리아DB 상태 한방에 체크! 문제 있으면 빨간색으로 보임."
for i in apache2 mariadb mysql $(systemctl list-unit-files --type=service|egrep "fpm" |awk1) ; do systemctl is-active --quiet $i && echo "$(GRN1)$i: Active (Running)$(RST)" || echo "$(RED1)$i: Inactive or Failed$(RST)"; systemctl status $i | head -n 5 ; dline; done


%%% {submenu_lamp_ext}Apache/PHP/MariaDB 통합 로그 보기 [log_all]
%%%e {submenu_lamp_ext}Journalctl: Apache / PHP-FPM / MariaDB logs [log_all]
%% echo "아파치, PHP-FPM, 마리아DB 최근 로그(journalctl) 싹 긁어옴. 에러 찾기 좋음."
%% echo "grep -iE로 에러/경고 라인만 필터링해서 보여줌! (한줄코드 수정)"
for i in apache2 mariadb mysql $(systemctl list-unit-files --type=service|egrep "fpm" |awk1) ; do echo; dline; echo -e "$(MAG1)===== [$i 로그 시작] =====$(RST)"; dline; journalctl -u "$i" -n 50 --no-pager | grep -iE 'error|fail|warn|critical|unable' | cpipe; echo -e "\\n$(MAG1)====== [$i 로그 끝] ======$(RST)"; readx; done




%%% {submenu_lamp_ext}SSL 인증서 / Fail2ban 상태 점검 [sec_check]
%%%e {submenu_lamp_ext}Security Check: SSL Cert & Fail2ban Status [sec_check]
%% echo "SSL 인증서 유효기간이랑 Fail2ban 감옥 상태 체크."
# === SSL 인증서 (LetsEncrypt 기준) ===
certbot certificates | cgrepn Domains Validity 10  # 유효기간 확인
ls -l /etc/letsencrypt/live/*/fullchain.pem # 실제 파일 경로
certbot renew --dry-run # 갱신 테스트 (실제 갱신 아님)
# === Fail2ban ===
systemctl status fail2ban | cgrepline "(running|dead|failed)"
fail2ban-client status | cgrep1 "Jail list"
fail2ban-client status sshd | cip # sshd 감옥 상세 상태
fail2ban-client status apache-auth | cip # 아파치 인증 감옥 (설정 시)
tail -n 50 /var/log/fail2ban.log | cgrep1 Ban Unban | less -RX
iptables -L INPUT -v -n | grep f2b | cip # 실제 차단 규칙 확인
# === ipban direct ===
ipban varIPs
ipban24 varIPs
ipban16 varIPs
ipbanlist 
# all 32/24/16 allow
ipallow varIPs


%%% {submenu_lamp_ext}웹루트 퍼미션 점검 [perm_webroot]
%%%e {submenu_lamp_ext}Webroot Permission Check [perm_webroot]
%% echo "웹서버(www-data)가 웹루트 디렉토리랑 파일에 접근 권한 있는지 확인."
%% echo "파일 업로드 안되거나 'Permission denied' 에러 뜰 때 이거부터 보셈."
export WEBROOT=$(grep -m1 DocumentRoot /etc/apache2/sites-enabled/* | head -n1 | awk '{print $NF}' | sed 's/"//g') ; echo "Detected Webroot: $WEBROOT"
# === 기본 웹루트 권한 ===
ls -ld ${WEBROOT:-/var/www/html}
# === 웹루트 내 샘플 파일/디렉토리 권한 ===
ls -al ${WEBROOT:-/var/www/html} | head -n 15
# === 소유권/그룹 확인 ===
stat ${WEBROOT:-/var/www/html} | grep -E 'Uid|Gid' | cpipe
# === www-data 사용자로 접근 시뮬레이션 (읽기) ===
sudo -u www-data ls -al ${WEBROOT:-/var/www/html} | head -n 15
# === www-data 사용자로 접근 시뮬레이션 (쓰기 - 테스트 파일 생성/삭제) ===
sudo -u www-data touch ${WEBROOT:-/var/www/html}/.test_perm_$(date +%s) && echo "$(GRN1)쓰기 테스트 OK$(RST)" && sudo -u www-data rm ${WEBROOT:-/var/www/html}/.test_perm_* || echo "$(RED1)쓰기 테스트 실패!$(RST)"
# === 계정 홈디렉토리 방식일 경우 ===
ls -ld /home/*/public_html
ls -al /home/varID/public_html | head




%%% {submenu_lamp_ext}siteconf 내 php-fpm 소켓 grep [grep_siteconf]
%%%e {submenu_lamp_ext}Grep PHP-FPM Sockets in Site Configs [grep_siteconf]
%% echo "아파치 가상호스트 설정(.conf) 파일들 싹 뒤져서 PHP-FPM 소켓 경로 찾아줌."
%% echo "사이트별로 다른 소켓 쓰거나 할 때 확인용."
grep -Hrn 'SetHandler.*php.*sock' /etc/apache2/sites-available/*.conf /etc/apache2/sites-enabled/*.conf 2>/dev/null | cpipe | cgrep1 .sock








%%% {submenu_lamp}debian lamp set flow - apache [a1]
%%%e {submenu_lamp}debian lamp set flow - apache [a1]
%% echo "http://$(hostname -f) // yourdomain:$yourdomain // webroot:$webroot"
: php8.3 repo add; apt install -y apt-transport-https ca-certificates lsb-release gnupg ; wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg ; echo "deb https://packages.sury.org/php/ $(lsb_release -sc) main" | tee /etc/apt/sources.list.d/php.list 
apt update ; apt upgrade
apt search varPKG__php8@dot@3 | cgrep varPKG | less -RX
apt show varPKG__php8@dot@3
# apache2 php8 ( nextpage bind9 postfix dovecot vsftpd )
apt install apache2 php8.3 php8.3-cli php8.3-fpm php8.3-common php8.3-mysql php8.3-gd php8.3-mbstring php8.3-xml php8.3-zip php8.3-curl php8.3-opcache php8.3-readline php8.3-bcmath php8.3-xmlreader php8.3-xmlwriter php8.3-redis php8.3-memcached php8.3-imagick
php -v ; readx  ;; php -m | less -r
# apache2
lsof -i:80 
dpkg -L varPKG__apache2 | cgrep1 sbin etc | less -RX
explorer /etc/apache2
export yourdomain="varDom" webroot="varWWWroot"
template_edit example.com.conf # go.sh 의 template 부분 수정 필요한 경우 
template_view example.com.conf
!!! template_copy example.com.conf /etc/apache2/sites-available/varDom.conf ;; cat "$lastarg"
vi2 /etc/apache2/sites-available/varDom.conf
mkdir -p $webroot ; chgrp www-data $webroot ; chmod 750 $webroot ;; ls -al $webroot | cgrep www-data
ps aux | grep apache # apache user 확인
tail -f $(ls /var/log/apache2/*.log | pipemenu )
# 아직 추가 되지 않은 site 환경파일 
comm -23 <(ls /etc/apache2/sites-available/*.conf | xargs -n1 basename | sed 's/\.conf//' | sort) <(ls /etc/apache2/sites-enabled | xargs -n1 basename | sed 's/\.conf//' | sort)
: a2ensite; a2ensite $( ls /etc/apache2/sites-available/*.conf | xargs -n1 basename | pipemenu ) 
: a2enmod;  a2enmod  $( ls /etc/apache2/mods-available/*conf | xargs -n1 basename | pipemenu ) 
: a2enconf; a2enconf $( ls /etc/apache2/conf-available/*conf | xargs -n1 basename | pipemenu )
systemctl reload apache2 ;; systemctl status apache2
echo "<h1>Success! Your virtual host is working!</h1>" | tee $webroot/index.html
explorer varWWWroot
cd varWWWroot ;; menufunc eee
explorer "/etc/apache2/$( echo sites-available mods-available conf-available | pipemenu)"
# en / dis 
a2query -s ;; varSetSite__a2ensite__a2dissite $( a2query -s | awk1 | pipemenu )
a2query -m ;; varSetMode__a2enmod__a2dismod $( a2query -m | awk1 | pipemenu )
a2query -c ;; varSetConf__a2enconf__a2disconf $( a2query -c | awk1 | pipemenu ) 
apachectl $( echo "start|stop|restart|graceful|graceful-stop|configtest|status|fullstatus|help" | pipemenu )



#trash
sed -i 's/\$yourdomain/varDom/g' /etc/apache2/sites-available/varDom.conf ;; cat "$lastarg" | cgrep1 ${yourdomain}




%%% {submenu_lamp}debian lamp set flow - mysql,modphp [a2]
%%%e {submenu_lamp}debian lamp set flow - mysql,modphp [a2]
%% echo "mysqlrootpw:$mysqlrootpw"
# mysql (mariadb)
apt install mariadb-server mariadb-client
mysql_secure_installation
echo "mysqlrootpw=varDBRootPW" >> ~/go.private.txt ; source ~/go.private.txt
mysql -u root -p"$mysqlrootpw"
mysql -u root -p"$mysqlrootpw" -e "SHOW DATABASES;"
# user db create
mysql -u root -p"$mysqlrootpw" -e "CREATE DATABASE varDBUser;"
mysql -u root -p"$mysqlrootpw" -e "CREATE USER 'varDBUser'@'localhost' IDENTIFIED BY 'varDBUserPW';"
mysql -u root -p"$mysqlrootpw" -e "GRANT ALL PRIVILEGES ON \`varDBUser\`.* TO 'varDBUser'@'localhost';"
mysql -u root -p"$mysqlrootpw" -e "FLUSH PRIVILEGES;"
# create/show tables;
mysql -u varDBUser -p'varDBUserPW' varDBUser -e "CREATE TABLE items (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100) NOT NULL, description TEXT, price DECIMAL(10, 2) DEFAULT 0.00, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP); show tables;"
mysql -u varDBUser -p'varDBUserPW' varDBUser -e 'show tables;'
# user db passwd update
mysql -u root -p"$mysqlrootpw" -e "ALTER USER 'varDBUser'@'localhost' IDENTIFIED BY 'varDBUserPW';"
# drop
mysql -u root -p"$mysqlrootpw" -e "DROP DATABASE IF EXISTS \`varDBUser\`;"
#
explorer /etc/mysql/mariadb.conf.d/
systemctl varMode__restart__start__stop__status mariadb ;; systemctl status mariadb
vi2 /etc/mysql/mariadb.conf.d/50-server.cnf
cat /etc/mysql/mariadb.conf.d/50-server.cnf | cgrep1 bind-address max_connections innodb_buffer_pool_size innodb_log_file_size query_cache_size max_ character-set-server |less -RX
change /etc/mysql/mariadb.conf.d/50-server.cnf "bind-address            = 127.0.0.1" "bind-address = 0.0.0.0" line
# open worldwide bind:127.0.0.1 -> bind:0.0.0.0 // ufw open
ufw allow 3306/tcp ; ufw reload
systemctl restart mariadb
# php8 module on/off
apt install libapache2-mod-php8.3
a2enmod php8.3
a2dismod php8.3
systemctl restart apache2 
cat /etc/php/8.3/apache2/php.ini | cgrep1 limit max_ time listen user group |less -RX
vi2 /etc/php/8.3/apache2/php.ini # memory_limit = 256M upload_max_filesize = 64M post_max_size = 64M max_execution_time = 300 date.timezone = Asia/Seoul 
# purge old version
update-alternatives --set php /usr/bin/php8.3
dpkg -l | grep php | less -RX
!!! apt purge php8.2*


%%% {submenu_lamp}debian lamp set flow - php-fpm [a3]
%%%e {submenu_lamp}debian lamp set flow - php-fpm [a3]
%% echo "siteconf: $siteconf"
# php8 fpm 
a2enmod proxy proxy_fcgi setenvif ;; a2enconf php8.3-fpm
systemctl restart apache2 
systemctl enable php8.3-fpm --now
dpkg -L php8.3-fpm | cgrep etc | less -RX
# php8 fpm conf
cat /etc/php/8.3/fpm/php-fpm.conf | cgrep1 listen user group |less -RX
cat /etc/php/8.3/fpm/php.ini | cgrep1 limit max_ time listen user group |less -RX
cat /etc/php/8.3/fpm/pool.d/www.conf | cgrep1 listen owner user group 127.0.0.1 |less -RX
vi3 /etc/php/8.3/fpm/php-fpm.conf /etc/php/8.3/fpm/php.ini /etc/php/8.3/fpm/pool.d/www.conf
systemctl restart php8.3-fpm
explorer /etc/php/8.3/
# Apache VirtualHost - phpfpm set
cat /etc/apache2/sites-available/"varDom".conf
vi2 /etc/apache2/sites-available/"varDom".conf
# fpm-add in siteconf
export siteconf="/etc/apache2/sites-available/"varDom".conf" ;; ls -l $siteconf
# insert 함수를 이용해 fpm-add 추가 
printf '\n    <FilesMatch \\.php$>\n        SetHandler "proxy:unix:/run/php/php8.3-fpm.sock|fcgi://localhost/"\n    </FilesMatch>\n' | insert "$siteconf" "</Directory>" ;; cat $siteconf | cgrep1 php8.3-fpm.sock
systemctl restart apache2
# http://yoursite.com/info.php
echo "<?php phpinfo(); ?>" | tee varWWWroot/info.php
rm -f varWWWroot/info.php
# php-mysql-connect-check page
export your_db_user=varDBUser ; your_db_password=varDBUserPW ; your_db_name=varDBUser
template_edit php_db_con_test.php
template_view php_db_con_test.php
!!! template_copy php_db_con_test.php varWWWroot/php_db_con_test.php ;; cat "$lastarg"
# 디비정보 수정후 http://yoursite.com/php_db_con_test.php
vi2 varWWWroot/php_db_con_test.php
# test 후 즉시 삭제
rm -f varWWWroot/php_db_con_test.php  # 테스트후 즉시삭제
#
explorer $( echo /etc/apache2/sites-available/ /etc/apache2/sites-enabled/ /var/log/apache2/| pipemenu )



%%% {submenu_lamp}debian lamp set flow - php-fpm per user [a4]
%%%e {submenu_lamp}debian lamp set flow - php-fpm per user [a4]
%% echo "siteconf: $siteconf"
# php-fpm 을 각 계정별로 운영하여, 파일생성시 www-data 가 아닌 계정소유로 생성하여 운영
# www-data 소유의 파일이 아니라, 보안 문제 해결 
# php8 pool.d/id.conf create 
cat /etc/php/8.3/fpm/pool.d/www.conf | cgrep1 listen owner user group ondemand dynamic 127.0.0.1 |less -RX
vi2 /etc/php/8.3/fpm/pool.d/www.conf
cp -a /etc/php/8.3/fpm/pool.d/www.conf /etc/php/8.3/fpm/pool.d/varID.conf
cat /etc/php/8.3/fpm/pool.d/varID.conf | cgrep1 listen owner user group ondemand dynamic 127.0.0.1 |less -RX
vi2 /etc/php/8.3/fpm/pool.d/varID.conf 
change /etc/php/8.3/fpm/pool.d/varID.conf "[www]" "[varID]"
change /etc/php/8.3/fpm/pool.d/varID.conf "pm = dynamic" "pm = ondemand"
change /etc/php/8.3/fpm/pool.d/varID.conf "user = www-data" "user = varID"
change /etc/php/8.3/fpm/pool.d/varID.conf "group = www-data" "group = varID"
change /etc/php/8.3/fpm/pool.d/varID.conf "listen = " "listen = /run/php/php8.3-fpm-varID.sock" line
# siteconf socket edit
export siteconf="/etc/apache2/sites-available/"varDom".conf" ;; ls -l $siteconf
printf '\n    <FilesMatch \\.php$>\n        SetHandler "proxy:unix:/run/php/php8.3-fpm-varID.sock|fcgi://localhost/"\n    </FilesMatch>\n' | insert "$siteconf" "</Directory>" ;; cat $siteconf | cgrep1 php8.3-fpm.sock
cat /etc/apache2/sites-available/"varDom".conf | cgrep php fpm
# 기존 socket 설정 부분은 삭제
hash_add $siteconf php8.3-fpm.sock 
vi2 /etc/apache2/sites-available/"varDom".conf
systemctl restart apache2 
systemctl restart php8.3-fpm
#
explorer /etc/php/8.3/
#
ps aux | grep php-fpm | cgrep1 varID
# http://your-domain.com/whoami.php
echo '<?php echo exec("whoami"); ?>' > /home/varID/public_html/whoami.php
rm -f /home/varID/public_html/whoami.php



%%% {submenu_lamp}debian lamp set flow - bind - varNameDom [b1]
%%%e {submenu_lamp}debian lamp set flow - bind - varNameDom [b1]
%% echo "namedom:$namedom / serverip:$publicip"
apt install bind9 bind9utils bind9-doc dnsutils whois
# bind9 nameserver domain set - export
export namedom="varNameDom"
template_edit named.conf.options
template_view named.conf.options
!!! template_copy named.conf.options /etc/bind/named.conf.options
cat /etc/bind/named.conf.options | cgrep1 allow-query _SERVER_IP listen-on allow-transfer | less -RX
# 1차/2차 네임서버 아이피 설정
change /etc/bind/named.conf.options YOUR_1ST_NAME_SERVER_IP varNAME1IP 
change /etc/bind/named.conf.options "// YOUR_2ND_NAME_SERVER_IP" varNAME2IP 
vi2 /etc/bind/named.conf.options
named-checkconf /etc/bind/named.conf.options
#
# zone add - named.conf.local
printf "%s\n" 'zone "varNameDom" { type master; file "/etc/bind/db.varNameDom"; };' >> /etc/bind/named.conf.local
tail /etc/bind/named.conf.local | cgrep1 zone /etc/bind/db. | less -RX
vi2 /etc/bind/named.conf.local # zone add
# zone file edit - varNameDom
template_edit db.example.com
template_view db.example.com
!!! template_copy db.example.com /etc/bind/db.varNameDom # ns1 A 레코드 활성화 할것
cat /etc/bind/db.varNameDom | cgrep1 CNAME MX NS
change /etc/bind/db.varNameDom namedomain.com varNameDom
change /etc/bind/db.varNameDom YOUR_1ST_NAME_SERVER_IP varNAME1IP 
change /etc/bind/db.varNameDom YOUR_2ND_NAME_SERVER_IP varNAME2IP 
change /etc/bind/db.varNameDom YOUR_SERVER_IP varNAME1IP 
vi2 /etc/bind/db.varNameDom
# zone serial update (2nd name server push)
serialup /etc/bind/db.varNameDom
systemctl restart named ;;  systemctl status named
systemctl enable --now named ;;  systemctl status named
systemctl status named
#
named-checkconf /etc/bind/named.conf.local
named-checkzone varNameDom /etc/bind/db.varNameDom
named-checkconf
ufw allow 53
nmap -sU -p 53 $publicip
netstat -tulnp | grep named
journalctl -xeu named.service



%%% {submenu_lamp}debian lamp set flow - bind - varNameDom - reverse [b2]
%%%e {submenu_lamp}debian lamp set flow - bind - varNameDom - reverse [b2]
%% echo "namedom:$namedom / serverip:$publicip nameserverip:$nameserverip revip3o:$revip3o nameip3o:$nameip3o nameip4o:$nameip4o"
%% echo "namedom:$namedom / serverip:$publicip nameserver2ip:$nameserver2ip rev2ip3o:$rev2ip3o name2ip3o:$name2ip3o name2ip4o:$name2ip4o"
# Reverse Zone -> ISP 업체에 등록 요청해야 활성화
# IP 의 네트워크 부분을 뒤집어 이름을 만든다. 192.168.0 -> 0.168.192.in-addr.arpa
# varRevIP ex) 111.222.333.444 -> 444.333.222
# nameserverip
export namedom="varNameDom"
export nameserverip="varNAME1IP" ; export nameip3o=$(echo "$nameserverip" | awk -F. '{print $1"."$2"."$3}') ; export revip3o=$(echo "$nameserverip" | awk -F. '{print $3"."$2"."$1}') ; export nameip4o=$(echo "$nameserverip" | awk -F. '{print $4}')
# nameserver2ip (optional)
export nameserver2ip="varNAME2IP" ; export name2ip3o=$(echo "$nameserver2ip" | awk -F. '{print $1"."$2"."$3}') ; export rev2ip3o=$(echo "$nameserver2ip" | awk -F. '{print $3"."$2"."$1}') ; export name2ip4o=$(echo "$nameserver2ip" | awk -F. '{print $4}')
# named.conf.local add
printf '%s\n' 'zone "'"$revip3o"'.in-addr.arpa" { type master; file "/etc/bind/db.'"$nameip3o"'"; };' >> /etc/bind/named.conf.local ;; tail /etc/bind/named.conf.local | cgrep arpa
vi2 /etc/bind/named.conf.local
# db.nameserverip3octet create
template_edit db.example.com.rev
template_view db.example.com.rev
!!! template_copy db.example.com.rev /etc/bind/db.$nameip3o ;; ls -l /etc/bind/db.$nameip3o # ns1 A 레코드 활성화 할것
# ns1 revip
change /etc/bind/db.$nameip3o NS1IP4OCTET $nameip4o
change /etc/bind/db.$nameip3o example.com $namedom
# ns2 revip (optional)
change /etc/bind/db.$nameip3o NS2IP4OCTET $name2ip4o
#
cat /etc/bind/db.$nameip3o| cgrep1 CNAME MX NS
vi2 /etc/bind/db.$nameip3o
# zone serial update
serialup /etc/bind/db.$nameip3o
#
named-checkzone $revip3o.in-addr.arpa /etc/bind/db.$nameip3o
systemctl restart named ;;  systemctl status named
systemctl enable --now named ;;  systemctl status named
systemctl status named
# log 
mkdir /var/log/bind ; chown bind:bind /var/log/bind ; chmod 775 /var/log/bind
explorer /etc/bind



%%% {submenu_lamp}debian lamp set flow - bind - varDom [b3]
%%%e {submenu_lamp}debian lamp set flow - bind - varDom [b3]
%% echo "namedom:$namedom / serverip:$publicip"
# hosting domain add
printf "%s\n" 'zone "varDom" { type master; file "/etc/bind/db.varDom"; };' >> /etc/bind/named.conf.local
tail /etc/bind/named.conf.local | cgrep1 zone /etc/bind/db. | less -RX
vi2 /etc/bind/named.conf.local # zone add
# zone file edit - varDom
template_edit named.conf.options
template_view named.conf.options
!!! template_copy db.example.com /etc/bind/db.varDom # ns1 A 레코드 주석 
cat /etc/bind/db.varDom | cgrep1 CNAME MX NS
change /etc/bind/db.varDom namedomain.com varNameDom
change /etc/bind/db.varDom YOUR_1ST_NAME_SERVER_IP varNAME1IP 
change /etc/bind/db.varDom YOUR_2ND_NAME_SERVER_IP varNAME2IP 
change /etc/bind/db.varDom YOUR_SERVER_IP varDomIP 
vi2 /etc/bind/db.varDom
#
named-checkzone varDom /etc/bind/db.varDom
#
systemctl restart bind9
#
nslookup varDom
dig varDom
dig -x varDomIP # (역방향 DNS 조회)
#
nslookup varNameDom
nslookup varNameDom 127.0.0.1
nslookup varNameDom ns1.varNameDom
nslookup -type=NS varNameDom
dig varNameDom
dig -x varNameDomIP # (역방향 DNS 조회)
resolvectl status
# zone serial update
serialup /etc/bind/db.varDom
#
systemctl restart named ;;  systemctl status named
systemctl enable --now named ;;  systemctl status named
systemctl status named
#
explorer /etc/bind





%%% {submenu_lamp}debian lamp set flow - postfix [m1]
%%%e {submenu_lamp}debian lamp set flow - postfix [m1]
apt install postfix dovecot-core dovecot-imapd dovecot-pop3d mailutils
# postfix (smtp)
vi2 /etc/postfix/main.cf 
cat /etc/postfix/main.cf |cgrep1 myhostname mydomain myorigin my private mailbox
rbackup /etc/postfix/main.cf ;; ls -ltr ${lastarg}*|tail -n5
echo "home_mailbox = Maildir/" >> /etc/postfix/main.cf
vi2 /etc/postfix/master.cf
change /etc/postfix/master.cf  "#submission inet n"  "submission inet n"
change /etc/postfix/master.cf  "#  -o syslog_name=" "  -o syslog_name="
change /etc/postfix/master.cf  "#  -o smtpd_tls_security_level=encrypt" "  -o smtpd_tls_security_level=encrypt"
change /etc/postfix/master.cf  "#  -o smtpd_sasl_auth_enable=yes" "  -o smtpd_sasl_auth_enable=yes"
change /etc/postfix/master.cf  "relay_restrictions" "  -o smtpd_relay_restrictions=permit_sasl_authenticated,reject" line
# postfix sasl auth set 
change /etc/postfix/main.cf smtpd_relay_restrictions "smtpd_relay_restrictions = permit_mynetworks, permit_sasl_authenticated, reject_unauth_destination" line
printf $'smtpd_sasl_type = dovecot\nsmtpd_sasl_path = private/auth  \nsmtpd_sasl_auth_enable = yes\n' >> /etc/postfix/main.cf
cdiff /etc/postfix/main.cf.1.bak /etc/postfix/main.cf 
# 
postconf -n | cgrep1 sasl home_mailbox myhostname
postfix check
systemctl restart postfix ;; systemctl status postfix
systemctl enable --now postfix ;; systemctl status postfix
journalctl -u postfix -n 200
nmap localhost
echo "Test Mail" | mail -s "Test Subject" root@varDom
ls -al /var/mail ;; ls -al ~/Maildir/new/
explorer /etc/postfix/

%%% {submenu_lamp}debian lamp set flow - dovecot [m2]
%%%e {submenu_lamp}debian lamp set flow - dovecot [m2]
# Dovecot (imap/pop)
vi2 /etc/dovecot/dovecot.conf # protocols = imap pop3 , mail_location = maildir:~/Maildir
# mail_location chg ~/Maildir/
change /etc/dovecot/conf.d/10-mail.conf "mail_location" "mail_location = maildir:~/Maildir" line
cat /etc/dovecot/conf.d/10-mail.conf | cgrep1 mail_location | less -RX
vi2 /etc/dovecot/conf.d/10-mail.conf
# 10-auth.conf
cat /etc/dovecot/conf.d/10-auth.conf | cgrep1 auth-system.conf.ext  | less -RX
vi2 /etc/dovecot/conf.d/10-auth.conf
change /etc/dovecot/conf.d/10-auth.conf "#disable_plaintext_auth" "disable_plaintext_auth = no" line
change /etc/dovecot/conf.d/10-auth.conf "auth_mechanisms" "auth_mechanisms = plain login" line
change /etc/dovecot/conf.d/10-auth.conf "#!include auth-system.conf.ext" "!include auth-system.conf.ext" line
: insert; echo 'auth_username_format = %n' | insert /etc/dovecot/conf.d/10-auth.conf "#auth_username_format"
# 10-master.conf -> sasl auth set (smtp auth)
rbackup /etc/dovecot/conf.d/10-master.conf ;; ls -ltr ${lastarg}*|tail -n5
: insert; printf $'  unix_listener /var/spool/postfix/private/auth {\n    mode = 0666\n    user = postfix\n    group = postfix\n  }\n' | insert /etc/dovecot/conf.d/10-master.conf "postfix/private" ;; cdiff /etc/dovecot/conf.d/10-master.conf.1.bak /etc/dovecot/conf.d/10-master.conf
vi2 /etc/dovecot/conf.d/10-master.conf
vi2 /etc/dovecot/conf.d/10-ssl.conf
vi2 /etc/postfix/main.cf
#
systemctl restart postfix ;; systemctl status postfix
systemctl enable --now postfix ;; systemctl status postfix
systemctl restart dovecot ;; systemctl status dovecot
systemctl enable --now dovecot ;; systemctl status dovecot
dovecot -n
# useradd
adduser -m -s /bin/bash varMailuser
paswd varMailuser
# ufw
ufw allow 25/tcp ; ufw allow 587/tcp ; ufw allow 993/tcp ;ufw allow 995/tcp
ufw reload




# todo
# Certbot 
# SPF, DKIM, DMARC, 스팸 필터
# 웹메일 설치: Roundcube, SquirrelMail
# vsftpd


%%% {submenu_lamp}debian lamp set flow - roundcube webmail [m3]
%%%e {submenu_lamp}debian lamp set flow - roundcube webmail [m3]
%% echo "webroot:$webroot // SERVERNAME:$SERVERNAME // http://$SERVERNAME/installer/"
# mailserver / mariadb / apache / php / dns (webmail.mailserver.com)
# Roundcube용 데이터베이스 및 사용자 생성
[ -z "$mysqlrootpw" ] && echo "mysqlrootpw=varPassword" >> ~/go.private.txt ; source ~/go.private.txt
echo $mysqlrootpw ;; mysqlrootpw=varPassword
mysql -u root -p"$mysqlrootpw"
# roundcube db create
mysql -u root -p"$mysqlrootpw" -e "CREATE DATABASE roundcube CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;CREATE USER 'roundcube'@'localhost' IDENTIFIED BY 'varRCpw';GRANT ALL PRIVILEGES ON roundcube.* TO 'roundcube'@'localhost';FLUSH PRIVILEGES;"
mysql -u root -p"$mysqlrootpw" -e "show databases;"
# install 
# /var/www/roundcube 위치로 설치 진행
export webroot=varWWWroot__@@var@@www
cd $webroot ; ls -al ; readxy &&  explorer $webroot
: download ; API_URL="https://api.github.com/repos/roundcube/roundcubemail/releases/latest" ;; DOWNLOAD_URL=$(curl -sL "$API_URL" | jq -r '.assets[] | select(.name | test("-complete.tar.gz$")) | .browser_download_url') ;; FILENAME="roundcube-latest-complete.tar.gz" ;; curl -L "$DOWNLOAD_URL" -o "$FILENAME"
: extract ; tar -xzf "$FILENAME" ;; EXTRACTED_DIR=$(find . -maxdepth 1 -type d -name 'roundcubemail-*' -print -quit) ;; mv "$EXTRACTED_DIR" roundcube
ls -al $webroot/roundcube
cd roundcube && chown -R www-data:www-data . && chmod -R 775 temp/ logs
# /etc/apache2/sites-available/roundcube.conf
# ex) SERVERNAME=webmail.yourdoamin.com
export SERVERNAME="varWebmailDom"
template_edit roundcube.conf
template_view roundcube.conf
!!! template_copy roundcube.conf /etc/apache2/sites-available/roundcube.conf
vi2 /etc/apache2/sites-available/roundcube.conf
a2ensite roundcube.conf
systemctl reload apache2 ;; systemctl status apache2
tail -f $( ls -1 /var/log/apache2/*.log |pipemenu ) 
# web install
# http://$SERVERNAME/installer/
vi $webroot/roundcube/config/config.inc.php
chown www-data:www-data $webroot/roundcube/config/config.inc.php ; chmod 600 $webroot/roundcube/config/config.inc.php
# install page del or mv 
mv $webroot/roundcube/installer/ $webroot/roundcube/installer.$(datetag) ; ls -al 
# log
tail -f $webroot/roundcube/logs/errors.log
cat $webroot/roundcube/logs/errors.log | less -RX



%%% {submenu_lamp}debian lamp set flow - /webmail alias [m4]
%%%e {submenu_lamp}debian lamp set flow - /webmail alias [m4]
%% echo "webroot:$webroot" 
# 웹서버 가상호스트의 http://a.com/webmail 접근시 roundcube 접근 설정
export webroot=varWWWroot__@@var@@www
cd $webroot/roundcube ; ls -al ; 
explorer $webroot/roundcube
# 
template_edit webmail.conf
template_view webmail.conf
!!! template_copy webmail.conf /etc/apache2/conf-available/webmail.conf
vi2 /etc/apache2/conf-available/webmail.conf
a2enconf webmail
systemctl reload apache2 ;; systemctl status apache2
tail -f $( ls -1 /var/log/apache2/*.log |pipemenu ) 
# log
tail -f $webroot/roundcube/logs/errors.log
cat $webroot/roundcube/logs/errors.log | less -RX




%%% {submenu_lamp}debian lamp set flow - certbot [cert]
%%%e {submenu_lamp}debian lamp set flow - certbot [cert]
%% echo "webroot:$webroot // SERVERNAME:$SERVERNAME // http://$SERVERNAME/installer/"
# Let's Encrypt 인증서 발행 ( web or mail ssl )
# /etc/postfix/main.cf /etc/dovecot/conf.d/10-ssl.conf 
# 인증서/개인키 갱신 필요 // 메일송수신시 보안암호 인증
export SERVERNAME="varDom"
# certbot
apt install python3-certbot-apache
: @,www,mail,webmail ; certbot --apache --redirect -d $SERVERNAME -d www.$SERVERNAME -d mail.$SERVERNAME -d webmail.$SERVERNAME 
: subdomain only ; certbot --apache --redirect -d $SERVERNAME 
: mail only ssl ; certbot --apache -d $SERVERNAME
systemctl reload apache2
# certbot renew / list / delete
systemctl status certbot.timer
certbot certificates | cgrepn Domains Validity 10  # 유효기간 확인
certbot delete varCert
# dovecot-ssl.conf - ssl change
cat /etc/dovecot/conf.d/10-ssl.conf | cgrep1 ssl_cert ssl_key | less -RX
change /etc/dovecot/conf.d/10-ssl.conf "ssl_cert =" "ssl_cert = </etc/letsencrypt/live/$SERVERNAME/fullchain.pem" line
change /etc/dovecot/conf.d/10-ssl.conf "ssl_key =" "ssl_key = </etc/letsencrypt/live/$SERVERNAME/privkey.pem" line
# postfix-main.cf - ssl change
cat /etc/postfix/main.cf | cgrep1 smtpd_tls_cert_file smtpd_tls_key_file | less -RX
change /etc/postfix/main.cf "smtpd_tls_cert_file=" "smtpd_tls_cert_file=/etc/letsencrypt/live/$SERVERNAME/fullchain.pem" line
change /etc/postfix/main.cf "smtpd_tls_key_file=" "smtpd_tls_key_file=/etc/letsencrypt/live/$SERVERNAME/privkey.pem" line
# privkey read perm set // 개인키를 읽을수 있는 권한을 dovecot/postfix 에게 설정 
# 예: ssl-cert 그룹이 있고 dovecot 사용자를 추가해야 한다면
groupadd ssl-cert # 그룹이 없다면 생성
usermod -a -G ssl-cert dovecot ; usermod -a -G ssl-cert postfix
chown root:ssl-cert /etc/letsencrypt/archive/$SERVERNAME/privkey1.pem ; chmod 640 /etc/letsencrypt/archive/$SERVERNAME/privkey1.pem ; chmod 711 /etc/letsencrypt/archive/ 
ls -al /etc/letsencrypt/live/$SERVERNAME/ ;; ls -al /etc/letsencrypt/archive/ ;; ls -al /etc/letsencrypt/archive/$SERVERNAME
#
systemctl restart dovecot ;; systemctl status dovecot
journalctl -u dovecot -n 50 --no-pager
journalctl -f -u dovecot
tail -n1000 /var/log/mail.log|less -RX


%%% {submenu_lamp}debian lamp set flow - vsftpd & ufw [f1]
%%%e {submenu_lamp}debian lamp set flow - vsftpd & ufw [f1]
# vsftpd
# anonymous_enable=NO local_enable=YES write_enable=YES chroot_local_user=YES
apt install vsftpd
vi2 /etc/vsftpd.conf 
cat /etc/vsftpd.conf | cgrep1 listen _enable local_umask use_localtime log_file xferlog_ | less -RX
change /etc/vsftpd.conf "listen=NO" "listen=YES"
change /etc/vsftpd.conf "listen_ipv6=YES" "listen_ipv6=NO"
change /etc/vsftpd.conf "#write_enable=YES" "write_enable=YES"
change /etc/vsftpd.conf "#local_umask=022" "local_umask=022"
change /etc/vsftpd.conf "#chroot_local_user=YES" "chroot_local_user=YES"
change /etc/vsftpd.conf "#xferlog_std_format=YES" "xferlog_std_format=YES"
hash_add /etc/vsftpd.conf "xferlog_file="
printf $'vsftpd_log_file=/var/log/vsftpd.log\nxferlog_file=/var/log/xferlog\n\n' | insert /etc/vsftpd.conf "xferlog_file="
#
echo "allow_writeable_chroot=YES" | insert /etc/vsftpd.conf "chroot_local_user=YES"
printf $'pasv_enable=YES\npasv_min_port=40000\npasv_max_port=40100\n' >> /etc/vsftpd.conf
# 
systemctl restart vsftpd ;;  systemctl status vsftpd
systemctl enable --now vsftpd ;;  systemctl status vsftpd
systemctl status vsftpd
tail -f /var/log/xferlog
# ufw firewall
apt install ufw
ufw enable
ufw status
# all allow
for port in ssh http https ftp 20/tcp 1024:1048/tcp domain pop3 pop3s imap imaps smtp smtps submission; do ufw allow $port; done
# select allow
ufw varMode__allow__disallow varPort__ssh__http__https__ftp__20@@tcp__domain__pop3__pop3s__imap__imaps__smtp__smtps__submission__mysql__3306@@tcp__postgresql__5432@@tcp__redis__6379@@tcp__mongodb__27017@@tcp__memcached__11211@@tcp__25565@@tcp__21@@tcp__990@@tcp__25@@tcp__587@@tcp__465@@tcp__1194@@udp__500@@udp__4500@@udp
# ftp passive mode
ufw allow 40000:40100/tcp 
# backup rsync
apt install rsync -y
rsync -avz /var/www/ /backup/www/
rsync -avz /etc/ /backup/etc/



%%% {submenu_lamp}debian lamp set flow - phpmyadmin [db]
%%%e {submenu_lamp}debian lamp set flow - phpmyadmin [db]
# install
apt install phpmyadmin
dpkg-reconfigure phpmyadmin
# apache module add
vi2 /etc/apache2/conf-available/phpmyadmin.conf
a2enconf phpmyadmin.conf
systemctl reload apache2 ;; systemctl status apache2 
# web
# http://yourdomain.com/phpmyadmin/
explorer /var/www/
explorer /etc/apache2/
# fail2ban
#
# ( optional )  
# apache auth add // phpmyadmin ddos ban
mkdir /etc/apache2/.htpasswd
# pre auth to enter phpmyadmin
touch /etc/apache2/.htpasswd/pma_pass ; chown root:www-data /etc/apache2/.htpasswd/pma_pass ; chmod 640 /etc/apache2/.htpasswd/pma_pass
htpasswd /etc/apache2/.htpasswd/pma_pass varUser
vi2 /etc/apache2/.htpasswd/pma_pass
# perm
chown root:www-data /etc/apache2/.htpasswd/pma_pass ; chmod 640 /etc/apache2/.htpasswd/pma_pass
# auth set 
printf $'AuthType Basic\nAuthName "Restricted Access - phpMyAdmin"\nAuthUserFile /etc/apache2/.htpasswd/pma_pass\nRequire valid-user\n' | insert /etc/apache2/conf-available/phpmyadmin.conf "DirectoryIndex index.php"


%%% {submenu_lamp}debian lamp set flow - wordpress [word]
%%%e {submenu_lamp}debian lamp set flow - wordpress [word]
# varID varDBname varDom 
# 권한을 rwxr-s---으로 설정: 2: setgid ? 하위 디렉토리/파일이 이 그룹을 상속함
cd ~varID/public_html ; chgrp www-data . ; chmod 2750 .
wget https://wordpress.org/latest.tar.gz
tar -xzf latest.tar.gz
# public_html/ 에 직접 운영 --> http://yourdomain.com/
mv wordpress/* . && rm -rf wordpress latest.tar.gz && ls -al 
# public_html/wp/ 에 운영 --> http://yourdoamin.com/wp/
mv wordpress/ wp/ && rm -f latest.tar.gz && ls -al 
chown varID:varID wp -R ; chmod 775 wp ; ls -al 
# web install
echo "$(YEL1)http://varDom/$(RST)" ;; readxy "lynx" && lynx http://varDom/
echo "$(YEL1)http://varDom/wp/$(RST)" ;; readxy "lynx" && lynx http://varDom/wp/
# www-data write perm test
usermod -aG varID www-data ;; cat /etc/group | grep varID
sudo -u www-data touch /home/varID/public_html/wp/test.txt
sudo -u varOtherID touch /home/varID/public_html/wp/test.txt
ls -al ~varID/public_html/
ls -al ~varID/public_html/wp/
vi2 ~varID/public_html/wp/wp-config.php
chmod 640 wp-config.php ; chown varID:www-data wp-config.php
sudo -u varOtherID cat /home/varID/public_html/wp/wp-config.php
# /wp/ .htacess
printf $'RewriteEngine On\n\nRewriteCond %%{REQUEST_URI} ^/$\nRewriteRule ^$ /wp/ [L,R=302]\n' >> ~varID/public_html/.htaccess && cat ~varID/public_html/.htaccess
vi2 ~varID/public_html/.htaccess


%%% {submenu_lamp}debian lamp set flow - Web Hosting Account [web]
%%%e {submenu_lamp}debian lamp set flow - Web Hosting Account [web]
%% echo "id:${id} pw:$pw dbid:$dbid dbpw:$dbpw webroot:$webroot yourdomain:${yourdomain} siteconf:$siteconf yourrootdomain:$yourrootdomain yoursubdomain:$yoursubdomain"
export webroot="/home/varID/public_html" id="varID" pw="varPW" yourdomain="varDom" dbid="varID" dbpw="varPW" dbhostname="localhost" siteconf="/etc/apache2/sites-available/${yourdomain}.conf" created_at=$(date '+%F %T') ; case "$yourdomain" in *.co.kr|*.or.kr|*.com|*.net|*.org|*.kr) yourrootdomain="${yourdomain#*.}"; yoursubdomain="${yourdomain%%.*}" ;; *) yourrootdomain="$yourdomain"; yoursubdomain="" ;; esac; export yourrootdomain yoursubdomain
: useradd ; useradd ${id} -md /home/${id} -c varComment__pro__dev__sup -s varShell__@@bin@@bash__@@bin@@nologin; echo "${id}:$pw" | chpasswd ;; usermod -aG ${id} www-data ; mkdir -p $webroot ; chown -R ${id}:www-data $webroot ; chmod 2750 $webroot ; chmod 711 /home/${id} ;; setfacl -dR -m u:${id}:rwx /home/${id} || yyay acl
: mysql ; mysql -u root -e "CREATE DATABASE \`$dbid\`; CREATE USER '$dbid'@'localhost' IDENTIFIED BY '$dbpw'; GRANT ALL PRIVILEGES ON \`$dbid\`.* TO '$dbid'@'localhost'; FLUSH PRIVILEGES;"
template_view example.com.conf && readxy && template_copy example.com.conf $siteconf && cat $siteconf && readxy && a2ensite ${yourdomain}.conf
#echo "<h1>Success! Your virtual host is working!</h1>" | tee $webroot/index.html
template_view webindex.html && readxy && template_copy webindex.html $webroot/index.html
template_view fpm_pool.conf ; readxy && template_copy fpm_pool.conf /etc/php/8.3/fpm/pool.d/${id}.conf
printf "\n    <FilesMatch \\.php$>\n        SetHandler \"proxy:unix:/run/php/php8.3-fpm-${id}.sock|fcgi://localhost/\"\n    </FilesMatch>\n" | insert "$siteconf" "</Directory>" ;; cat $siteconf | cgrep1 php8.3-fpm.sock
#
systemctl restart php8.3-fpm
systemctl restart apache2
# bind set - in name server 
# root doamin - conf.local add / zone create
printf 'zone "%s" { type master; file "/etc/bind/db.%s"; };\n' "$yourdomain" "$yourdomain" >> /etc/bind/named.conf.local ;; tail /etc/bind/named.conf.local
# 네임서버와 웹서버가 분리 or 네임서버와 웹서버가 하나 (2nd 네임서버없)
export name1st="ns1.varNameDom" name2nd="ns2.varNameDom2nd" serverip="varWebserverip"
export name1st="ns1.varNameDom" name2nd="ns2.varNameDom" serverip="$publicip"
template_view db.yourdomain.com ; readxy && template_copy db.yourdomain.com /etc/bind/db.$yourdomain ;; cat /etc/bind/db.$yourdomain
named-checkzone /etc/bind/db.$yourdomain && systemctl restart named 
# 이미 zone 파일이 있을때 서브도메인추가  ex) host abc.yourdomain.com >> db.yourdomain.com
echo "$yoursubdomain IN A $publicip" >> /etc/bind/db.$yourrootdomain ;; tail /etc/bind/db.$yourrootdomain
named-checkzone $yourrootdomain /etc/bind/db.$yourrootdomain && systemctl restart named 
#
!!! userdel -r -f ${id} ; groupdel ${id}
!!! mysql -u root -e "DROP DATABASE IF EXISTS \`${id}\`; DROP USER '${id}'@'localhost'; SHOW DATABASES ;"
template_edit $( echo example.com.conf webindex.html fpm_pool.conf db.yourdomain.com | pipemenu )
vi2 $( echo $siteconf /etc/bind/named.conf.local /etc/bind/db.$yourdomain /etc/bind/db.$yourrootdomain | pipemenu ) 
: next page ; web1

%%% {submenu_lamp}debian lamp set flow - Web Hosting Account2 [web1]
%%%e {submenu_lamp}debian lamp set flow - Web Hosting Account2 [web1]
%% echo "SERVERNAME: $SERVERNAME"
# let's encrypt ssl certbot
export SERVERNAME="varDom"
# if root domain 
: @,www,mail,webmail ; certbot --apache --redirect -d $SERVERNAME -d www.$SERVERNAME -d mail.$SERVERNAME -d webmail.$SERVERNAME
# if sub domain
: subdomain only ; certbot --apache --redirect -d $SERVERNAME
# reload 
systemctl reload apache2
# certbot check cert
certbot certificates | cgrepn Domains Validity 10  # 유효기간 확인
# delete cert
certbot delete varCert
# userinfo
userinfo varID
: before page ; web
: check web ; flow_lamp_adv
: lets encrypte ssl ; cert

# cert 
# postfix virtusertable /etc/postfix/virtual
# cband
# mail send
# dom chg
# /home/id/.userinfo chattr +a awk lastseen 
#
#trash
export yoursubdomain="${yourdomain%%.*}" yourrootdomain="${yourdomain#*.}" 



%%% {submenu_lamp}Web Hosting Control Panel - aaPanel [aap]
%%%e {submenu_lamp}Web Hosting Control Panel - aaPanel [aap]
# clean os -> aapenel install   6 sudo apt update && sudo apt upgrade -y
URL=https://www.aapanel.com/script/install_7.0_en.sh && if [ -f /usr/bin/curl ];then curl -ksSO "$URL" ;else wget --no-check-certificate -O install_7.0_en.sh "$URL";fi;bash install_7.0_en.sh aapanel
# ufw allow
ufw allow 7800/tcp  ; ufw allow 443/tcp ; ufw allow 20/tcp  
ufw reload        # 방화벽 규칙 다시 로드
# https://<YOUR_SERVER_IP>:7800/
bt
service bt varMode__start__stop__restart
# uninstall
service bt stop && chkconfig --del bt && rm -f /etc/init.d/bt && rm -rf /www/server/panel
systemctl stop bt.service ; systemctl disable bt.service ; rm -f /etc/init.d/bt ; rm -f /lib/systemd/system/bt.service /etc/systemd/system/bt.service ; systemctl daemon-reload ; rm -rf /www/server/panel
# etc
# 상용: cPanel, Plesk, DirectAdmin
# 오픈소스: aaPanel, HestiaCP, CyberPanel, Webmin/Virtualmin, CloudPanel







%%% {submenu_lamp}debian/ubuntu lamp set [lampu]
%%%e {submenu_lamp}debian/ubuntu lamp set [lampu]
# db
apt install -y mariadb-server mariadb-client
mysql_secure_installation
systemctl status mariadb
# apache2
apt install -y apache2 apache2-doc
a2enmod userdir
systemctl restart apache2
# firewalld
apt install ufw
ufw app list
ufw app info "WWW Full"
ufw allow in "WWW Full"
# php / perl / python
apt install -y php libapache2-mod-php php-mysql
apt install -y php-cli php-fpm php-json php-pdo php-mbstring php-zip php-gd php-curl
vi2 /var/www/html/info.php
#
apt install -y perl libapache2-mod-perl2
apt install -y python3 libapache2-mod-python
#
apt install -y phpmyadmin
vi2 /etc/apache2/conf-available/phpmyadmin.conf
ln -s /etc/phpmyadmin/apache.conf /etc/apache2/conf-available/phpmyadmin.conf
a2enconf phpmyadmin
systemctl reload apache2
#
ls -al /etc/apache2/sites-enabled/
ls -al /etc/apache2/sites-available/ ;; a2ensite varSITE
a2dissite varSITE
a2ensite varSITE
explorer /etc/apache2/





%%% {submenu_lamp}Rocky,Alma (8/9) lamp set [lampc]
%%%e {submenu_lamp}Rocky,Alma (8/9) lamp set [lampc]
# apache install
dnf install -y httpd httpd-tools
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
firewall-cmd --permanent --zone=public --add-service=http 
firewall-cmd --permanent --zone=public --add-service=https 
firewall-cmd --reload
systemctl restart httpd
# http://IP_address
#
# php install epel repo add
rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
# alma8 php7.x
dnf module list php
dnf module reset php
dnf module enable php:varVersion
dnf install -y php php-cli php-gd php-curl php-zip php-mbstring php-mysqlnd
# alma9 php8.1
dnf install -y php php-mysqlnd php-dom php-simplexml php-xml php-xmlreader php-curl php-exif php-ftp php-gd php-iconv php-json php-mbstring php-posix php-sockets php-tokenizer
systemctl restart httpd 
php -v 
dnf install -y phpMyAdmin.noarch
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
dnf search php
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
# db install
dnf install -y mariadb-server mariadb
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql_secure_installation
mysql -e "SHOW DATABASES;" -p
# 
ntsysv || yy ntsysv



%%% {submenu_lamp}Centos7 lamp set [lampcc]
%%%e {submenu_lamp}Centos7 lamp set [lampcc]
# apache install
yum install -y httpd
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
firewall-cmd --permanent --zone=public --add-service=http
firewall-cmd --permanent --zone=public --add-service=https
firewall-cmd --reload
systemctl restart httpd
# http://IP_address
#
# php
yum install -y php php-mysql
systemctl restart httpd
php -v
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
yum install -y phpmyadmin
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
# db install
yum install -y mariadb-server mariadb
mysql_secure_installation
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql -e "SHOW DATABASES;" -p
#
ntsysv || yy ntsysv


%%% {submenu_lamp}Annyung3 lamp set [lampan3]
%%%e {submenu_lamp}Annyung3 lamp set [lampan3]
# apache install
yum install -y varPkg__httpd
yy httpd mod_ssl httpd-devel
yum search varPkg__httpd --disablerepo='*' --enablerepo="AN:addon" --enablerepo="AN:core" --enablerepo="AN:base" --enablerepo="AN:xless"
yum list varPkg__httpd* |cgrep Installed|cgrep1 Available
yum list installed |grep varPkg__http
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
chattr +i /etc/httpd/conf/httpd.conf ; vi2 /etc/httpd/conf/httpd.conf
vi2 $( find /etc/httpd/conf.d/ -type f | pipemenu )
vi2 $( find /etc/httpd/user.d/ -type f | pipemenu )
explorer /etc/httpd/
httpd -V | cgrep MPM | cdir
# http://IP_address
#
# php install
yy php80* --skip-broken
yy php74* --skip-broken
yum list installed|grep php
explorer /etc/$( ls -1 /etc/ |grep php | pipemenu )
systemctl restart httpd
php -v
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
# phpmyadmin
yy phpmyadmin
rpm -ql varPKG__phpMyAdmin | less -RX
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
yumdownloader phpMyAdmin.noarch
rpms=$(ls -1tr|grep phpMyAdmin|tail -n1) ; rpm -ivh --nodeps $rpms ; readx ; rpm -ql ${rpms%.rpm}
# db install
yum install -y mariadb-server mariadb
mysql_secure_installation
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql -e "SHOW DATABASES;" -p
# httpd watch
rpm -ql check-utils
/usr/bin/chkbandwidth
/usr/bin/httpwatch http://localhost
vi2 $( echo /etc/cron.d/httpd-monitor /etc/sysconfig/httpd-monitor|pipemenu )
# proftpd 
yy proftpd
systemctl start proftpd.socket
netstat -tulpn | grep -v :::|grep LISTEN|sort -k4
#
ntsysv || yy ntsysv





%%% {submenu_lamp}Apache Modules - mod_cband [cband]
%%%e {submenu_lamp}Apache Modules - mod_cband [cband]
cd /usr/local/src
wget https://fossies.org/linux/www/apache_httpd_modules/old/mod-cband-0.9.7.5.tgz
tar zxvf mod-cband-0.9.7.5.tgz 
cd mod-cband-0.9.7.5
which apxs || yy httpd-devel 
which apxs || ay apache2-dev
./configure --with-apxs=$(which apxs)
make
# apache 2.4 error -> patch
sed s/remote_ip/client_ip/g -i src/mod_cband.c
sed s/c-\>remote_addr/c-\>client_addr/g -i src/mod_cband.c
make
make install
# ########## centos load module set add -> httpd.conf
# ##########################
echo "LoadModule cband_module       modules/mod_cband.so" >> /etc/httpd/conf/httpd.conf
echo "LoadModule cband_module       modules/mod_cband.so" >> /usr/local/apache/conf/httpd.conf
echo "LoadModule cband_module       modules/mod_cband.so" >> /etc/httpd/conf.d/LoadModules.conf
# cband-status throttle-me alias & permit set
template_view cband.conf
!!! template_copy cband.conf /etc/httpd/conf.d/cband.conf ;; cat $lastarg
echo "CBandScoreboard /var/run/apache2/cband_scoreboard 61440" >> /etc/httpd/conf.d/cband.conf
vi2 /etc/httpd/conf.d/cband.conf
systemctl restart httpd && systemctl status httpd
systemctl status httpd
# ########## debian/ubuntu
# ##########################
echo "LoadModule cband_module /usr/lib/apache2/modules/mod_cband.so" >> /etc/apache2/apache2.conf
vi2 /etc/apache2/apache2.conf
a2enmod cband
# cband-status throttle-me alias & permit set
template_view cband.conf
!!! template_copy cband.conf /etc/apache2/conf-available/cband.conf ;; cat $lastarg
echo "CBandScoreboard /var/run/apache2/cband_scoreboard 61440" >> /etc/apache2/conf-available/cband.conf
vi2 /etc/apache2/conf-available/cband.conf
a2enconf cband
systemctl restart apache2 && systemctl status apache2
systemctl status apache2
# apache 2.4 error -> 'Order command' error -> access_compat_module -> on
# scoreboard 는 restart 시 초기화 reload 시 유지 
explorer /etc/httpd/
explorer /etc/apache2/
template_edit cband.conf



%%% {submenu_lamp}Apache Modules - mod_cband - cbnaduser [cbandu]
%%%e {submenu_lamp}Apache Modules - mod_cband - cbanduser [cbandu]
# :80 :443 등 동일한 호스트가 나뉜경우 트래픽 합산 계산
cd /etc/apache2/sites-available
cat varDom.conf
cat varDom-le-ssl.conf
cp -a varDom.conf varDom.conf~
cp -a varDom-le-ssl.conf varDom-le-ssl.conf~
# 
cat varDom.conf~ | cgrep CBandUser
cat varDom-le-ssl.conf~ | cgrep CBandUser
# cbanduser set 가상호스트 시작되기전 상단 cbanduser 지시자 설정 
printf '1i\n<CBandUser varDom>\n    CBandUserLimit varLimit__1000M\n</CBandUser>\n.\nwq\n' | ed -s varDom.conf~ && cat varDom.conf~ | cgrep CBandUser
# cbanduserlist set
printf '?ServerAlias?a\n%s\n.\nwq\n' "    CBandUser varDom" | ed -s varDom.conf~ && cat varDom.conf~ | cgrep CBandUser
printf '?ServerAlias?a\n%s\n.\nwq\n' "    CBandUser varDom" | ed -s varDom-le-ssl.conf~ && cat varDom-le-ssl.conf~ | cgrep CBandUser
#
# 적용
mv varDom.conf varDom.conf~~ && mv varDom.conf~ varDom.conf 
mv varDom-le-ssl.conf varDom-le-ssl.conf~~ && mv varDom-le-ssl.conf~ varDom-le-ssl.conf
#
apachectl -t
systemctl restart apache2 && systemctl status apache2





%%% {submenu_lamp}Lamp - auto install sh GIT [lampa]
%%%e {submenu_lamp}Lamp - auto install sh GIT [lampa]
# https://github.com/teddysun/lamp
# source down & compile install /usr/local/src
yyay wget git
cd $HOME ; git clone https://github.com/teddysun/lamp.git
cd $HOME/lamp
chmod 755 *.sh
vi2 ./lamp.sh
./lamp.sh
# auto
./lamp.sh -h
# auto example
./lamp.sh --apache_option 1 --apache_modules mod_wsgi,mod_security --db_option 1 --db_root_pwd teddysun.com --php_option 1 --php_extensions apcu,ioncube,imagick,redis,mongodb,libsodium,swoole --db_manage_modules phpmyadmin,adminer --kodexplorer_option 1
# 
# upgrade
cd $HOME/lamp
# Resets the index and working tree
git reset --hard         
# Get latest version first
git pull                 
chmod 755 *.sh
vi2 ./upgrade.sh
./upgrade.sh             
./upgrade.sh apache     
./upgrade.sh db        
./upgrade.sh php      
./upgrade.sh phpmyadmin 
./upgrade.sh adminer   
# backup
vi2 ./backup.sh
./backup.sh
# uninstall
vi2 ./uninstall.sh
!!! ./uninstall.sh





%%% {submenu_sys}webd ftpd smtpd popd [dmi]
%%%e {submenu_sys}webd ftpd smtpd popd [dmi]
# apache2
yyay apache2
vi2 /etc/apache2/apache2.conf
explorer /etc/apache2
a2enmod varModule__rewrite
systemctl $( echo restart start stop status | pipemenu ) apache2
# nginx
yyay nginx
vi2 /etc/nginx/nginx.conf
explorer /etc/nginx
systemctl $( echo restart start stop status | pipemenu ) nginx
# ftpd proftpd
yyay proftpd
explorer /etc/proftpd
systemctl $( echo restart start stop status | pipemenu ) proftpd.socket
# ftpd vsftpd
yyay vsftpd
vi2 /etc/vsftpd.conf
systemctl $( echo restart start stop status | pipemenu ) vsftpd
# maild smtp sendmail (sendmail.mc Addr 127.0.0.1 -> 0.0.0.0)
yyay sendmail sendmail-cf
vi2 /etc/mail/sendmail.mc /Addr 
m4 /etc/mail/sendmail.mc > /etc/mail/sendmail.cf
explorer /etc/mail/
systemctl $( echo restart start stop status | pipemenu ) sendmail
# maild smtp postfix
yyay postfix mailutils libsasl2-2 ca-certificates libsasl2-modules
vi2 /etc/postfix/main.cf 
postconf compatibility_level=3.6
explorer /etc/postfix/
systemctl $( echo restart start stop status | pipemenu ) postfix 
# mail login auth sasl add
# https://93it-serverengineer.co.kr/57
vi2 /etc/sasl2/Sendmail.conf
echo "pwcheck_method: saslauthd" > /etc/sasl2/Sendmail.conf
systemctl enable --now saslauthd
# maild pop imap & clients & tools
yyay dovecot-imapd dovecot-pop3d || yyay dovecot
yyay sendemail mailx ed
vi2 /etc/dovecot/dovecot.conf
explorer /etc/dovecot/
systemctl $( echo restart start stop status | pipemenu ) dovecot
# 서버의 mail command -> gmail smtp 사용 메일발송 (postfix)
# Google 계정관리 - 보안 - 2단게 인증 - 앱 비밀번호 생성
rbackup /etc/postfix/sasl_passwd ; echo "smtp.gmail.com varGmailadd:varGmailAppPW" > /etc/postfix/sasl_passwd
postmap hash:/etc/postfix/sasl_passwd ; chmod 600 /etc/postfix/sasl_passwd
!!! template_copy postfix.yml /etc/postfix/main.cf ; cat /etc/postfix/main.cf
echo "/From:.*/ REPLACE From: varName <varGmailadd>" >> /etc/postfix/header_check
vi2 /etc/postfix/header_check
echo "smtp_header_checks = regexp:/etc/postfix/header_check" >> /etc/postfix/main.cf
postfix reload
# test
pstree | mail -s "pstree $(hostname)" varGmailadd


%%% {submenu_com}nfs server / client [nfs]
%%%e {submenu_com}nfs server / client [nfs]
%% echo "nfsdir: $nfsdir"
# install
yy nfs-utils rpcbind
ay nfs-kernel-server nfs-common
# share dir create 
export nfsdir="varShareDir__@@nfs.share"
mkdir -p $nfsdir && chmod 777 $nfsdir && touch $nfsdir/.nfs.share.$localip1 ; ls -al $nfsdir
explorer $nfsdir
# nfs 서버에 접근을 허용할 IP 대역 지정 
# remoteip ex) 192.168.0.1 or 192.168.0.1/24 or 192.168.0.1/16 or *
# 접근권한 ex) no_root_squash / root_squash / no_all_squash / all_squash
echo "localip: $localip" ;; echo "$nfsdir varRemoteIP(rw,sync,no_root_squash)" >> /etc/exports && vi2 /etc/exports
echo "localip: $localip" ;; echo "$nfsdir varRemoteIP(rw,sync,no_root_squash) varRemoteIP2(rw,sync,no_root_squash)" >> /etc/exports && vi2 /etc/exports
vi2 /etc/exports
# firewall port open 111,2049,20048,32769(tcp/udp) nfs/mountd/rpc-bind
# 
systemctl enable --now nfs-server ; systemctl status nfs-server
!!! systemctl disable --now nfs-server ; systemctl status nfs-server
systemctl status nfs-server
# apply
exportfs -ra
exportfs -v
showmount -e 
#
vi2 $( ls -1 /etc/fstab /etc/idmapd.conf /etc/sysconfig/nfs /etc/nfs.conf 2>/dev/null | pipemenu1 ) 
# ###########################################
# client - nfs mount && fstab add
# ###########################################
mkdir -p varLocalDIR__@@mnt@@nfs.mount ; mount -t nfs -o nolock varNfsRhost:varShareDir__@@nfs.share varLocalDIR ; df -h
df | hl -h ;; cd varLocalDIR ; ls -al ;
explorer varLocalDIR
# nfs fstab add
echo "varNfsRhost:varShareDir varLocalDIR nfs nolock,_netdev 0 0" >> /etc/fstab && cat /etc/fstab | cgrep1 nfs varNfsRhost






%%% {submenu_com}autofs - Auto Mount NFS [afs]
%%%e {submenu_com}autofs - Auto Mount NFS [afs]
# nfs clinet - auto nfs mount
# 필요할 때 자동으로 마운트하고, 일정 시간 사용하지 않으면 자동 언마운트
yyay autofs
# 직접맵 방식
echo "/-    /etc/auto.direct    --timeout=60" >> /etc/auto.master ;; cat /etc/auto.master
vi2 /etc/auto.master
# 실제 마운트 정보
echo "varLocalDIR__@@mnt@@nfs.mount -fstype=nfs,rw,hard,_netdev,timeo=15,retrans=3  varNfsRhost:varShareDir" >> /etc/auto.mount ;; cat /etc/auto.mount | cgrep1 varNfsRhost
vi2 /etc/auto.mount
systemctl enable --now autofs ;; systemctl status autofs
systemctl status autofs
df ; echo ; cd varLocalDIR__@@mnt@@nfs.mount ; ls -al 
# fstab 에 마운트 설정이 되어 있다면 주석처리 - 이중접근
cat /etc/fstab | cgrep varLocalDIR
hash_add /etc/fstab varLocalDIR
vi2 /etc/fstab




%%% {submenu_com}samba server / client [smb]
%%%e {submenu_com}samba server / client [smb]
%% echo "smbdir: $smbdir /  smbuser: $smbuser"
# install
yyay samba
# share dir create ##############################
export smbdir="varShareDir__@@mnt@@usb"
# mount nobody
mount -t varType__exfat__vfat__ntfs-3g /dev/$(lsblk -l -o name,type|grep part| pipemenu1 ) $smbdir -o uid=65534,gid=65534,dmask=0000,fmask=0000
# chmod 
mkdir -p $smbdir && touch $smbdir/.smb.share.$localip1 ; chown -R nobody:nogroup $smbdir ; chmod -R 755 $smbdir ; ls -al $smbdir
# ##############################################
vi2 /etc/samba/smb.conf
# 1. 비밀번호 없이 이용 설정 (로컬환경) 
printf $"[varNmae__usbshare]\n   path = $smbdir\n   browseable = yes\n   writable = yes\n   guest ok = yes\n   force user = nobody\n" >> /etc/samba/smb.conf
# 2. 비밀번호 등록 이용 - 유저숼정  
: useradd and b ; u
export smbuser=$( getent passwd | awk -F: '$3 >= 1000 && $3 < 65534 { print $1 }' | pipemenu )
# 2.1 a.계정추가(비번등록)/e.활성화/d.비활성화/x.삭제
smbpasswd varFlag__-a__-e__-d__-x $smbuser
pdbedit -L -v $smbuser
change /etc/samba/smb.conf "guest ok = yes" "guest ok = no" find usbshare
echo "   valid users = $smbuser" | insert /etc/samba/smb.conf "force user = nobody"
# restart
systemctl restart smbd
ufw allow 'Samba'
explorer $smbdir



: ubu/debian ; systemctl enable --now iscsid ; systemctl status iscsid



%%% {submenu_com}iscsi server [iss]
%%%e {submenu_com}iscsi server [iss]
%% echo "iqn:$iqn  ciqn:$ciqn"
# nfs (파일수준공유,로컬파일) vs iscsi (블록수준공유,로컬디스크)
# server (iscsi target)
yy targetcli || ay targetcli-fb 
: centos ; systemctl enable --now target ; systemctl status target
: ubu/debian ; systemctl enable --now targetclid ; systemctl status targetclid
export sharedir="varSHARE__@@iscsi_share" ; mkdir -p $sharedir
export diskname="varDiskName__idisk1"
targetcli
# Create a file to be used as a backstore
targetcli /backstores/fileio create $diskname $sharedir/$diskname varSIZE__10G ;ls -alh $sharedir
# Create an iSCSI target
targetcli /iscsi create 
#
# iscsi 경로를 마음속에 저장 
targetcli ls /iscsi
#
export iqn=$(targetcli ls /iscsi | grep "iqn." | awk '{print $2}' | head -n1 ) ; echo $iqn
export iqn=$(targetcli ls /iscsi | grep "iqn." | awk '{print $2}' | tail -n1 ) ; echo $iqn
targetcli ls /iscsi ;; export iqn=varIQN
# unused iqn delete 
!!! targetcli /iscsi delete $iqn
# set LUN - Link the backstore to the target as LUN 0 and add network portal
targetcli /iscsi/$iqn/tpg1/luns create /backstores/fileio/$diskname
# set ACL - Add ACL for a specific initiator
# iscsi initiator iqn ( client side /etc/iscsi/initiatorname.iscsi copy & paste )
export ciqn=varClientIQN
targetcli /iscsi/$iqn/tpg1/acls create $ciqn
!!! targetcli /iscsi/$iqn/tpg1/acls delete $ciqn
# acl 
targetcli /iscsi/$iqn/tpg1/acls/$ciqn set attribute authentication=1
targetcli /iscsi/$iqn/tpg1/acls/$ciqn set auth userid=varUsername
targetcli /iscsi/$iqn/tpg1/acls/$ciqn set auth password=varPassword
!!! targetcli /iscsi/$iqn/tpg1/acls/$ciqn delete auth userid
!!! targetcli /iscsi/$iqn/tpg1/acls/$ciqn delete auth password
targetcli saveconfig
systemctl restart targetclid || systemctl restart target
systemctl disable --now targetclid || systemctl disable --now target
echo "$publicip $localip" | cip




%%% {submenu_com}iscsi client [isc]
%%%e {submenu_com}iscsi client [isc]
%% echo "iqn:$iqn  ciqn:$ciqn"
# iscsi server -> wan 접속 불가 // vpn,lan 접속 가능 
# client (isci initiator)
yyay open-iscsi
systemctl enable --now iscsid ; systemctl status iscsid
# clinetIQN 복사후 serverside acl 인증에 적용 
vi2 /etc/iscsi/initiatorname.iscsi
export ciqn=$( cat /etc/iscsi/initiatorname.iscsi | awk -F'=' '/InitiatorName/ && $2 != "" {print $2}')
# id/pw 설정후 재시작
echo -e "node.session.auth.authmethod = CHAP\nnode.session.auth.username = varUsername\nnode.session.auth.password = varPassword" >> /etc/iscsi/iscsid.conf
vi2 /etc/iscsi/iscsid.conf ; chmod 600 /etc/iscsi/iscsid.conf
systemctl restart iscsid ; systemctl status iscsid
# connect
iscsiadm -m discovery -t sendtargets -p varServerIP 
iscsiadm -m node -l ; echo ; iscsiadm -m session
iscsiadm -m session 
# status
lsblk ;echo; lsscsi || { yyay lsscsi ; lsscsi ; }
fdisk -l ;; fdisk varDEVICE 
#
# session logout
iscsiadm -m node -T $(iscsiadm -m session | awk '{print $4}')  -u
# node del
iscsiadm -m node --logout ; iscsiadm -m node --op delete ; systemctl restart iscsid 
# reset
systemctl disable --now iscsid || systemctl disable --now target
explorer $( echo /etc/iscsi /var/lib/iscsi|pipemenu )





%%% {submenu_com}find query [find]
%%%e {submenu_com}find query [find]
# 폴더에서 검색문자열 탐색
for i in $( grep "varFind" varPath__@@etc/* -rlF 2>/dev/null ) ; do echo -n "$i " ;dline 40 ; grep "varFind" $i ; echo ; done | cgrep varFind |less -RX
# 이진 파일을 제외하고 탐색 
find varPath__@@etc -type f ! -iregex '.*\.\(jpg\|png\|gif\|pdf\|bin\|zip\|gz\|bz2\|tgz\|zst\|exe\|mp3\|mp4|sql\)$' | while read -r i; do if file -b "$i" | grep -q 'text' && grep -q "varFind" "$i"; then echo -n "$i "; dline 40; grep "varFind" "$i"; echo; fi; done | cgrep varFind | less -RX
# perm 000 폴더 find 
find varPath/ -maxdepth 1 -type d -perm 000
# 하루내 수정된 파일을 찾기 /home 폴더안에 계정별 작업이 필요할때 
for i in $( cd varPath__@@home1; ls -al |grep ^d |awk '{print $NF}' ); do find varPath/$i -mtime -1 -type f; done 
# 하루내 수정된 파일이 있는 계정 찾기
for i in $( find varPath__@@home1 -maxdepth 1 -mindepth 1 -type d ); do if find $i -mtime -1 -type f -print -quit | grep -q .; then echo $i; fi; done
# 특정파일(백업파일)이 생성된 이후 생성된 파일 찾기
find varPath -newer varFile
# 특정시점 이후 생성된 파일 찾기
touch -t varMT__202504051200 .ref_time ;; find varPath -newer .ref_time ;; rm -f .ref_time
# 특정단어포함 파일 삭제 *thumb*
!!! find varPath -type f -name "*varFind__thumb*" -maxdepth 1 -size 0 -exec rm -f {} \;
# expired account Lock // 특정폴더로 이동된 계정폴더를 기준 
!!! for i in $(/bin/ls -l varPath__@@home1@@expire |awk '{print $NF}'); do passwd -l ${i%/} ; done
# 삭제된 계정 정리 // deleted account homedir cleaning
!!! cd varPath && rm -rf `ls -al|awk '$3 ~ /^[0-9]/ {print $NF} '`
# 소유자가 없는 파일/디렉터리 찾기 (deleted user/group)
find varPATH -nouser -o -nogroup
# 빈파일 빈폴더 탐색
pwd ;; find "varPath__@dot@/" \( -type f -empty -o -type d -empty \) -exec ls -ld {} \;
# 빈파일/폴더 삭제 
pwd ;; find varPath__@dot@/ -type f -empty -delete ; find varPath -type d -empty -delete
# 지정 크기 이상이며 N일 내 수정된 파일 찾기
find varPATH -type f -size +varSize__100M -mtime -varMTime__3
# 최근 N분 내 실행 가능한 파일 찾기
find varPATH -type f -executable -mmin -varMin__10
# 특정 사용자 소유 파일 찾기
find varPATH -user varUSER__www-data
# 특정 확장자(bak) 파일 찾기
find varPATH -type f -iregex '.*\.\(varEXT__bak\)$'
# 이름에 공백 또는 특수문자 포함된 파일 찾기
find varPATH -type f \( -name "* *" -o -name "*[!A-Za-z0-9._/-]*" \)
# 특정 파일 생성 이후 생성된 파일 찾기
find varPATH -newer varFILE
# 특정 시각 이후 생성된 파일 찾기
touch -t varMT__202504131200 .ref_time ;; find varPATH -newer .ref_time ;; rm -f .ref_time




%%% {submenu_com}mysql query [mysql]
%%%e {submenu_com}mysql query [mysql]
mysqlshow
vi2 $( find /etc/mysql/ -type f |pipemenu ) 
explorer /var/lib/mysql/
# mysql connect 
mysql varDBNAME
mysql $( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1)
# mysql process monitoring
while true;do echo;date;cat /proc/loadavg;mysqladmin processlist|egrep -v "Sleep|DELAYED";read -p "exit -> [Anykey] " -s -n1 -t1 key;[ "$key" ] && break;sleep 1 ;done
mysqladmin processlist|grep -v "Sleep"
# table query
mysql varDBNAME -e 'show tables;'
mysql varDBNAME -e 'varCMD ;'
mysql $( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1) -e 'varCMD ;'
# table check - myisamchk & flush tables
export db=$( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1) ; export table="$( mysql $db -Be 'show tables;' |pipemenu1 )" ;; myisamchk -r /var/lib/mysql/$db/$table ; mysql $db -e 'flush tables;' ; unset db table
# db size monitor
cd /var/lib/mysql/ && ls -al
cd /var/lib/mysql/ && find ./ -size +100000k -exec ls -alh {} \; 
cd /var/lib/mysql/ && find ./ -size +20000k -exec ls -alh {} \; 
cd /var/lib/mysql/ && find ./ -size +20000k -mtime -1 -exec ls -alh {} \; 
# dump
mysqldump -Q varDBNAME > /root/varDBNAME.$(datetag1).sql ; ls -alh /root/varDBNAME.$(datetag1).sql
dbname=$( mysql -Be "show databases;"  | awk 'NR>1' | pipemenu1 ) ; mysqldump -Q $dbname > /root/$dbname.$(datetag1).sql ; ls -alh /root/$dbname.$(datetag1).sql
# dbs all dump
mkdir -p /varBackupDIR__@@backup@@mysqldump/ ; chmod 700 /varBackupDIR/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1 && $1 !~ /^(information_schema|performance_schema|sys|mysql)$/'); do echo "$i DB dumping..." ;    mysqldump --single-transaction -Q "$i" | gzip > /varBackupDIR/${i}.$(datetag1).sql.gz ; done
# root
mysql -uroot -p mysql
mysql mysql
!!! mysql -e "grant all privileges on *.* to root@localhost identified by 'varPassword';"
!!! mysql -e "drop database varDBNAME;"
!!! mysql -e "DROP DATABASE IF EXISTS varID; DROP USER IF EXISTS 'varID'@'localhost';"

# perm
chmod 660 /var/lib/mysql/mysql/*
chown mysql.mysql /var/lib/mysql/
chown mysql.root /var/lib/mysql/mysql
chmod 755 /var/lib/mysql
chmod 711 /var/lib/mysql/mysql
yyay mysql || yyay mariadb-server




%%% {submenu_com}fail2ban [ban]
%%%e {submenu_com}fail2ban [ban]
%% systemctl status fail2ban 2>/dev/null
# fail2ban install
yyay fail2ban
explorer /etc/fail2ban
# conf cp
cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
vi2 /etc/fail2ban/jail.local
systemctl reload fail2ban
# 
systemctl start fail2ban ; sleep 1 ; systemctl status fail2ban
systemctl enable fail2ban
systemctl stop fail2ban ; sleep 1 ; systemctl status fail2ban
systemctl disable fail2ban
#
systemctl status fail2ban
fail2ban-client status
fail2ban-client status sshd | cip
# 
iptables-save | grep f2b | cip
# ipban (manual)
fail2ban-client set sshd banip varIP
fail2ban-client set sshd unbanip varIP
# unban
fail2ban-client unban --all
fail2ban-client unban varIP
# log
tail -f /var/log/fail2ban.log 
tail -f /var/log/auth.log 
tail -f /var/log/syslog 
vi /var/log/fail2ban.log
# not syslog or auth.log ( ex. proxmox )
ls -al /var/log | egrep "syslog|auth.log" 
yyay rsyslog




%%% {submenu_com}wondershaper limit net-bandwidth [band]
%%%e {submenu_com}wondershaper limit net-bandwidth [band]
%% echo "eth: $eth // ethpath: $ethpath"
# 네트워크 대역폭 제한 
# 업/다운로드로 대역폭을 풀로 다 쓰는걸 방지
git clone https://github.com/magnific0/wondershaper.git
cd wondershaper ; make ; make install
ethtool $( ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | pipemenu ) | cgrepl "Speed:"
route
wondershaper 
# eth select ex) eth0 ens01 // psysical device
export eth=$( ip -br a | awk '$2 ~ /UP/ {print $1}' | pipemenu ) ;; echo "eth: $eth"
# limit status
ethtool $eth | cgrepl Speed ;; wondershaper -s -a $eth | cgrep1 pfifo_fast | cgrep htb
: tc show  ; tc -s qdisc show dev $eth
: tc reset ; tc qdisc del dev $eth root
# reset && limit set down speed ( kbps )
: reset ;  wondershaper -c -a $eth
: 500mbps; wondershaper -c -a $eth ; wondershaper -a $eth -d 500000
: 100mbps; wondershaper -c -a $eth ; wondershaper -a $eth -d 100000
: 70mbps ; wondershaper -c -a $eth ; wondershaper -a $eth -d 70000
: 50mbps ; wondershaper -c -a $eth ; wondershaper -a $eth -d 50000
: 30bmps ; wondershaper -c -a $eth ; wondershaper -a $eth -d 30000
# iface -> iprange check
for nic in $( basename -a /sys/class/net/e* ) ; do echo -n "$nic " ; ip -br a s $( basename $( readlink -f  /sys/class/net/$nic/master/))|awk '{print $3}' ; done
# kbps -> mbps // down(RX) && up(TX) speed set 
eth=$( basename -a /sys/class/net/e* | pipemenu ) ;; wondershaper -c -a $eth ; wondershaper -a $eth -d $(( varDownMbps__40__50__60__70__80__100 * 1024 )) -u $(( varUpMbps__40__50__60__70__80__100 * 1024 ))
# speedtest
: monitor ;  bmon -p "$( basename -a /sys/class/net/e* | paste -sd ',' )" || ay bmon
yyay speedtest-cli
speedtest-cli
( trap 'rm -f testfile.iso ; return' INT ; wget -O testfile.iso https://ftp.kaist.ac.kr/ubuntu-cd/noble/ubuntu-24.04.2-desktop-amd64.iso ; trap - INT ; ) ;; rm -f testfile.iso 
iftop 
# 50% 80% 100% down speed set 
ethpath="$( ls -d /sys/class/net/e* | pipemenu )/speed" ;; cat $ethpath
: speed 50% ; wondershaper -c -a $eth ; wondershaper -a $eth -d $(( $(cat $ethpath) * 1000 * 50 / 100 ))
: speed 80% ; wondershaper -c -a $eth ; wondershaper -a $eth -d $(( $(cat $ethpath) * 1000 * 80 / 100 ))
: speed 100%; wondershaper -c -a $eth ; wondershaper -a $eth -d $(( $(cat $ethpath) * 1000 * 100 / 100 ))




%%% {submenu_com}arp ip scan [nn]
%%%e {submenu_com}arp ip scan [nn]
%% route -n
# 네트워크 (ex. vmbr0 에 할당된 네트워크 대역) 전체를 스캔
# 대역중 사용중인 아이피 체크 
route -n | cip
route -n ;; arp-scan -I varInterFace__vmbr0 -l | hostinfo | cip
route -n ;; arp-scan -I $( route -n|awk99 |awknr3|sort|pipemenu ) -l | hostinfo | cip | cgrep Cisco | cgrep1 Unknown
arp
arp -n
# arp + arp -n (mac 정렬후 합침)
awk 'NR==FNR {mac[$3] = $1; next} $3 in mac {print mac[$3], $1, $3, $5}' <(arp) <(arp -n)|column -t
arp-scan -I vmbr0 -l | awk '$1 ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/ {print $0}'
arp-scan -I $( basename -a /sys/class/net/* | pipemenu ) -l | awk '$1 ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/ {print $0}'
# arp-scan 결과 arp cache 에 추가
dev=$(ip r | awk '/default/ {print $5}'); arp-scan -I "$dev" --localnet | awk -v dev="$dev" '/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+[ \t]+([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}/ {print "ip neigh replace "$1" lladdr "$2" dev "dev}' | bash
# nmap 
nmap $( arp-scan -I $( basename -a /sys/class/net/* | pipemenu ) -l | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | pipemenu ) 
# fping -asg 192.168.0.128/25
route -n ;; fping -asg varIPrange
# reverse dokmain 
# 메일서버 운영을 위해서는 상위아이피 관리 기관에 ptr 레코드 등록 요청
# 메일서버의 ip에 ptr 도메인이 없다 -> 스팸 처리
dig -x varIP__publicip
dig -x varIP__publicip @127.0.0.1
dig -x varIP__publicip @8.8.8.8
dig -x varIP__publicip @168.126.63.1
dig +trace varDom
dig @8.8.8.8 varDom +noanswer +ttlid
dig @8.8.8.8 varDom +ttlunits
#
nslookup varIP
host varIP
getent hosts varIP
# resolve.conf edit ban
ls -al /etc/resolv.conf ;; realpath /etc/resolv.conf
!!! cp --dereference /etc/resolv.conf /tmp/resolv.conf.backup && unlink /etc/resolv.conf && mv /tmp/resolv.conf.backup /etc/resolv.conf 
vi2 /etc/resolv.conf
chattr +i /etc/resolv.conf
chattr -i /etc/resolv.conf
#
yyay varPKG__arp-scan__nmap__fping


%%% {submenu_com}dig / nslookup [dig]
%%%e {submenu_com}dig / nslookup [dig]
# query
dig varDom
dig varDom @8.8.8.8
dig varDom @168.126.63.1
dig varDom @varNameDom
nslookup varDom
nslookup varDom 8.8.8.8
nslookup varDom 168.126.63.1
nslookup varDom varNameDom
# dns 서버 해외/국내 varDom query
for x in "8.8.8.8:Google" "1.1.1.1:Cloudflare" "168.126.63.1:KT" "210.220.163.82:SK" "164.124.101.2:LGU+"; do ip=${x%%:*}; tag=${x##*:}; echo -n "$ip ($tag) "; dig varDom @$ip +short ; done | column -t
dig varDom MX 
dig varDom TXT 
dig varDom NS 
dig varDom +noall +answer +ttlid @8.8.8.8
dig varDom +ttlunits
dig varDom +trace
# reverse domain 
dig -x varIP__168.126.63.1 +short
nslookup varIP
: jump to resolv.conf set ; resolv
: jump to net set ; n
: jumt to net set arp ; nn

%%% {submenu_com}resolve.conf dns query [resolv]
%%%e {submenu_com}resolve.conf dns query [resolve]
# 현재 /etc/resolv.conf 상태 확인 (링크 여부, 대상 경로)
ls -al /etc/resolv.conf ;; realpath /etc/resolv.conf ;; file /etc/resolv.conf
# 현재 내용 보기
cat /etc/resolv.conf | cgrepn nameserver search 2
vi2 /etc/resolv.conf
# nameserver 1.1.1.1
# nameserver 8.8.8.8
# search example.com sub.example.net # ping abc -> abc.example.com 
# options edns0 trust-ad
# options rotate    : 여러 nameserver 순환 사용
# options timeout:n : 응답 대기 시간 (초)
# options attempts:n: 재시도 횟수
#
# ##################################### resolv.conf 수정 방어 (immutable 설정)
# ### 링크가 아닌 일반 파일로 교체 후 보호
cp --dereference /etc/resolv.conf /tmp/resolv.conf.backup
unlink /etc/resolv.conf
mv /tmp/resolv.conf.backup /etc/resolv.conf
vi2 /etc/resolv.conf
chattr +i /etc/resolv.conf
# 보호 해제
chattr -i /etc/resolv.conf
# #################################### 수정 주체 (자동으로 덮어쓰는 놈들)
# ### systemd-resolved 확인 및 제어 # → ../run/systemd/resolve/stub-resolv.conf 인 경우
systemctl status systemd-resolved
systemctl disable --now systemd-resolved
#
# ### NetworkManager 확인 및 제어
systemctl status NetworkManager
cat /etc/NetworkManager/NetworkManager.conf | cgrep dns main
# NetworkManager가 덮어쓰지 않도록 설정
# [main]
# dns=none
#
# ### dhclient (DHCP 클라이언트) 설정
cat /etc/dhcp/dhclient.conf | cgrep supersede
# 예시: DNS 서버 수동 지정
# supersede domain-name-servers 1.1.1.1, 8.8.8.8;
#
# ### netplan 사용 시
cat /etc/netplan/*.yaml
netplan apply






%%% {submenu_com}sgdisk / fdisk [sgdisk]
%%%e {submenu_com}sgdisk / fdisk [sgdisk]
%% echo -n "HDD: " ; lsblk -d -n -o name | oneline
# fdisk: MBR (Master Boot Record) 
# sgdisk: GPT (GUID Partition Table)
sgdisk -p /dev/$( lsblk -d -n -o name | pipemenu )
fdisk -l /dev/$( lsblk -d -n -o name | pipemenu )
# net gpt
# !!! sgdisk -o /dev/sdb 
# new part ex) sgdisk -n=파티션번호:시작섹터:종료섹터 /dev/sdb
# !!! sgdisk -n=1:0:+10G /dev/sdb
# del part 
# !!! sgdisk -d=1 /dev/sdb
# chg type code / type list
# !!! sgdisk -t=1:EF00 /dev/sdb
sgdisk -L
# backup part table
# !!! sgdisk -b=backup.gpt /dev/sdb
# zap reset disk
# !!! sgdisk -z /dev/sdb
# load backup 
# !!! sgdisk -l=backup.gpt /dev/sdb
# sample 
!!! sgdisk -o /dev/sdx  # /dev/sdb 디스크를 GPT로 초기화
!!! sgdisk -n=1:0:+500M -t=1:EF00 -c=1:"EFI System Partition" /dev/sdx # 1번 파티션 (EFI) 생성
!!! sgdisk -n=2:0:+16G -t=2:8200 -c=2:"Swap" /dev/sdx # 2번 파티션 (Swap) 생성
!!! sgdisk -n=3:0:0 -t=3:8300 -c=3:"Root Filesystem" /dev/sdx # 3번 파티션 (Root) 생성 (남은 공간 모두 사용)
!!! sgdisk /dev/sdx # 명령줄 내용 반영 
# kernel probe part load
!!! partprobe /dev/sdx




%%% {submenu_com}swap [swap]
%%%e {submenu_com}swap [swap]
%% swapon --show 2>/dev/null || swapon -s
# 
free -h
cat /proc/swaps
swapon --show 2>/dev/null || swapon -s
vmstat 1
# on
df -h ;; dd if=/dev/zero of=varSwapPath__@@backup@@extra_swap bs=1M count=varSIZe__2048 ; chmod 600 varSwapPath
mkswap varSwapPath 
swapon varSwapPath ; swapon -s
# off
swapoff varSwapPath ; swapon -s
rm -f varSwapPath
# write
echo "varSwapPath none swap sw 0 0" >> /etc/fstab
vi2 /etc/fstab
vi2 /etc/sysctl.conf
sysctl -p
# 스왑 사용 빈도수 - 숫자 작을수록 적게 사용 (기본 60)
cat /proc/sys/vm/swappiness
sysctl vm.swappiness=varHIT__10
#
# swap {1,2,4,8}G on / off
df ; free ; echo ; cat /proc/swaps ;; size=$( echo 1024000 2048000 4096000 8192000 | pipemenu ) ;; dd if=/dev/zero bs=1024 count=$size | { pv -s ${size}k || cat ; } > varSwapPath__@@backup@@extra_swap ; mkswap varSwapPath $size ; swapon varSwapPath ; chmod 600 varSwapPath ; free ; echo ; cat /proc/swaps
# swap on -> rc.local service add
cat /proc/swaps ;; [ -f /etc/rc.local ] && echo "[ -f varSwapPath__@@backup@@extra_swap ] && swapon varSwapPath" >> /etc/rc.local && vi2 /etc/rc.local
# swap off 
free ; echo ; cat /proc/swaps ;; swapoff varSwapPath__@@backup@@extra_swap && rm -rf varSwapPath ; free ; echo ; cat /proc/swaps







%%% {submenu_com}at / cron [at]
%%%e {submenu_com}at / cron [at]
# at 확인 -> atqq func 
declare -f atqq
atqq | stripe
# at 삭제
atqq|stripe ;; atrm $( atq |while read -r l;do echo $l|awk1; done | pipemenu )
# at 모두 삭제
atqq|stripe ;; atrm $( atq |while read -r l;do echo -n $l|awk1; done )
# at 설정 
# echo "varCMD" | at 15:30
echo "varCMD" | at varTIME
# echo "varCMD" | at 15:00 this Sat
# echo "varCMD" | at 10:00 next week + Fri
# echo "varCMD" | at 16:15 2025-08-03
echo "varCMD" | at varTIME varDATE
# echo "varCMD" | at now + 2h 30m
# echo "varCMD" | at now + 3d 14:05
# echo "varCMD" | at now + 2w 16:00
echo "varCMD" | at now + varDATETIME 
# 이달말 
echo "varCMD" | at varTIME $(date -d "$(date '+%Y-%m-01') 1 month -1 day" '+%Y-%m-%d')
#
# cron -> [0-9] * / - , 를 이용하여 표현, %는 줄바꿈 특수키
# min(0-59) hour(0-23) day(1-31) month(1-12) weekand(0-7) user command
# */5 * * * * root /script/per5min.sh 5분마다 실행
# 0 0 * * 0 root /script/sunday0hour.sh 일요일 자정에 실행
#
# 30 20-22/2 * * * root /script/am10pm10.sh 10~22시까지 2시간 마다 실행
echo $(date -d "$(date +'%Y-%m-01') 1 month -1 day" '+%m-%d')
echo $(date -d "$(date +'%Y-%m-01') 1 month -2 day" '+%m-%d')
echo $(date -d "$(date +'%Y-%m-01') 2 month -1 day" '+%m-%d')
# 이달의 마지막날 10시 실행되는 스크립트 
# 0 10 27-31 * * root [ "$(date '+\%d' -d tomorrow)" == 01 ] && /script/specialday.sh 말일에 실행
echo "varMin varHour varDay varMonth varWeekand varUser__root varComPath" >> /etc/crontab ; vi2 /etc/crontab
# /root /etc 폴더 증분백업 (최저부하) / 백업본 (7*24)
echo "varMin varHour varDay varMonth varWeekand varUser__root MY_DATE=\$(date +\%w\%H) && nice -n 19 ionice -c2 -n7 rsync -ar --backup --suffix=\".bak_\$MY_DATE\" varSource__@@root varSource2__@@etc varBackupDIR__@@backup@@" >> /etc/crontab ; vi2 /etc/crontab
vi2 /etc/crontab
cal || yyay ncal




%%% {submenu_com}vim 설정 / vi alias [vi]
%%%e {submenu_com}vim setting / vi alias [vi]
# default editor set
echo $EDITOR ; echo $VISUAL
echo -e "export EDITOR=vim\nexport VISUAL=vim" >> ~/.bashrc && source ~/.bashrc # vim
echo -e "export EDITOR=nano\nexport VISUAL=nano" >> ~/.bashrc && source ~/.bashrc # nano
# .vimrc scp
scp varHost:~/.vimrc ~/.vimrc
# vimrc template copy
vi3 ~/.vimrc /root/.bashrc
template_edit vimrc1.yml
template_view vimrc1.yml
!!! template_copy vimrc1.yml ~/.vimrc ; vi2 ~/.vimrc
template_edit vimrc2.yml
template_view vimrc2.yml
!!! template_copy vimrc2.yml ~/.vimrc ; vi2 ~/.vimrc
# vim 에서 folding 제거 zo zf 
rbackup ~/.vimrc ; perl -pi -e 's|^set foldmethod=marker|" set foldmethod=marker|g' ~/.vimrc
rbackup ~/.vimrc ; echo "set nofoldenable" >> ~/.vimrc
# 비주얼 모드 off (mouse off)
rbackup ~/.vimrc ; echo "set mouse-=a" >> ~/.vimrc ; 
# 알록달록이
[ ! "$(grep "syntax" ~/.vimrc)" ] && echo -e "syntax on\ncolorscheme default\n" >> ~/.vimrc ; 
# backup file ~/.vim/backup/file.bak
echo -e "set backup\nset backupdir=~/.vim/backup\n" >> ~/.vimrc ; mkdir -p $HOME/.vim/backup
# backup infinite ~/.vim/backup/filename/file_timestamp.bak
printf $'" 단순 백업 설정 - 파일명_날짜시간.bak 형식\nfunction! MakeBackup()\n  " 기본 백업 디렉토리 확인 및 생성\n  let l:backupdir = $HOME."/.vim/backup"\n  if !isdirectory(l:backupdir)\n    call mkdir(l:backupdir, "p")\n endif\n  \n  " 파일명과 타임스탬프를 결합한 백업 파일명 생성\n  let l:filename = expand("%%:t")\n  let l:timestamp = strftime("%%Y%%m%%d_%%H%%M%%S")\n  let l:backupfile = l:backupdir."/".l:filename."_".l:timestamp.".bak"\n \n  " 백업 파일 생성\n  execute "silent !cp " . shellescape(expand("%%:p")) . " " . shellescape(l:backupfile)\nendfunction\n\nautocmd BufWritePre * call MakeBackup()\n' >> ~/.vimrc
# permanant undo
printf $'if v:version >= 703\n  let undodir=$HOME."/.vim/undo"\n  if !isdirectory(undodir)\n    call mkdir(undodir, "p")\n  endif\n  set undofile\n  set undodir=$HOME/.vim/undo\n  set undolevels=1000\n  set undoreload=10000\nendif\n' >> ~/.vimrc
# 한글 encoding
echo "set fileencodings=utf8,euc-kr" >> ~/.vimrc
# 마우스 붙여 넣기 들여쓰기 방지 && f2 토글 
echo "set paste" >> ~/.vimrc
echo "set pastetoggle=<F2>" >> ~/.vimrc
# vim 종료시 vi 편집 내용 화면 그대로 남게 하기 
echo "set t_ti= t_te=" >> ~/.vimrc
# vi vim alias 
[ ! "$(grep " vi=" /root/.bashrc)" ] && echo "alias vi='vim'" >> /root/.bashrc
#
vi2 ~/.vimrc
vim -c "source ~/.vimrc" -c "q"
ls -ltr ~/.vim/backup |tail -n10
explorer ~/.vim/backup



%%% {submenu_com}markdown viewer glow [glow]
%%%e {submenu_com}markdown viewer glow [glow]
# glow 
: install ; mkdir -p /etc/apt/keyrings && curl -fsSL https://repo.charm.sh/apt/gpg.key | gpg --dearmor -o /etc/apt/keyrings/charm.gpg && echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | tee /etc/apt/sources.list.d/charm.list && apt update && apt install glow
: glow ;f=$( find ~/ -name '*.md' | pipemenu ) ; [ -f $f ] && glow $f --pager
: glow web; glow https://raw.githubusercontent.com/charmbracelet/glow/master/README.md -p
glow --help
# bat
: bat ; f=$( find ~/ -name '*.md' | pipemenu ) ; [ -f $f ] && batcat $f 
[ ! -e /usr/bin/bat ] && ln -s /usr/bin/batcat /usr/bin/bat


%%% {submenu_hidden}rc.local service add [rc]
%%%e {submenu_hidden}rc.local service add [rc]
# 등록 서비스 체크
find /etc/systemd/system/ -name rc-local.service -exec echo {} \; -exec sh -c 'read x' \; -exec vi {} \;
systemctl list-unit-files --type=service | grep rc-local
systemctl cat rc-local.service
# 서비스 등록 #!/bin/bash 로 시작
echo "#!/bin/bash" >> /etc/rc.local
vi2 /etc/rc.local ; chmod +x /etc/rc.local ; 
# 
[ ! -f /etc/systemd/system/rc-local.service ] && touch /etc/systemd/system/rc-local.service
echo -e "[Unit]\nDescription=/etc/rc.local Compatibility\nDocumentation=man:systemd-rc-local-generator(8)\nConditionFileIsExecutable=/etc/rc.local\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=5min\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target" | tee /etc/systemd/system/rc-local.service ; vi2 /etc/systemd/system/rc-local.service
#
vi2 /etc/systemd/system/rc-local.service
#
systemctl enable --now rc-local.service ;;  systemctl status rc-local.service
systemctl restart rc-local.service ;; systemctl status rc-local.service
systemctl status rc-local.service
bash /etc/rc.local ; df -h
explorer /etc/systemd/system
#




%%% ssh connect / id_rsa [s]
%%%e ssh connect / id_rsa [s]
ssh varHost -p varPort__22
ssh varHost -p varPort__22 "varCMD" 
assh varHost varID__root "varPW" 
sshpass -p 'varPW' ssh -o StrictHostKeyChecking=no 'varID__root'@varHost 
# ssh // sshd 환경파일 수정 
vi2 $(ls -1 /root/.ssh/config /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /root/.ssh/known_hosts /etc/openssh/sshd_config /etc/ssh/sshd_config 2>/dev/null |pipemenu1)
# 원격지 파일/폴더 select no. scp download
scp -r -P varPort__22 varHost:varRPATH__@@root/$(ssh varHost -p varPort__22 "ls -1 varRPATH__@@root"|pipemenu) varLocalPATH__.
# 개인키 / 공개키 
rbackup /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys 
!!! scp varHost:/root/.ssh/id_rsa.pub /root/.ssh/ 
!!! scp varHost:/root/.ssh/id_rsa /root/.ssh/ 
!!! ssh-keygen -t rsa -b 2048 -f /root/.ssh/id_rsa
# 로컬 공개키 대상 서버에 복사 // 로컬에서 원격지로 키로그인
!!! ssh-copy-id varHost
!!! ssh-copy-id -p varPort__22 -i $( find /root/.ssh -name "*.pub"|pipemenu1) varHost
!!! cat /root/.ssh/id_rsa.pub | ssh varHost "cat >> /root/.ssh/authorized_keys"
# 원격지 공개키 현재 서버에 복사 // 원격지에서 로컬로 키로그인
!!! ssh varHost "cat .ssh/id_rsa.pub" | tee -a /root/.ssh/authorized_keys
# 원격지 공개키 저장소 로컬 동기화 // 원격지 키로그인 가능한 게스트는 이서버도 가능
!!! scp varHost:/root/.ssh/authorized_keys /root/.ssh/ 
#
# old server
ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -oHostKeyAlgorithms=ssh-rsa,ssh-dss varHost
# kex server side
echo -e "KexAlgorithms +diffie-hellman-group1-sha1 \nHostKeyAlgorithms +ssh-rsa,ssh-dss \nPubkeyAcceptedKeyTypes=+ssh-rsa \nPubkeyAcceptedAlgorithms=+ssh-rsa" >> /etc/ssh/sshd_config ; vi2 /etc/ssh/sshd_config
# ssh from utf8-client to euc-kr-server ( encoding chg )
luit -encoding euc-kr ssh varHost || yyay luit
#
ssh -v varHost -p varPort__22
sshd -T |grep rsa 
systemctl restart sshd || systemctl restart ssh 
# client ssh - auto handshake 
sshre varHost
vi2 ~/.ssh/config
#
declare -f sshre 
yyay sshpass expect 




%%% screen [x] / tmux (xx)
%%%e screen [x] / tmux (xx)
%% screen -ls|grep tach
screen -ls
screen -ls ;; screen -S varSname
# multi mode / all -x / -rd (detach & retach)
screen -ls ;; screen -x $( screen -ls |grep tach |pipemenu1 )
screen -ls ;;  for i in $( screen -ls |grep tach |awk1 ) ;do echo $i ; sleep 1 ; screen -x $i ; done
screen -ls ;; screen -rd varSname
# 프로그램이나 스크립트 screen 으로 실행 
screen -dmS $(basename varCommandPATH) sh -c 'varCommandPATH' 
screen -S $(basename varCommandPATH) sh -c 'varCommandPATH;/bin/bash' 
# screen dump
screen -ls ;; screen -S $( screen -ls |grep tach |pipemenu1 ) -X hardcopy -h /root/_screendump && cat /root/_screendump |cpipe|less -RX +G && rm -f /root/_screendump
# screen dump all
for i in $( screen -ls|grep tach|awk '{print $1}' ) ;do echo "$i ===========================" && screen -S $i -X hardcopy -h /root/_screendump && tail -n100 /root/_screendump | cpipe && echo -n "=== end of $i [Enter] " && read x ; done ; rm -rf /root/_screendump 
# screen quit
!!! screen -ls ;; screen -S $( screen -ls |grep tach |pipemenu1 ) -X quit ; screen -ls 
# monitor 
c=('top' 'iftop' 'sh -c "pstree; exec bash"'); s(){ screen "$@"; }; s -dmS m ${c[0]}; for x in "${c[@]:1}"; do s -S m -X screen; s -S m -X stuff "${x}\n"; done; s -r m
# command to screen // & dump 
screen -ls ;; screen -S varSname -X stuff "varCommand$(printf \\\\r)"
screen -ls ;; sno=$( screen -ls |grep tach |pipemenu1 ) ;; screen -S $sno -X stuff "varCommand$(printf \\\\r)" ;; screen -S $sno -X hardcopy -h /root/_screendump && cat /root/_screendump |cpipe && rm -f /root/_screendump
# detach 재접속 all 
for s in $(screen -ls | grep Detached | awk '{print $1}'); do screen -rx "$s" ; done ; screen -ls
# detach 재접속 all - 가장 최근거 먼저 
for s in $(screen -ls | grep Detached | awk '{print $1}' | tac ); do screen -rx "$s" ; done ; screen -ls
# attach / detach 재접속 all
for s in $(screen -ls | grep tached | awk '{print $1}'); do screen -rx "$s" ; done ; screen -ls
# detach 제거
!!! for i in $( screen -ls|grep detach|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ; screen -ls
# attach / detach 모두 제거
!!! for i in $( screen -ls|grep tach|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ; screen -ls
# 검색 문자열 screen 제거
!!! screen -ls ;; for i in $( screen -ls|grep tach|grep varSname|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ;screen -ls




yyay fuse ; [ ! $( which fusermount3) ] && ln -s /usr/bin/fusermount /usr/bin/fusermount3





%%% {submenu_com}teldrive daemon [tel]
%%%e {submenu_com}teldrive daemon [tel]
%% echo "tg-uploads-encryption-key: ${tguploadsencryptionkey}"
%% echo "tg-jwtsecret: ${jwtsecret}"
%% echo "tg-app-id: ${telegramappid}"
%% echo "tg-app-hash: ${telegramapphash}"
%% echo "webport: $webport dbinfo: teldbuser=$teldrive teldbpw=$teldbpw teldbhost=$teldbhost teldbname=$teldbhost"
# telegrem drive docker -> dkt [Enter]
# telegram api app_id, app_hash
# https://my.telegram.org/auth?to=myapp
echo "tguploadsencryptionkey=$(openssl rand -hex 32)" >> ~/go.private.env
echo "jwtsecret=$(openssl rand -hex 32)" >> ~/go.private.env
echo "telegramappid=varAppID" >> ~/go.private.env
echo "telegramapphash=varAppHash" >> ~/go.private.env
source ~/go.private.env
# DB 필요 -> pgsql 직접 설치 psql [Enter]
# or Free BaaS 500M https://supabase.com/database
# /usr/local/bin/teldrive
ay fuse3 ; curl -sSL instl.vercel.app/teldrive | bash ; teldrive version
# user create
groupadd --system teldrive ; useradd --system -g teldrive -s /bin/false -d /var/lib/teldrive teldrive
mkdir -p /var/cache/teldrive && chown -R teldrive:teldrive /var/cache/teldrive 
mkdir /mnt/teldrive && chown teldrive:teldrive /mnt/teldrive
# auth
export webport="varPort__8080" ; export teldbuser="varDBUser__teldrive" ; export teldbpw="varDBpw" ; export teldbhost="varDBHost__localhost" ; export teldbname="varDBName__teldrive"
# exec && trouble check
sudo -u teldrive teldrive run --tg-app-id "$telegramappid" --tg-app-hash "$telegramapphash" --jwt-secret "$jwtsecret" --tg-uploads-encryption-key "$tguploadsencryptionkey" --db-data-source "postgresql://$teldbuser:"$teldbpw"@$teldbhost:5432/$teldbname?sslmode=disable"
# systemd add
template_edit teldrive.service
template_view teldrive.service
!!! template_copy teldrive.service /etc/systemd/system/teldrive.service ;; chmod 640 $lastarg 
vi2 /etc/systemd/system/teldrive.service ; ls -al /etc/systemd/system/teldrive.service
systemctl daemon-reload
systemctl restart teldrive.service ;; systemctl status teldrive.service ;;
systemctl enable --now teldrive.service ;; systemctl status teldrive.service ;;
# http://$publicip:$webport
nmap localhost
# 봇 토큰 추가 (Teldrive 웹) 업로드/다운로드 속도를 위해 7-8개의 봇 토큰
ufw allow varPort__8080__80
# teldrive db backup - pgsql
PGPASSWORD="$teldbpw" pg_dump -U "$teldbuser" -h "$teldbhost" -d "$teldbname" -F c -b -v -f "teldrive_backup_$(date +\%Y\%m\%d).backup" ;; ls -al teldrive_backup*







#trash
#vi2 /var/lib/teldrive/.config/teldrive/config.json
#mkdir -p /var/lib/teldrive/.config/teldrive && chown -R teldrive:teldrive /var/lib/teldrive
#export config="/var/lib/teldrive/.config/teldrive/config.json" ; touch $config && chown -R teldrive:teldrive $config && chmod 640 $config



%%% {submenu_com}teldrive-rclone fork [telr]
%%%e {submenu_com}teldrive-rclone fork [telr]
%% echo "rcloud:$rcloud // rcloudroot:$rcloudroot"
# rclone fork - teldrive 가 정식 cloud drive 가 아니라 rclone 포함 힘들듯
# https://github.com/tgdrive/rclone/releases
wget -O rclone.deb https://github.com/tgdrive/rclone/releases/download/v1.69.1/rclone-v1.69.1-linux-amd64.deb 
apt install ./rclone.deb
dpkg -L rclone | cgrep1 /bin
rclone version
ay fuse3
# config Teldrive WebUI ->‘DevTools(f12) -> Application -> cookie -> access-token (copy)
# api host -> http://localhost:8080
rclone config
mkdir -p /mnt/teldrive ;; ls -al /mnt/teldrive
cat /root/.config/rclone/rclone.conf | cgrep1 teldrive
vi2 /root/.config/rclone/rclone.conf
export rcloud=$(cat /root/.config/rclone/rclone.conf |grep '^\['| awk -F'\\]|\\[' '{print $2}' | pipemenu) ;; export rcloudroot="$(rclone lsd $rcloud:/ | awk '{$1=$2=$3=$4=""; print $0}')" ; echo "$rcloudroot"
# mount
# mount point /mnt/teldrive 에는 아무런 파일이나 폴더가 들어가 있으면 안된다.
nohup rclone mount varRemote__teldrive:/ /mnt/teldrive --daemon --vfs-cache-mode writes --allow-non-empty & ;; sleep 1 ;  df -h | cgrep1 teldrive &
df -h | cgrep1 teldrive | cgrep /mnt/
# umount
fusermount -u /mnt/teldrive
for i in $( df|awk99|grep mnt ) ; do fusermount -u $i ; done ;; df | cgrep /mnt





%%% {submenu_com}postgresql [psql]
%%%e {submenu_com}postgresql [psql]
%% echo "postgresqlconf:$postgresqlconf pg_hbaconf:$pg_hbaconf"
# install
yyay postgresql postgresql-contrib lsb_release 
systemctl status postgresql
sudo -i -u postgres
psql --version
# pgroonga (need for teldrive)
ay software-properties-common ; add-apt-repository -y universe ; add-apt-repository -y ppa:groonga/ppa ; apt update
# Ubuntu 22.04->14 // 24.04 ->16
ay -V varOS__postgresql-14-pgroonga__postgresql-16-pgroonga
# root pw chg
sudo -u postgres psql -c "ALTER USER postgres WITH PASSWORD 'varDBPW';"
sudo -u postgres psql
# db create
sudo -u postgres psql -c "CREATE USER varDBUser WITH PASSWORD 'varDBPW';"
sudo -u postgres psql -c "CREATE DATABASE varDBName OWNER varDBUser;"
sudo -u postgres psql -c "ALTER DATABASE varDBName OWNER TO varDBUser;"
sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE varDBName TO varDBUser;"
# pgroonga ext set 
sudo -u postgres psql teldrive -c "CREATE EXTENSION IF NOT EXISTS pgroonga;"
# db pw chg
sudo -u postgres psql -c "ALTER USER varDBUser WITH PASSWORD 'varDBPW';"
# allow 0.0.0.0
export postgresqlconf="$(sudo -u postgres psql -c "SHOW config_file;"|grep "/etc/")"
vi2 $postgresqlconf
change $postgresqlconf "#listen_addresses" "listen_addresses = '*'" line
# allow 0.0.0.0 db
export pg_hbaconf="$(sudo -u postgres psql -c "SHOW hba_file;"|grep "/etc")"
vi2 $pg_hbaconf
echo "host    varDBName    varDBUser    0.0.0.0/0            scram-sha-256" | insert $pg_hbaconf "IPv4 local connections"
# firewall add
ufw status
ufw allow 5432/tcp comment 'Allow PostgreSQL access'
#
systemctl restart postgresql 
systemctl status postgresql




%%% {submenu_com}rclone mount [cc]
%%%e {submenu_com}rclone mount [cc]
%% df -h | grep /mnt | cpipe
curl https://rclone.org/install.sh | bash ;; rclone --version
rclone config
# cloud token config 가 Rhost 에 있다면 copy
mkdir -p /root/.config/rclone/ ; scp varHost:/root/.config/rclone/rclone.conf /root/.config/rclone/ ; vi2 /root/.config/rclone/rclone.conf
mkdir -p /tmp/rclone/Cache /tmp/rclone/Log ; chmod 700 /tmp/rclone ; ls -al /tmp/rclone
vi2 /root/.config/rclone/rclone.conf
yyay fuse3
# var export 
echo "CLOUD='varCLOUD__gdrive' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__gdrive_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
echo "CLOUD='varCLOUD__gcp' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__gcp_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
echo "CLOUD='varCLOUD__onedrive' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__onedrive_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
cat /tmp/rclone/var.conf
# after var export // import env && rclone { mkdir,copy,ls } test
# 아래 명령시 에러가 나지 않을경우 마운트가 가능
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone mkdir $CLOUD:$RMOUNT 
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone copy /root/.config/rclone/rclone.conf $CLOUD:$RMOUNT 
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone lsd $CLOUD: ; rclone ls $CLOUD:$RMOUNT
# rclone mount ( script 종료후에도 마운트 유지 nohup ) 
. /tmp/rclone/var.conf ; nohup rclone mount $CLOUD:$RMOUNT /mnt/$LMOUNT --config /root/.config/rclone/rclone.conf --daemon --allow-other --allow-non-empty --fast-list --drive-skip-gdocs --poll-interval=15s --vfs-cache-mode full --vfs-write-back 5s --bwlimit-file 16M --buffer-size=16M --vfs-read-chunk-size=32M --vfs-read-chunk-size-limit 2048M --vfs-cache-max-size 10G --vfs-cache-max-age 336h --vfs-read-ahead 32M --dir-cache-time=1000h --log-level INFO --log-file $LTMP/Log/rclone.log --cache-dir=$LTMP/Cache --timeout 1h --umask 000 &>/dev/null & sleep 2  ; df | grep /mnt | cdir
tail -n100 $LTMP/Log/rclone.log
# rc.local 에 추가
cat /tmp/rclone/var.conf >> /etc/rc.local ; echo -e "mkdir -p /tmp/rclone/Cache /tmp/rclone/Log ; chmod 700 /tmp/rclone\nmkdir -p /mnt/$LMOUNT ; rclone mkdir $CLOUD:$RMOUNT\nrclone mount $CLOUD:$RMOUNT /mnt/$LMOUNT --config /root/.config/rclone/rclone.conf --daemon --allow-other --allow-non-empty --fast-list --drive-skip-gdocs --poll-interval=15s --vfs-cache-mode full --vfs-write-back 5s --bwlimit-file 16M --buffer-size=16M --vfs-read-chunk-size=32M --vfs-read-chunk-size-limit 2048M --vfs-cache-max-size 10G --vfs-cache-max-age 336h --vfs-read-ahead 32M --dir-cache-time=1000h --log-level INFO --log-file $LTMP/Log/rclone.log --cache-dir=$LTMP/Cache --timeout 1h --umask 000 " >> /etc/rc.local
vi2 /etc/rc.local
#
# unmount // explorer // update
df ;; . /tmp/rclone/var.conf ; umount /mnt/$LMOUNT
explorer /mnt/$LMOUNT
rclone selfupdate --stable




%%% {submenu_com}rclone direct command [rclone]
%%%e {submenu_com}rclone direct command [rclone]
# 폴더를 마운트 하여 작업할경우 임시폴더에 이동후 작업
# 직접 명령으로 임시폴더를 거치지 않고 네트웍 전송
%% echo "rcloud: $rcloud"
%% echo "rcloud2: $rcloud2"
rclone config
: rcloud; export rcloud=$(cat /root/.config/rclone/rclone.conf |grep '^\['| awk -F'\\]|\\[' '{print $2}' | pipemenu) ;; export rcloudroot="$(rclone lsd $rcloud:/ | awk '{$1=$2=$3=$4=""; print $0}')" ; echo "$rcloudroot"
: rcloud2;export rcloud2=$(cat /root/.config/rclone/rclone.conf |grep '^\['| awk -F'\\]|\\[' '{print $2}' | pipemenu) ;; export rcloud2root="$(rclone lsd $rcloud2:/ | awk '{$1=$2=$3=$4=""; print $0}')" ; echo "$rcloud2root"
# varDIR ls -d
rclone lsd $rcloud:varDIR__@@
rclone lsd $rcloud2:varDIR__@@
# varDIR ls
rclone ls $rcloud:varDIR
# varDIR ls -l
rclone lsl $rcloud:varDIR
# varDIR 트리뷰
rclone lsf $rcloud:varDIR
# varDIR 새폴더 생성
rclone mkdir $rcloud:varNewDIR
# varDIR 빈폴더 삭제 
rclone rmdir $rcloud:varEmptyDIR
# varDIR 폴더내 파일 삭제
rclone delete $rcloud:varDIR
# varDIR 폴더 전체삭제
rclone purge $rcloud:varDIR
# varDIR 복사
rclone copy varPath $rcloud:varDIR ; push
rclone copy varPath $rcloud2:varDIR ; push
# copy cloud -> rclone relay server -> clond2 (주의)rclone 중계서버 네트워크 사용함)
rclone lsd $rcloud:varDIRlist__@@ ;; rclone copy $rcloud:varDIRdest $rcloud2:varDIRdest --progress --transfers=10 --checkers=8 --drive-chunk-size=64M ; push
# varDIR 동기화
rclone sync varPath $rcloud:varDIR ; push
rclone sync varPath $rcloud2:varDIR ; push
# mount
mkdir -p $HOME/$rcloud.tmpmount ; rclone mount $rcloud:/ $HOME/$rcloud.tmpmount & ;; cd $rcloud.tmpmount ; ls -al ; readx ; explorer $HOME/$rcloud.tmpmount
# umount 
fuser -km $HOME/$rcloud.tmpmount ;; umount $HOME/$rcloud.tmpmount



%%% {submenu_com}rclone serve [rclones]
%%%e {submenu_com}rclone serve [rclones]
%% echo "sharefoler: $sharefoler"
# rclone 을 이용하여 파일서버 구축
# rclone 이 설치된 곳의 폴더나 rclone.conf 에 정의된 클라우드를 ftp 같은 서버로 만듬
cat /root/.config/rclone/rclone.conf | cgrep1 "\[.*\]"
# 내 폴더를 serve 할때 web:8080 // web:8081
export sharefoler=varSharePath__@@mnt@@share ;; mkdir -p $sharefoler
nohup rclone serve http $sharefoler --addr :varPort__8080 --log-level INFO &
# web 인증 설정 ( auth web // auth webdav )
htpasswd -Bcb $sharefoler/.htpasswd varID varPW ;; cat $sharefoler/.htpasswd | cgrep1 varID
nohup rclone serve http $sharefoler --addr :varPort__8080  --htpasswd $sharefoler/.htpasswd --log-level INFO &
nohup rclone serve webdav $sharefoler --addr :varPort__8081 --htpasswd $sharefoler/.htpasswd --log-level INFO &
nohup rclone serve dlna $sharefoler --addr :varPort__8082 --log-level INFO &
nohup rclone serve ftp $sharefoler --addr :varPort__2121 --user varID --pass varPW --log-level INFO &
nohup rclone serve sftp $sharefoler --addr :varPort__2222 --user varID --pass varPW --log-level INFO &
# gdrive ftp serve 
nohup rclone serve ftp varCloudNmae__gdrive:/ --addr :varPort__2121 --user varID --pass varPW --log-level INFO & ;; nmap localhost
# script 종료 되도 서비스 유지 ( screen 사용법 -> x [Enter] )
screen -dmS "rclone.serve.web" nohup rclone serve http $sharefoler --addr :varPort__8080  --htpasswd $sharefoler/.htpasswd --log-level INFO &
screen -dmS "rclone.serve.web" sh -c 'nohup rclone serve http $sharefoler --addr :varPort__8080  --htpasswd $sharefoler/.htpasswd --log-level INFO &'
screen -dmS "rclone.serve.webdav" nohup rclone serve webdav $sharefoler --addr :varPort__8081 --htpasswd $sharefoler/.htpasswd --log-level INFO 
screen -dmS "rclone.serve.dlna" nohup rclone serve dlna $sharefoler --addr :varPort__8082 --log-level INFO 
screen -dmS "rclone.serve.ftp" nohup rclone serve ftp $sharefoler --addr :varPort__2121 --user varID --pass varPW --log-level INFO 
screen -dmS "rclone.serve.sftp" nohup rclone serve sftp $sharefoler --addr :varPort__2222 --user varID --pass varPW --log-level INFO 
screen -dmS "rclone.serve.ftp.gdrive" nohup rclone serve ftp varCloudNmae__gdrive:/ --addr :varPort__2121 --user varID --pass varPW --log-level INFO
# setsid 로 별도 sid 지정 (sigterm 대응)
setsid rclone serve sftp "$sharefoler" --addr ":$varPort__2222" --user "$varID" --pass "$varPW" --log-level INFO --log-file="/var/log/my_rclone_sftp_service.log" 
# 
echo "$(hostname -f):varPort"
nmap localhost
ufw allow varPort
ay screen
# stop
pgrep -af "screen" ;; screen -ls
pgrep -af "rclone serve"
kill -9 $(pgrep -af "rclone serve" |awk1)

%%% {submenu_com}tmux [xx]
%%%e {submenu_com}tmux [xx]
# prefix key ctrl-b ( screen -> ctrl-a )
tmux -u 
# tmux 한글깨짐 utf8 set 
echo -e "alias tmux='tmux -u'" >> $HOME/.bashrc
tmux ls
tmux attach 
tmux attach -t $( tmux ls|awk -F: '{print $1}' | pipemenu ) 
tmux kill-session 
tmux kill-session -t $( tmux ls|awk -F: '{print $1}' | pipemenu ) 
tmux kill-server
tmux new-session -u -d 'bashtop' \; new-window 'top' \; new-window 'iftop' \; new-window 'sh -c "pstree; exec bash"'; tmux attach
# 새로운 윈도우 생성: Ctrl-b c (create)
# 다음 윈도우로 이동: Ctrl-b n (next)
# 이전 윈도우로 이동: Ctrl-b p (prev)
# 세로 분할: Ctrl-b %
# 가로 분할: Ctrl-b "
# 패널 이동: Ctrl-b 방향키
# 패널 크기 조절: Ctrl-b Ctrl-방향키
# 스크롤 모드: Ctrl-b [
# 스크롤 모드 종료: q
# 탈출 (detach)하여 현재 세션 종료: Ctrl-b d
#
# install
yyay tmux



# 변수 재사용 5초 타임아웃 
[ -z "$vmslistoutput" ] || (( $(date +%s) - ${vmslistoutput:0:10} >= 5 )) && export vmslistoutput="$(date +%s)$(vmslistview)"; echo ${vmslistoutput:10}


%%% {submenu_virt}>Proxmox 관리 가이드 [flow_proxmox]
%%%e {submenu_virt}>Proxmox Management Guide [flow_proxmox]
%% echo "Proxmox VE 환경 관리 가이드입니다."
%% echo "각 단계를 완료하고 엔터 또는 'b'를 눌러 다음 단계로 이동하세요."
#----------------------------------------------------------------------
: 1단계: 기본 상태 확인 ; pxc
:   (참고) 현재 노드 시스템/리소스 상세 확인 ; p
:   (참고) 네트워크 설정 상세 확인 ; n
#----------------------------------------------------------------------
: 2단계: 스토리지 확인 및 관리 ; pxs
:   (참고) 물리 디스크/파티션 정보 ; f
:   (참고) LVM 볼륨 관리 (생성/확장 등) ; lvm
:   (참고) ISO/LXC 템플릿 다운로드/관리 ; iso
#----------------------------------------------------------------------
: 3단계: VM/CT 관리 ; px
# --- 3.1: VM(KVM) 생성/관리 ---
:   VM 생성 (Ubuntu/Debian 등 ISO 기반) ; ubun
:   (선택) VM 생성 (Xpenology NAS) ; nas
:   (선택) VM 생성 (OPNsense 방화벽) ; opn
:   (참고) VMware 이미지 마이그레이션 ; mig
:   (고급) KVM 하이퍼바이저 직접 관리 (virsh) ; kvm
:   (참고) OS 이미지 변환 (qemu-img) ; qemui
# --- 3.2: CT(LXC) 생성/관리 ---
:   LXC 템플릿 다운로드 (pveam) ; iso
:   CT 관리 (생성/삭제는 GUI/CLI 권장) ; px
# --- 3.3: Cloud-Init (VM 템플릿) ---
:   Cloud-Init VM 템플릿 생성 (범용 이미지) ; pxci
:   Cloud-Init VM 템플릿 생성 (기존 VM 변환) ; pxcc
#----------------------------------------------------------------------
: 4단계: 백업, 스냅샷, 복구 ; pxdump
:   (중요) VM/CT 스냅샷 관리 ; snap
:   (선택) Proxmox Backup Server(PBS) 설정 ; pbs
:   (참고) 호스트 설정 백업/복구 ; pxb
:   (주의) 삭제된 VM 디스크 복구 시도 ; pxr
#----------------------------------------------------------------------
: 5단계: 고급 설정 및 유지보수 ; pxg
:   (참고) AMD GPU 패스스루 ; pxgg
:   (참고) WebUI SSL 인증서 설정 ; pvssl
:   (참고) Tailscale VPN 설정 ; pxt
:   (참고) 내부망 DHCP 서버 설정 ; pxd
:   (참고) Open vSwitch 설정 ; ovs
:   (중요) Proxmox 시스템 업그레이드 ; pxup
:   (참고) Proxmox Helper Scripts (부가 기능) ; pxh
:   (참고) 로그 확인 및 Fail2ban ; pxl
:   (주의) 클러스터 노드 탈퇴/리셋 ; node

#%% exec 3< <(basename "$(readlink /etc/pve/local 2>/dev/null)" 2>/dev/null);# cat <&3
#%% echo SHLVL:$SHLVL
#: Local Node Name; echo "* Local Node: $(basename "$(readlink /etc/pve/local 2>/dev/null)" 2>/dev/null)"
#%% basename "$(readlink /etc/pve/local 2>/dev/null)" 2>/dev/null > /dev/shm/dlines 2>/dev/null && sleep 0.1
#: qemu info; pvesh get /nodes/$(find /etc/pve/ -name varVMID.conf |head -n1|awk -F/ '{print $5}')/qemu/varVMID/status/current --noborder 
#: pct info; pvesh get /nodes/$(find /etc/pve/ -name varVMID.conf |head -n1|awk -F/ '{print $5}')/lxc/varVMID/status/current --noborder 

%%% {submenu_virt}proxmox - manage vms [px]
%%%e {submenu_virt}proxmox - manage vms [px]
%% vmslistview|cgrep3136 running
{ pct list ;echo; qm list ; } | cgrep1 running
vmslist | cgrep stopped | cgrep1 running
: pct Start/Stop; pct list | cgrepline running ;; for i in varPCTIDs ; do pct varMode__enter__start__stop__reboot__config__unlock $i ; done ;; vmslist | cgrep stopped | cgrep1 running
: qm Start/Stop ; qm list | cgrepline running ;; for i in varVMIDs ; do qm varMode__start__stop__reset__status__config__unlock $i ; done ;; vmslist | cgrep stopped | cgrep1 running
# pct / qemu enter (ssh) ---> Please press Enter after typing the VMID directly on the prompt.
: pct  enter; pct list |cgrepline running ;; pct enter $( pct list | awknr2 | pipemenu1 ) 
: qemu enter; vmslist|grep qemu|cgrepline running ;; qssh varVMID varSshID__root
: stop all ; pvenode stopall --timeout varTimeOut__180__120__60
: start all ; pvenode startall --vms varVMSnospace --force
: onboot autoStart pct check; pct list | awk '{print $1}' | tail -n +2 | while read ctid; do echo "CT $ctid: $(pct config $ctid | grep onboot)"; done
: onboot autoStart qm  check; qm list | awk '{print $1}' | tail -n +2 | while read vmid; do echo "VM $vmid: $(qm config $vmid | grep onboot)"; done
: disk_usage ; lvs --noheadings --units g -o lv_name,lv_size,data_percent | awk '$2 != "0.00g" && NF==3 {u=$2*$3/100; printf "%s: %s / %.2fG / %s%%\n", $1, $2, u, $3}' | column -t
# proxmox boot -> vm autostart on(1)/off(0)
qm set varVMID --onboot varSET__0__1 
pct set varVMID --onboot varSET__0__1 
# proxmox api - pvesh
pvesh get $( echo cluster/resources cluster/status /nodes /storage | pipemenu )
pvesh get $( echo cluster/resources cluster/status /nodes /storage | pipemenu ) --noheader --noborder | tr -s ' ' | cpipe
explorer /etc/pve/
# iface -> iprange check
for nic in $( basename -a /sys/class/net/e* ) ; do echo -n "$nic " ; ip -br a s $( basename $( readlink -f  /sys/class/net/$nic/master/))|awk '{print $3}' ; done
# proxmox functions
: monitor all kvms ; watch_pve
: ip scan - Running qemu vms - arp-scan ; vmipscan varIFace__vmbr0
: pct/qemu enter ; enter varVMID
: vm all_node_pct_qemu ; vm varVMID
: vm all_node_pct_qemu ; vm varVMID varS__start__stop__enter__status__config__econfig__ip__shutdvown__reboot__reset__suspend__resume__snapshot__rollback__backup
: functions ; varS__vm__vms__vmm



%%% {submenu_virt}proxmox - start stop enter vm [pxx]
%%%e {submenu_virt}proxmox - start stop enter vm [pxx]
vmslistview | cgrepn running -3 ;; vm varVMID varS__start__stop__enter__status__config__econfig__ip__shutdvown__reboot__reset__suspend__resume__snapshot__rollback__backup


%%% {submenu_virt}proxmox - monitoring vms [pxm]
%%%e {submenu_virt}proxmox - monitoring vms [pxm]
watch_pve

#trash
: qemu ssh ;vmslist | grep qemu | cgrepline running ;; qmip=$( qm agent varVMID network-get-interfaces | gipa | grep -v "127.0.0.1" ); [ "$qmip" ] && ssh root@$qmip




%%% {submenu_virt}proxmox - storage [pxs]
%%%e {submenu_virt}proxmox - storage [pxs]
%% vmslistview|cgrep3136 running
# storage
pvesm status | cgrep1 lvmthin | hl -h
pvesm list $( pvesm status |awk1 |awknr2 |pipemenu )
pvesm scan ;; pvesm scan varA
# trim ( thin-volume diet ) - 운영 vm 들의 root 로 실행
fstrim -a -v
systemctl status fstrim.timer
journalctl -u fstrim.service
# lvs vm size check
lvs --units g -o lv_name,data_percent | awk '$1 ~ /^vm-/{printf "Estimated used size of LV '\''%s'\'': %.2fGiB\n", $1, ($2 * 10) / 100}'
# mount/unmount - vm pct
pvesm status ; lvs ;; qm set varVMID $( echo -scsi0 -scsi1 -sata0 -sata1 -ide0 -ide1 |pipemenu) varSTGName:varLVName
pvesm status ; lvs ;; qm set varVMID $( echo -scsi0 -scsi1 -sata0 -sata1 -ide0 -ide1 |pipemenu) none
pvesm status ; lvs ;; pct set varVMID $( echo -mp0 -mp1 -mp2 |pipemenu) varSTGName:varLVName,mp=/mnt/disk1
pvesm status ; lvs ;; pct set varVMID $( echo -mp0 -mp1 -mp2 |pipemenu) none
# qm importdisk <vmid> /var/lib/vz/images/your-image.qcow2 local-lvm
pvesm status ; lvs ;; qm importdisk varVMID varQCowPATH varSTGName
# list of storage ( backup / image ) 
pvesh get /storage -output-format=yaml |cgrep backup |cgrep1 storage 
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage'
explorer /etc/pve/
# proxmox api - pvesh
pvesh get $( echo cluster/resources cluster/status /nodes /storage | pipemenu )
# template iso/img list
find /var/lib/vz/template/
# pveam lxc image download 
pveam update ; pveam available ; pvesm status |hl -h ;; pveam download varSTRG__local $( pveam available|awk2 |pipemenu1  ) 

#trash
# thin-pool 사용량 체크 (vm 이 사용할 수 있는 thin 전체 용량)
(echo "LV LSize Data% Meta% Used(G) Free(G)"; lvs --units g -o lv_name,lv_size,data_percent,metadata_percent --select 'segtype="thin-pool"' --noheadings | awk '{print $1, $2, $3, $4, ($2 * $3 / 100) "G", ($2 - ($2 * $3 / 100)) "G"}') | column -t



%%% {submenu_virt}proxmox - cluster/node [pxc]
%%%e {submenu_virt}proxmox - cluster/node [pxc]
%% vmslistview|cgrep3136 running
# cluster
pvecm $( echo status nodes | pipemenu ) 
# cluster 하나가 shutdown 되었을때, lock 해제 투표수조정 
!!! pvecm expected 1 
# cluster 동기화 서버 없고, cluster 간헐적 운영시 quorum 섹션 주석처리   
vi2 /etc/corosync/corosync.conf
systemctl restart corosync
# !!! cluster node etc backup / delete
rbackup varBDIR__@@backup/etc_daily.tgz ; tar cvzf varBDIR__@@backup/etc_daily.tgz /etc/ ; ls -al /backup/etc_daily.*
!!! pvecm delnode varNodename ; ls -al /etc/pve/nodes ; rm -r /etc/pve/nodes/varNodename
systemctl restart pve-cluster
# list of nodes
pvesh get /nodes --output-format json | jq -r '.[].node'
# vmID -> node name check 
find /etc/pve/nodes/*/{qemu-server,lxc} -name 'varVMID'.conf | awk -F/ '{print $5}'
# pveproxy webui restart 
systemctl restart pveproxy ; systemctl status pveproxy 
systemctl status pveproxy 
explorer /etc/pve/
# proxmox api - pvesh
pvesh get $( echo cluster/resources cluster/status /nodes /storage | pipemenu )



%%% {submenu_virt}proxmox - node reset [node]
%%%e {submenu_virt}proxmox - node reset [node]
pvecm nodes ;echo; pvecm status
# 클러스터에서 node 분리 작업
systemctl stop pve-cluster corosync
pmxcfs -l 
# corosync 구성 파일 검토/백업/삭제
rbackup varBackupDIR__@@backup/etc_daily.tgz ; tar cvzf varBackupDIR__@@backup/etc_daily.$(datetag2).tgz /etc/ 
vi2 /etc/pve/corosync.conf
explorer /etc/corosync/
#
rm -rf /etc/pve/corosync.conf /etc/corosync/*
killall pmxcfs ; systemctl start pve-cluster
# 나머지 node 에서 분리된 node 삭제
pvecm delnode varNodename
rm -rf /etc/pve/nodes/varNodename 
# cluster node down 
# 정족수 부족 -> 읽기전용모드 -> 해제
pvecm expect 1




%%% {submenu_virt}proxmox - iso/lxc download [iso]
%%%e {submenu_virt}proxmox - iso/lxc download [iso]
%% find /var/lib/vz/template/iso -type f -exec ls -alh {} \;
# iso download 
cd /var/lib/vz/template/iso ; ls -al
cd varIsoPath; ls -al 
# ubuntu Server 22.04.3
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O ubuntu-22.04.3-live-server-amd64.iso https://releases.ubuntu.com/22.04.3/ubuntu-22.04.3-live-server-amd64.iso ;push
# ubuntu Desktop 23.10 
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O ubuntu-23.10.1-desktop-amd64.iso https://releases.ubuntu.com/23.10.1/ubuntu-23.10.1-desktop-amd64.iso ;push
# centos7 http://mirror.kakao.com/centos/7.9.2009/isos/x86_64/
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O CentOS-7-x86_64-DVD-2009.iso http://mirror.kakao.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso ;push
# debian12 https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O debian-12.2.0-amd64-DVD-1.iso https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.2.0-amd64-DVD-1.iso ;push
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O debian-12.10.0-amd64-DVD-1.iso https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.10.0-amd64-DVD-1.iso
# hamonios
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O hamonikr-kumkang-7.0-LTS-amd64.iso https://invesume.com/linkfile/download_count.php?type=hamonikr-kumkang-7.0-LTS-amd64.iso ;push
#
# pveam lxc image download 
pveam update ; pveam available ; pvesm status | hl -h ;; pveam download varSTRG__local $( pveam available|awk2 |pipemenu1  ) 
#
#
explorer /var/lib/vz/template/iso
explorer varIsoPath




%%% {submenu_virt}proxmox - webui ssl-cert set [pvssl]
%%%e {submenu_virt}proxmox - webui ssl-cert set [pvssl]
%% echo "myemail: $myemail mydomain: $mydomain"
# after - publicip & domain set
# 
hostname -f 
# stop temporary :80 port web-service 
netstat -tulnp | grep :80
# email / doamin set
echo "myemail=varEmail" | tee -a ~/go.private
echo "mydomain=varDomain" | tee -a ~/go.private
# 0: Production mode 
pvenode acme account register default $myemail
pvenode acme account register default varEmail
vi2 /etc/pve/priv/acme/default
# domain set
hostname -f ;; pvenode config set --acme domains=$mydomain
hostname -f ;; pvenode config set --acme domains=varDomain
# cert order - port 80 use
pvenode acme cert order
pvenode acme cert order --force
# pveproxy restart
systemctl restart pveproxy
# renew force
pvenode acme cert renew --force
#
pvenode acme account list
pvenode cert info
!!! pvenode acme cert revoke
pvenode help | less -RX



%%% {submenu_virt}proxmox - backup vms [pxdump]
%%%e {submenu_virt}proxmox - backup vms [pxdump]
%% vmslistview|cgrep3136 running
# { pct list ; qm list ; } | cgrepline running
# dump selects ex. vzdump 100 101
vzdump varVMIDs --mode snapshot --storage $( pvesh get /storage -output-format=json | jq -r --arg node "$(basename "$(readlink /etc/pve/local)")" '.[] | select( (.nodes == $node) and (.type == "dir") and (.content |contains("backup"))) | .storage' | pipemenu storage ) --compress zstd --notes-template '{{guestname}}' --remove 0 ; bell
# dump running vms
vms="$( { pct list ; qm list ; } | grep running | awk1 | oneline )" ; echo "Dump vms: $vms" ; readx ; vzdump $vms --mode snapshot --storage $( pvesh get /storage -output-format=json | jq -r --arg node "$(basename"$(readlink /etc/pve/local)")" '.[] | select( (.nodes == $node) and (.type == "dir") and (.content | contains("backup"))) | .storage' | pipemenu storage ) --compress zstd --notes-template '{{guestname}}' --remove 0 ; bell
# dump all
vzdump --all   --mode snapshot --storage $(pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'| pipemenu storage ) --compress zstd --remove 0 ; bell
# proxmox etc daily backup -> cronadd
mkdir -p varEtcBackupPATH__@@mnt@@pve@@onedrive@@etc ; echo "59 23 * * * root /bin/bash -c 'tar -cvzf varEtcBackupPATH__@@mnt@@pve@@onedrive@@etc/pve-config-backup.\$(hostname).\$(date +\%Y\%m\%d).tar.gz /var/lib/pve-cluster/config.db /etc/pve > /dev/null 2>&1'" >> /etc/crontab ; vi2 /etc/crontab
# all node storage check
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'
# local node storage check
pvesh get /storage -output-format=json | jq -r --arg node "$(basename "$(readlink /etc/pve/local)")" '.[] | select( (.nodes == $node) and (.type == "dir") and (.content | contains("backup"))) | .storage'




%%% {submenu_virt}proxmox - log/ fail2ban [pxl]
%%%e {submenu_virt}proxmox - log/ fail2ban [pxl]
# access log
cat /var/log/pveproxy/access.log | cpipe | less -RX +G
# auth log
journalctl -u pvedaemon --no-pager | grep "authentication" | cpipe | less -RX +G
# common log 
journalctl -u pveproxy -rx
#
# fail2ban
template_view fail2ban_filter_proxmox.conf
!!! template_copy fail2ban_filter_proxmox.conf /etc/fail2ban/filter.d/proxmox.conf
vi2 /etc/fail2ban/filter.d/proxmox.conf
#
template_view fail2ban_jail_proxmox.conf
!!! template_copy fail2ban_jail_proxmox.conf /etc/fail2ban/jail.d/proxmox.conf
vi2 /etc/fail2ban/jail.d/proxmox.conf
#
systemctl reload fail2ban
systemctl status fail2ban
fail2ban-client status
fail2ban-client status proxmox
# file
explorer /etc/fail2ban/filter.d/
explorer /etc/fail2ban/jail.d/





# chg
vzdump varVMIDs --mode snapshot --storage $(pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'| pipemenu storage ) --compress zstd --notes-template '{{guestname}}' --remove 0 ; bell
vms="$( { pct list ; qm list ; } | grep running | awk1 | oneline )" ; echo "Dump vms: $vms" ; readx ; vzdump $vms --mode snapshot --storage $(pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'| pipemenu storage ) --compress zstd --notes-template '{{guestname}}' --remove 0 ; bell




%%% {submenu_virt}proxmox - snapshot [snap]
%%%e {submenu_virt}proxmox - snapshot [snap]
%% vmslistview|cgrep3136 running
# 설치를 하거나 무언가 서버에 조작이 필요할때는 사전에 필히 스냅샷을 찍어둔다.
# 서버에 자원 부하가 적기 때문에 자주해도 부담이 없다.
# 너의 시간과 고생을 아껴줄 것이다. 
pct list ;echo; qm list
# snapshot
pct list | cgrep1 running ;; pct snapshot varPCTID varPCTName__adatetag2 
qm list | cgrep1 running ;; qm snapshot varVMID varVMName__adatetag2
# running vms -> autosnapshot
: pct ; for i in $( pct list | grep running | awk1 ) ; do echo "$i >>> " ; pct snapshot $i daily_auto_$(datetag2) ; done
: qm  ; for i in $( qm list  | grep running | awk1 ) ; do echo "$i >>> " ; qm snapshot $i daily_auto_$(datetag2) ; done
: all ; for i in $( pct list | grep running | awk1 ) ; do echo "$i >>> " ; pct snapshot $i daily_auto_$(datetag2) ; done ; for i in $( qm list | grep running | awk1 ) ; do echo "$i >>> " ; qm snapshot $i daily_auto_$(datetag2) ; done
# list
pct listsnapshot varPCTID
qm listsnapshot varVMID
# rollback
pct list | awk1c ;; pct listsnapshot varPCTID | awk2c ;; pct rollback varPCTID varPCTName ;; pct start varPCTID
qm list | awk1c ;; qm listsnapshot varVMID | awk2c ;; qm rollback varVMID varVMName ;; qm start varVMID
# delete
pct delsnapshot varPCTID varPCTName 
qm delsnapshot varVMID varVMName 


vi2 /etc/default/grub
sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT=.*/#&\nGRUB_CMDLINE_LINUX_DEFAULT="quiet intel_iommu=on iommu=pt"/' /etc/default/grub


%%% {submenu_virt}proxmox - gpu passthrough - intel 1 - passthrough [pxg]
%%%e {submenu_virt}proxmox - gpu passthrough - intel 1 - passthrough [pxg]
%% echo "rootuuid:$rootuuid kernelv:$kernelv vgaid:$vgaid aduioid:$audioid"
%% cat /proc/cmdline
# 목표: GRUB 메뉴에서 아래 3가지 모드를 선택 가능하게 
# 로컬 모니터 사용 (Normal): 기본 상태. Proxmox 콘솔이 로컬 모니터에 나옴.-> n100 기준
# GPU 몰빵 (Passthrough): 로컬 모니터 사용 불가. VM 하나에 iGPU 통째로 할당. -> n100 기준
# GPU 골고루 (GVT-g): 로컬 모니터 사용 가능 + VM에 가상 GPU(vGPU) 할당 시도. -> n100 기준
# BIOS/UEFI에서 IOMMU (VT-d) 활성화 // secure boot off
: kernel version check ; export kernelv=$(uname -r) ; echo $kernelv
: root part uuid ; export rootuuid=$(lsblk -f|grep pve-root|awk '{print $(NF-3)}') ; echo $rootuuid
: vga vender id ; export vgaid=$(lspci -nn | grep -i vga | grep -o '\[[0-9a-fA-F]*:[0-9a-fA-F]*\]'|tr -d '[]') ; echo $vgaid
: audio vender id ; export audioid=$(lspci -nn | grep -i audio | grep -o '\[[0-9a-fA-F]*:[0-9a-fA-F]*\]'|tr -d '[]') ; echo $aduioid
# custom grub set
vi2 /etc/grub.d/40_custom
cat /boot/grub/grub.cfg|cgrep1 initrd.img |less -RX
template_edit grub40.conf
template_view grub40.conf
!!! template_insert grub40.conf /etc/grub.d/40_custom ;; cat "$lastarg"
# 몰빵용 iniramfs 만들고 모듈삭제 ###################################################################
: grub-update ; chmod -x /etc/grub.d/*.bak ; update-grub
# 1. vfio 설정 임시 삽입
echo "options vfio-pci ids=$vgaid,$audioid disable_vga=1 disable_idle_d3=1" > /etc/modprobe.d/vfio.conf
echo "blacklist i915" > /etc/modprobe.d/blacklist-i915.conf
echo -e "vfio\nvfio_pci\nvfio_iommu_type1\nvfio_virqfd" >> /etc/initramfs-tools/modules
update-initramfs -c -k $kernelv
cp /boot/initrd.img-${kernelv} /boot/initrd.img-${kernelv}-passthrough
lsinitramfs /boot/initrd.img-${kernelv}-passthrough | grep vfio # 세줄나와야 정상
# 2.기본 initramfs 로 복구 (로컬 콘솔 화면 사용할수있게)
rm /etc/modprobe.d/vfio.conf ; rm /etc/modprobe.d/blacklist-i915.conf ; sed -i '/vfio/d' /etc/initramfs-tools/modules ; cat /etc/initramfs-tools/modules
update-initramfs -u -k $kernelv ;; chmod -x /etc/grub.d/*.bak ; update-grub
# 3.리붓 //  리붓후 grub 에서 몰빵선택시 화면이 나가야 정상.. 부팅후 ssh 접속 체크
explorer /etc/grub.d/ /boot/
vi3 /etc/modules /etc/modprobe.d/blacklist.conf /etc/modprobe.d/blacklist-i915.conf /etc/modprobe.d/vfio.conf /etc/grub.d/40_custom /boot/grub/grubenv /etc/default/grub /etc/initramfs-tools/modules
# 4.gpu check
cat /proc/cmdline
dmesg | grep -iE "gvt|kvmgt|IOMMU" | cgrep 0000:00:02
{ lspci -vns 00:02.0 | cgrep "Kernel driver in use: vfio-pci" ; lspci -nnk | cgrep1 VGA Audio |cgrep vfio-pci ; } | less -R
for g in $(find /sys/kernel/iommu_groups/* -maxdepth 0 -type d | sort -V); do echo "IOMMU Group ${g##*/}:" ;for d in $g/devices/*; do echo -e "\t$(lspci -nns ${d##*/})" ;done ; done | cgrepline VGA Audio




echo "options vfio-pci ids=$vgaid,$audioid disable_idle_d3=1" > /etc/modprobe.d/vfio.conf
shopt -s nullglob
: next page ; pxgg
echo "$(grep -P "^menuentry ['\"]" /boot/grub/grub.cfg | sed -E "s/menuentry ['\"]([^'\"]+)['\"].*/\1/" | pipemenulist )"




%%% {submenu_virt}proxmox - gpu passthrough - intel 2 - SR-IOV [pxgg]
%%%e {submenu_virt}proxmox - gpu passthrough - intel 2 - SR-IOV [pxgg]
%% echo "rootuuid:$rootuuid kernelv:$kernelv vgaid:$vgaid audioid:$audioid"
%% cat /proc/cmdline
# GPU 골고루 (GVT-d): 로컬 모니터 사용 가능 + VM에 가상 GPU(vGPU) 할당 시도. -> n100 성공
# host 와 vm 이 동시 gpu 를 나눠서 쓰는데 의의를 갖자. vm 2개 할당에서 돌리면 뻗는 증상 발생
# https://github.com/strongtz/i915-sriov-dkms
# 골고루 #############################################################################################
: kernel version check ; export kernelv=$(uname -r) ; echo $kernelv
: root part uuid ; export rootuuid=$(lsblk -f|grep pve-root|awk '{print $(NF-3)}') ; echo $rootuuid
: vga vender id ; export vgaid=$(lspci -nn | grep -i vga | grep -o '\[[0-9a-fA-F]*:[0-9a-fA-F]*\]'|tr -d '[]') ; echo $vgaid
: audio vender id ; export audioid=$(lspci -nn | grep -i audio | grep -o '\[[0-9a-fA-F]*:[0-9a-fA-F]*\]'|tr -d '[]') ; echo $aduioid
# custom grub set
vi2 /etc/grub.d/40_custom
cat /boot/grub/grub.cfg|cgrep1 initrd.img |less -RX
template_edit grub40.conf
template_view grub40.conf
!!! template_insert grub40.conf /etc/grub.d/40_custom ;; cat "$lastarg"
# 1. deb install 
# BIOS/UEFI에서 IOMMU (VT-d) 활성화 // secure boot off
wget -O intel.deb "https://github.com/strongtz/i915-sriov-dkms/releases/download/2025.03.27/i915-sriov-dkms_2025.03.27_amd64.deb"
dpkg -i intel.deb
cd ~ ; git clone https://github.com/intel-gpu/intel-gpu-firmware.git
mkdir -p /lib/firmware/updates/i915/
cp intel-gpu-firmware/firmware/*.bin /lib/firmware/updates/i915/
update-initramfs -u -k $kernelv 
chmod -x /etc/grub.d/*.bak ; update-grub
# /etc/sysfs.conf 재부팅 후에도 유지되어야 하는 /sys 파일 시스템 관련 설정들을 영구적으로 저장
echo "devices/pci0000:00/$(lspci | grep VGA | head -n 1 | awk '{print "0000:"$1}')/sriov_numvfs = 7" >> /etc/sysfs.conf
vi2 /etc/sysfs.conf
# reboot
dkms status
lspci | grep VGA 
dmesg | grep i915 | cgrepline SR-IOV
: GPU-top ; intel_gpu_top -d drm:/dev/dri/renderD128 || ay intel-gpu-tools 
ls /sys/bus/pci/devices/0000:00:02.*
ls /dev/dri | cgrep1 renderD128
: before page ; pxg
# Mapped device 방식(GVT-g)은 불가 (지원 종료)
# Raw device (VF) 항목에서 7개 할당 (GVT-d 기반 SR-IOV 활용)




%%% {submenu_virt}proxmox - gpu passthrough - intel 3 - grub [pxggg]
%%%e {submenu_virt}proxmox - gpu passthrough - intel 3 - grub [pxggg]
%% cat /proc/cmdline
%% echo "=== cat /boot/grub/grubenv ================"
%% cat /boot/grub/grubenv |grep _entry
: kernel version check ; export kernelv=$(uname -r) ; echo $kernelv
: root part uuid ; export rootuuid=$(lsblk -f|grep pve-root|awk '{print $(NF-3)}') ; echo $rootuuid
: vga vender id ; export vgaid=$(lspci -nn | grep -i vga | grep -o '\[[0-9a-fA-F]*:[0-9a-fA-F]*\]'|tr -d '[]') ; echo $vgaid
: audio vender id ; export audioid=$(lspci -nn | grep -i audio | grep -o '\[[0-9a-fA-F]*:[0-9a-fA-F]*\]'|tr -d '[]') ; echo $aduioid
# custom grub set
vi2 /etc/grub.d/40_custom
cat /boot/grub/grub.cfg|cgrep1 initrd.img|cgrepline1 "menuentry"|less -RX
template_edit grub40.conf
template_view grub40.conf
!!! template_insert grub40.conf /etc/grub.d/40_custom ;; cat "$lastarg"
#
# 커널 디폴트(save_entry) or 리붓시1회 부팅 지정(next_entry)
# 
# lvm 위에 pve-root 가 설치된 경우 리붓시1회후 flag 삭제가 안되니 수동 삭제필요
# grub-reboot -> /boot/grub/grubenv set -> 다음부팅할 메뉴 기록 
: grub-reboot set ; grub-reboot "$(grep -P "^menuentry ['\"]" /boot/grub/grub.cfg | sed -E "s/menuentry ['\"]([^'\"]+)['\"].*/\1/" | pipemenulist )" ;; cat /boot/grub/grubenv
: grub-reboot cancel ; grub-editenv /boot/grub/grubenv unset next_entry ;; cat /boot/grub/grubenv
# grub-default
: grub-default set 1 ; change /etc/default/grub GRUB_DEFAULT "GRUB_DEFAULT=saved" line ;; chmod -x /etc/grub.d/*.bak ; update-grub
: grub-default set 2 ; grub-set-default "$(grep -P "^menuentry ['\"]" /boot/grub/grub.cfg | sed -E "s/menuentry ['\"]([^'\"]+)['\"].*/\1/" | pipemenulist )" ;; cat /boot/grub/grubenv
: grub-default cancel ; grub-editenv /boot/grub/grubenv unset saved_entry ;; cat /boot/grub/grubenv
cat /boot/grub/grubenv
#
# 커널 오염시 재설시  
# fail or reset -> kernel reinstall
dpkg -l | grep proxmox-kernel
apt install --reinstall $( dpkg -l | grep kernel|grep "proxmox-kernel"|awk2 | pipemenu )





%%% {submenu_virt}proxmox - gpu passthrough - amd [pxga]
%%%e {submenu_virt}proxmox - gpu passthrough - amd [pxga]
# 공사중
# amd apu 기준 하나의 vm 에서 gpu passthrough
# BIOS/UEFI에서 IOMMU/SVM enable // secure boot off
# https://god-logger.tistory.com/188
vi2 /etc/default/grub
sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT=.*/#&\nGRUB_CMDLINE_LINUX_DEFAULT="quiet amd_iommu=on iommu=pt video=efifb:off,vesafb:off initcall_blacklist=sysfb_init pcie_acs_override=downstream,multifunction"/' /etc/default/grub
#
# select gpu ( hostos // vm )
vi2 /etc/grub.d/40_custom
#
explorer /etc/grub.d/
#
!!! update-grub
!!! reboot
# 
vi2 /etc/modules
echo "vfio\nvfio_iommu_type1\nvfio_pci\nvfio_virqfd" | tee -a /etc/modules
# 내장 GPU와 오디오 드라이버를 호스트에서 사용하지 않도록 차단
vi2 /etc/modprobe.d/blacklist.conf
echo "blacklist amdgpu\nblacklist snd_hda_intel\nblacklist snd_hda_codec_hdmi" | tee -a /etc/modprobe.d/blacklist.conf
# vga / audio vender id check 
vi2 /etc/modprobe.d/vfio.conf
lspci -nn | cgrep1 VGA | cgrep Audio
# lscpi -> [1002:????] 형태의 amd vender 장치ID varVGA (참조 amd vender 1002)
echo "options vfio-pci ids=varVGA" >> /etc/modprobe.d/vfio.conf
echo "options vfio-pci disable_idle_d3=1" >> /etc/modprobe.d/vfio.conf
!!! update-initramfs -u
!!! reboot
# VBIOS 추출 -> vm 과 host 동기화 (rom)... 위 참고링크 확인
dmidecode -t bios
# gpu check
dmesg | grep IOMMU
ls /dev/dri | cgrep1 renderD128
lspci -nnk | cgrep1 VGA
# proxmox host gpu-top
yyay intel-gpu-toools
intel_gpu_top



%%% {submenu_virt}proxmox - upgrade && noti-push [pxup]
%%%e {submenu_virt}proxmox - upgrade && noti-push [pxup]
%% pveversion
%% echo "telegram_chatid:$telegram_chatid telegram_token:$telegram_token"
%% echo "WEBHOOK_NAME:$WEBHOOK_NAME ENCODED_TOKEN:$ENCODED_TOKEN ENCODED_CHAT_ID:$ENCODED_CHAT_ID ENCODED_BODY:$ENCODED_BODY ENCODED_HEADER:$ENCODED_HEADER"
# 현재버젼 확인
pveversion ;; dpkg -l | grep -i "proxmox ve"
echo "deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription" | tee -a /etc/apt/sources.list.d/pve-install-repo.list   
vi3 /etc/apt/sources.list.d/pve-install-repo.list /etc/apt/trusted.gpg.d/proxmox-release-bookworm.gpg
wget https://enterprise.proxmox.com/debian/proxmox-release-bookworm.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bookworm.gpg
# 판올림 없이 프로그램만 업그레이드 
: upgrade ; apt update ; apt -y upgrade
# 판올림 ex) 8.1 -> 8.2 --> 사전 구동중인 vm 종료 혹은 migrate 
: upgrade dist ;  apt update ; apt -y dist-upgrade ;; bell
!!! reboot
# ### kernel up
apt list proxmox-kernel* ;; readxy &&  apt install $( apt list 'proxmox-kernel*' 2>/dev/null | grep -oP 'proxmox-kernel-\d+\.\d+' | sort -Vu| pipemenu ) 
# ########################################################################
# proxmxox 의 알람을 telegram 으로 받고자 할때 설정 
# telegram 봇 생성후, 환경변수 설정
echo "telegram_chatid=varChatID" >> ~/go.private.env ;; echo "telegram_token=varToken" >> ~/go.private.env 
vi2 ~/go.private.env ; chmod 600 ~/go.private.env
# proxmox alert -> telegram push #########################################
export WEBHOOK_NAME="telegram_push_webhook" ENCODED_TOKEN=$(echo -n "$telegram_token" | base64) ENCODED_CHAT_ID=$(echo -n "$telegram_chatid" | base64) ENCODED_BODY=$(printf '{"text": "* PVE Alert: {{ severity }}\\nTitle: {{ title }}\\nNode: {{fields.hostname}}\\n\\n{{ message }}"}' | base64 | tr -d '\n') ENCODED_HEADER=$(echo -n "application/json" | base64)
template_edit proxmox2telegram.sh proxmox2telegram_priv.sh
template_view proxmox2telegram.sh proxmox2telegram_priv.sh
template_insert proxmox2telegram.sh /etc/pve/notifications.cfg ;; cat "$lastarg"
template_insert proxmox2telegram_priv.sh /etc/pve/priv/notifications.cfg ;; cat "$lastarg"
vi3 /etc/pve/notifications.cfg /etc/pve/priv/notifications.cfg
# 1-1 alert critical set
: critical noti ; pvesh create /cluster/notifications/matchers --name critical-matcher --match-severity warning,error --mode any --target ${WEBHOOK_NAME} --comment "Send crit_noti to Telegram_push"
# 1-2 alert all set
: all noti ; pvesh create /cluster/notifications/matchers --name all-matcher --match-severity info,notice,warning,error,unknown --mode any --target ${WEBHOOK_NAME} --comment "Send All_noti to Telegram_push"
# 2-1 alert delete
: delete ; pvesh delete /cluster/notifications/matchers/critical-matcher
# 3-1 alert view
: get ; pvesh get /cluster/notifications/matchers/critical-matcher
# fake alert 
: alert ; pvesh create /nodes/$(cat /etc/pve/.members | jq -r '.nodename')/vzdump --vmid 999999




%%% {submenu_virt}proxmox - helper script [pxh]
%%%e {submenu_virt}proxmox - helper script [pxh]
%% vmslistview|cgrep3136 running
# https://community-scripts.github.io/ProxmoxVE/scripts
# Proxmox VE Post Install
bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/post-pve-install.sh)"
# Proxmox Backup Server Post Install
bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/post-pbs-install.sh)"
# Proxmox All template - LXC container create in proxmox
bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/addon/all-templates.sh)"
#
# Nginx Proxy Manager LXC IP:81 username admin@example.com password changeme
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/nginxproxymanager.sh)"
# WireGuard LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/wireguard.sh)"
# Home Assistant OS VM IP:8123
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/vm/haos-vm.sh)"
# Docker LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/docker.sh)"
# Transmission LXC (BitTorrent client) user/password transmission IP:9091/transmission
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/transmission.sh)"
# TurnKey File Server LXC (SMB, SFTP, NFS, WebDAV and rsync)
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-fileserver.sh)"
# TurnKey Nextcloud LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-nextcloud.sh)"
# TurnKey OpenVPN LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-openvpn.sh)"
# TurnKey Torrent Server LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-torrentserver.sh)"
# TurnKey Wordpress LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-wordpress.sh)"
# 
# install
yyay qemu-guest-agent__bsdextrautils__curl__wget__vim
systemctl start qemu-guest-agent || /etc/init.d/qemu-ga start





%%% {submenu_virt}proxmox vm - backup server [pbs]
%%%e {submenu_virt}proxmox vm - backup server [pbs]
# pbs install ( proxmox-backup-server on new vm/ct(debian11.base) )
# https://pangkin.me/proxmox-backup-server-lxc/
wget https://enterprise.proxmox.com/debian/proxmox-release-bullseye.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bullseye.gpg
echo "deb http://download.proxmox.com/debian/pbs bullseye pbs-no-subscription" >> /etc/apt/sources.list
apt update && apt upgrade -y
apt install -y proxmox-backup 
reboot
# backup-server Removes sub..
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/misc/post-pbs-install.sh)"
# pbs boot after - backup storage mount
#
# nfs mount
apt install -y nfs-common
mkdir -p /data/PBS_NFS ; chown backup:backup /data/PBS_NFS ; chmod 775 /data/PBS_NFS
#mount <NFS_SERVER_IP>:<NFS_SERVER_PATH> /data/PBS_NFS
mount varNFSIP:varNFSpath /data/PBS_NFS
df -h ;; explorer /data/
# boot mount (fstab)
#echo "<NFS_SERVER_IP>:<NFS_SERVER_PATH> /data/PBS_NFS nfs defaults 0 0" >> /etc/fstab
echo "# varNFSIP:varNFSpath /data/PBS_NFS nfs defaults 0 0" >> /etc/fstab && vi2 /etc/fstab
#
# smb mount 비밀번호에 특수기호 없는 smb 전용계정 생성 
apt install -y smbclient keyutils cifs-utils 
mkdir -p /data/PBS_SMB ; chown backup:backup /data/PBS_SMB ; chmod 775 /data/PBS_SMB
mount -t cifs -o "username=varSMBusername,password=varSMBpassword" "//varSMBhost/varRDIR/" /data/PBS_SMB
df -h ;; explorer /data/
# smb fstab add
echo "# //varSMBhost/varRDIR/ /data/PBS_SMB cifs credentials=/root/.smbcredentials,noperm,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab
echo -e "username=varSMBusername\npassword=varSMBpassword" >> /root/.smbcredentials && vi2 /root/.smbcredentials
# https://pbs.proxmox.com/docs/storage.html
proxmox-backup-manager disk list
# datastore create / 시간지연 screen/tmux 에서 작업 / 완료시 telegram push
df ;; date ; time proxmox-backup-manager datastore create varDataStoreName varPath ; push
proxmox-backup-manager datastore show varDataStoreName
# 기존 운영중인 datastore path 가 있는 경우 재연결 (PBS 재설치시)
# 기존 운영중인 datastore 제거시 아래 cfg 파일에서 삭제
vi2 /etc/proxmox-backup/datastore.cfg
cat /etc/proxmox-backup/datastore.cfg | push
# webgui
systemctl restart proxmox-backup-proxy ; systemctl status proxmox-backup-proxy
systemctl status proxmox-backup-proxy




# not use
storage="$( for storage in $(pvesm status | awk '/active/ {print $1}'); do pvesm list $storage | grep -q images && echo $storage; done | sort -u )" ; [ -z "$storage" ] && storage="$(pvesm status | awk '/active/ {print $1}')" ; export storage="$storage" ; echo -n "storage scaned: $storage" ; echo


%%% {submenu_virt}proxmox vm - win11 [win11]
%%%e {submenu_virt}proxmox vm - win11 [win11]
%% echo -n "vmid: $VMID / storage:" ; echo $storage
%% cat /proc/cmdline
vmslistview ;; export VMID="varVMID" VMNAME="varName__win11__win11-gpu-passthrough" CORES="varCore__4" SOCKETS="1" MEMORY="varMEM__8192" DISK_SIZE="varSize__250G" BRIDGE="vmbr0"  
: find iso ; find /mnt/pve /var/lib/vz/template/iso -name "*.iso" |cgrep1 win Win WIN virtio ;; export WIN_ISO_PATH="varPath_WinISO" VIRTIO_ISO_PATH="varPath_VirtIO" ;; export WIN_ISO_PATH1=$(echo $WIN_ISO_PATH | sed 's|/template.*||') WIN_ISO_PATH2="$( basename $WIN_ISO_PATH)" VIRTIO_ISO_PATH1=$(echo $VIRTIO_ISO_PATH | sed 's|/template.*||') VIRTIO_ISO_PATH2=$( basename $VIRTIO_ISO_PATH) ; echo "WIN_ISO_PATH:$WIN_ISO_PATH WIN_ISO_PATH1:$WIN_ISO_PATH1 // VIRTIO_ISO_PATH:$VIRTIO_ISO_PATH VIRTIO_ISO_PATH1:$VIRTIO_ISO_PATH1" ; read WIN_STORAGE_ID WIN_SHARE_NAME < <(pvesh get /storage --output-format json | jq -r --arg path_val "$WIN_ISO_PATH1" '.[] | select(.path == $path_val) | "\(.storage) \(.share)"' ) ; echo "{WIN_STORAGE_ID}:${WIN_STORAGE_ID} // {WIN_SHARE_NAME}:${WIN_SHARE_NAME}" ; read VIRTIO_STORAGE_ID VIRTIO_SHARE_NAME < <(pvesh get /storage --output-format json | jq -r --arg path_val "$VIRTIO_ISO_PATH1" '.[] | select(.path == $path_val) | "\(.storage) \(.share)"' ) ; echo "{VIRTIO_STORAGE_ID}:${VIRTIO_STORAGE_ID} // {VIRTIO_SHARE_NAME}:${VIRTIO_SHARE_NAME}" ; export WIN_STORAGE_ID WIN_SHARE_NAME VIRTIO_STORAGE_ID VIRTIO_SHARE_NAME
: vm storage ; export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo ; export STORAGE_POOL=$( echo "$storage" | pipemenu )
# 1. VM 생성 (기본 틀 잡기) // intel(n100->i440fx)
: create vm ;qm create ${VMID} --name ${VMNAME} --ostype win11 --sockets ${SOCKETS} --cores ${CORES} --cpu host --memory ${MEMORY} --balloon 0 --net0 e1000,bridge=${BRIDGE},firewall=1 --bios ovmf --machine pc-q35-9.2+pve1 --scsihw virtio-scsi-single
: cpu ; qm set ${VMID} --cpu host,hidden=1,flags=+pcid
# 2. 빈 디스크 추가 (설치 공간)
pvesm alloc ${STORAGE_POOL} ${VMID} vm-${VMID}-disk-0 ${DISK_SIZE} ; qm set ${VMID} --scsi0 ${STORAGE_POOL}:vm-${VMID}-disk-0,discard=on,iothread=1,ssd=1
# 3. CD/DVD 드라이브 설정 (Windows ISO, VirtIO ISO)
qm set ${VMID} --ide2 ${WIN_STORAGE_ID}:${WIN_SHARE_NAME}/${WIN_ISO_PATH2},media=cdrom
qm set ${VMID} --ide3 ${VIRTIO_STORAGE_ID}:${VIRTIO_SHARE_NAME}/${VIRTIO_ISO_PATH2},media=cdrom
qm set ${VMID} --vga memory=64 # 또는 --vga std,memory=32
# 4. (선택 사항) TPM/EFI 추가
qm set ${VMID} --tpmstate0 ${STORAGE_POOL}:1,version=v2.0
qm set ${VMID} --efidisk0 ${STORAGE_POOL}:1,format=raw,efitype=4m,size=4M,pre-enrolled-keys=1
# 5. (선택 사항) 부팅 순서 설정 (CD-ROM 우선)
: cd boot ; qm set ${VMID} --boot order='ide2;scsi0'
: os boot ; qm set ${VMID} --boot order='scsi0;ide2'
vm ${VMID} start
# 6.1 디스플레이 설정 (Passthrough 용) - win 설치가 완료된 후, rdp 설정후 display 교체 
: n100-12th-gpu-passthrough set? ; export IGPU_PCI_ID="0000:00:02.0" AUDIO_PCI_ID="0000:00:1f.3" ; qm set ${VMID} --vga none
qm set ${VMID} --hostpci0 ${IGPU_PCI_ID%.0},pcie=1,x-vga=1
: or with rom ; qm set ${VMID} --hostpci0 ${IGPU_PCI_ID%.0},pcie=1,x-vga=1,romfile="i915ovmf.rom"
qm set ${VMID} --args "-cpu host,kvm=off,+invtsc"
# 6.2 SR-IOV (가상 gpu 선택) - win 설치가 완료된 후, rdp 설정후 교체
qm set ${VMID} --hostpci0 ${IGPU_PCI_ID%.0}.varNum__1__2__3__4__5__6__7,pcie=1,x-vga=1
vm ${VMID} varS__confe__conf__start__stop__status



qm set ${VMID} --hostpci0 ${IGPU_PCI_ID},romfile='gen12_igd.rom' -set device.hostpci0.x-igd-opregion=on
qm set ${VMID} --hostpci1 ${AUDIO_PCI_ID},romfile='gen12_gop.rom'
: vga.rom save ; cd "/sys/devices/pci0000:00/0000:$(lspci | grep -i vga | awk 'NR==1 {print $1}')" ; echo 1 > rom ; cat rom > /usr/share/kvm/GPU.rom ; echo 0 > rom ; ls -al /usr/share/kvm/GPU.rom
: vga.rom download -n100; wget -O /usr/share/kvm/gen12_gop.rom https://github.com/gangqizai/igd/blob/main/gen12_gop.rom ; wget -O /usr/share/kvm/gen12_igd.rom https://github.com/gangqizai/igd/blob/main/gen12_igd.rom
qm create ${VMID} --name ${VMNAME} --ostype win11 --sockets ${SOCKETS} --cores ${CORES} --cpu host --memory ${MEMORY} --balloon 0 --net0 e1000,bridge=${BRIDGE},firewall=1 --bios ovmf --machine pc-i440fx-9.0 --scsihw virtio-scsi-single
: del ; pvesm free ${STORAGE_POOL}:vm-${VMID}-disk-0
echo "pvesm alloc ${STORAGE_POOL} ${VMID} vm-${VMID}-disk-0 ${DISK_SIZE}"




%%% {submenu_virt}proxmox vm - xpenology nas [nas]
%%%e {submenu_virt}proxmox vm - xpenology nas [nas]
%% echo -n "vmid: $newvmid / storage:" ; echo $storage
vmslistview | cgrep1 running
# vm create (cli or gui)
vmslistview ;; export newvmid="varVMID"
qm create $newvmid --name varVMname__nas --ostype l26 --memory 4096 --net0 virtio,bridge=vmbr0 --sockets 1 --cores 4 --kvm 1 --machine q35 --scsihw virtio-scsi-single ; qm list | cgrepl varVMname__nas
# arpl boot loader download https://github.com/wjz304/arpl-i18n/releases
export release_info=$(curl -L --silent "https://api.github.com/repos/wjz304/arpl-i18n/releases/latest") ; export download_url=$(echo "$release_info" | jq -r '.assets[] | select(.name | contains("4GB") and contains("img.zip")) | .browser_download_url') ; echo "release_info: $release_info download_url:$download_url" | courl
cd /var/lib/vz/template/iso ; wget -O arpl.img.zip $download_url ; unzip arpl.img.zip ; rm -f arpl.img.zip ; ls -al /var/lib/vz/template/iso ; export img=arpl.img
# or tcrp boot loader download https://github.com/PeterSuh-Q3/tinycore-redpill/releases
export release_info=$(curl -L --silent "https://api.github.com/repos/PeterSuh-Q3/tinycore-redpill/releases/latest") ; export download_url=$(echo "$release_info" | grep "browser_download_url" | grep "img.gz" | awk -F '"' '{print $4}') ; echo "release_info: $release_info download_url:$download_url" | courl
cd /var/lib/vz/template/iso ; wget -O tcrp.img.gz $download_url ; gunzip tinycore.img.gz ; ls -al /var/lib/vz/template/iso ; export img=tcrp.img
#
# vm disk create 
# storage check
export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo
# vm disk 1 boot, 6 data (max6)
qm importdisk $newvmid /var/lib/vz/template/iso/$img $( echo "$storage" | pipemenu )
qm set $newvmid --ide0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=ide0
qm set $newvmid --varSTG__sata0__sata1__sata2__sata3__sata4__sata5__sata6 $(echo "$storage" | pipemenu):varSIZE__250__500__1000 ; qm config $newvmid 
#
# start 
qm config $newvmid ;echo; qm status $newvmid
qm start $newvmid
#
# hdd detach
qm config $newvmid ;; qm set $newvmid --satavarNUM none
# boot hdd resize ( max 16G )
lvextend -L+'varSIZE__15'G $(find /dev/ -name vm-$newvmid-disk-0) && resize2fs $(find /dev/ -name vm-$newvmid-disk-0)
# boot loader img delete 
rm -f /var/lib/vz/template/iso/$img
# vm delete (if failed / test / unused)
qm stop $newvmid
!!! qm stop $newvmid ; qm destroy $newvmid




%%% {submenu_virt}proxmox vm - opnsense firewall [opn]
%%%e {submenu_virt}proxmox vm - opnsense firewall [opn]
%% echo -n "vmid: $newvmid / storage:" ; echo $storage
vmslistview | cgrep1 running
# vm create (cli or gui)
vmslistview ;; export newvmid="varVMID"
qm create $newvmid --name varVMname__opnsense --ostype l26 --memory 4096 --net0 virtio,bridge=vmbr0 --sockets 1 --cores 4 --kvm 1 --machine q35 --scsihw virtio-scsi-single ; qm list | cgrepl varVMname__opnsense
# boot loader download 
cd /var/lib/vz/template/iso ; wget -O opnsense.img.bz2 https://mirror.ams1.nl.leaseweb.net/opnsense/releases/23.7/OPNsense-23.7-vga-amd64.img.bz2 ; bunzip2 opnsense.img.bz2 ; ls -al /var/lib/vz/template/iso ; export img=opnsense.img
#
# vm disk create 
# storage check
export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo
# vm disk 1 bootloader, 1 os
qm importdisk $newvmid /var/lib/vz/template/iso/$img $( echo "$storage" | pipemenu )
qm set $newvmid --ide0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=ide0
qm set $newvmid --scsi0 $(echo "$storage" | pipemenu):varSIZE__250 ; qm config $newvmid 
# vm wan/lan network add ( 브리지로 내부/외부망 분리한 경우 vmbr1 )
qm set $newvmid --net1 virtio,bridge=vmbr0
qm set $newvmid --net1 virtio,bridge=varVRIDGE__vmbr1
#
# start 
qm config $newvmid ;echo; qm status $newvmid
qm start $newvmid
# live booting 후 login -> installer/opnsense 로그인 하여 scsi0 에 설치 
# 설치후 poweroff 후 ide0 분리 (webui) 후 부팅 
# wan,lan ip 설정후 shell 진입, 방화벽 잠시 끄고 webui 접근 / 방화벽 끄기,켜기
pfctl -d
pfctl -e
#
# boot loader img delete 
rm -f /var/lib/vz/template/iso/$img
# vm delete (if failed / test / unused)
qm status $newvmid
qm ulock $newvmid 
qm stop $newvmid ; qm status $newvmid
!!! qm stop $newvmid ; qm destroy $newvmid



%%% {submenu_virt}proxmox vm - ubuntu desktop or etc [ubun]
%%%e {submenu_virt}proxmox vm - ubuntu desktop or etc [ubun]
%% echo -n "newvmid: $newvmid / img: $img / iso: $isourl /  storage:" ; echo $storage
vmslistview | cgrep1 running
# vm create (cli or gui)
vmslistview ;; export newvmid="varVMID"
qm create $newvmid --name varVMname --ostype l26 --memory varMEMm__2048__4096__8192 --sockets 1 --cores 4 --kvm 1 --machine q35 --net0 virtio,bridge=vmbr0 --scsihw virtio-scsi-single ; qm list | cgrepl varVMname
# iso download
# https://releases.ubuntu.com/noble/
# https://releases.ubuntu.com/noble/ubuntu-24.04.2-desktop-amd64.iso
# https://releases.ubuntu.com/noble/ubuntu-24.04.2-live-server-amd64.iso
export isourl="varISOurl" ; export img="$(basename "$isourl")" 
cd /var/lib/vz/template/iso ; wget --limit-rate=varSpeedLimit__5m__10m__100m -c -O $img $isourl ; ls -al /var/lib/vz/template/iso ; bell
# 다운 완료된 img 선택
export img=$( ls -1t /var/lib/vz/template/iso | pipemenu ) 
explorer /var/lib/vz/template/iso
#
# vm disk create 
# storage check
export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo
# bootloader(cdrom -> img.iso mount) // os_disk(ex.ubuntu)
qm set $newvmid --ide0 local:iso/$img,media=cdrom ; qm set $newvmid --boot order=ide0
qm set $newvmid --scsi0 $(echo "$storage" | pipemenu):varSIZE__250 ; qm config $newvmid 
# static or dhcp ip set // ex.) ip=192.168.1.100/24 gw=192.168.1.1
# img install and set ip
ip -br a | awk '$3 != "" {print $1, $3}'
qm set $newvmid --net0 virtio,bridge=varBRG__vmbr0__vmbr1__vmbr2 --ipconfig0 ip=varIP,gw=varGateway
qm set $newvmid --net0 virtio,bridge=varBRG__vmbr0 --ipconfig0 ip=dhcp
#
# start 
qm config $newvmid ;echo; qm status $newvmid
qm start $newvmid
qm $( echo start config status ulock stop | pipemenu ) $newvmid ;; qm status $newvmid
# iso install end 
qm set $newvmid --boot order=scsi0
#
# img delete 
rm -f /var/lib/vz/template/iso/$img
# vm delete (if failed / test / unused)
!!! qm stop $newvmid ; qm destroy $newvmid







%%% {submenu_virt}proxmox host - cloud init generic [pxci]
%%%e {submenu_virt}proxmox host - cloud init generic [pxci]
%% echo "tvmid: $tvmid storage: $storage"
ay cloud-init ; qm list
# type2. download the image ubuntu / debian / centos7,9 (include cloud-init)
:ubuntu ; cd /var/lib/vz/template/iso ; wget https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img
:debian ; cd /var/lib/vz/template/iso ; wget https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2
:centos7; cd /var/lib/vz/template/iso ; wget http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2
:alma9  ; cd /var/lib/vz/template/iso ; wget https://repo.almalinux.org/almalinux/9/cloud/x86_64/images/AlmaLinux-9-GenericCloud-latest.x86_64.qcow2
# create a new VM with VirtIO SCSI controller
qm list ;; export tvmid=varNewTemplateID__9000
qm create $tvmid --name varVmName --memory 4096 --net0 virtio,bridge=vmbr0 --scsihw virtio-scsi-pci
# cloud-init 저장할 storage 선택
export storage=$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' |pipemenu) 
# import the downloaded disk to the storage, attaching it as a SCSI drive
qm set $tvmid --scsi0 $storage:0,import-from=$( find /var/lib/vz/template/iso/ -type f | pipemenu ) 
qm set $tvmid --ide2 $storage:cloudinit
qm set $tvmid --boot order=scsi0
qm set $tvmid --serial0 socket --vga serial0
qm set $tvmid --ipconfig0 'ip=dhcp'
# 설정값 출력
qm cloudinit dump $tvmid user
qm template $tvmid
#
# template -> full_clone -> init set (gui or cli)
export vmid=varNewVMID
qm clone $tvmid $vmid --name varVMname
qm set $vmid --sshkey ~/.ssh/id_rsa.pub
qm set $vmid --ipconfig0 'ip=varIP/24,gw=varGateway'
qm set $vmid --ciuser varUser__root --cipassword 'varPW' 
qm set $vmid --nameserver varNAME__168.126.63.1 
# 설정값 출력
qm cloudinit dump $vmid user


%%% {submenu_virt}proxmox host - cloud init custom [pxcc]
%%%e {submenu_virt}proxmox host - cloud init custom [pxcc]
# cloud init 지원 os 체크 (centos6.4 이상, 예전 리눅스는 지원불가)
%% echo "tvmid: $tvmid storage: $storage"
ay cloud-init ; qm list
# type1. template 로 변환할 vmid 선택
qm list ;; export tvmid=$( qm list |awk1 |pipemenu )
# clone -> template chg (원본 vmid 유지희망시)
qm clone $tvmid varNewTemplateID__9000 ; export tvmid=varNewTemplateID__9000
# cloud-init 저장할 storage 선택
export storage=$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' |pipemenu) 
# 
qm set $tvmid --name varVmName
qm set $tvmid --ide2 $storage:cloudinit
qm set $tvmid --boot order=scsi0
qm set $tvmid --serial0 socket --vga serial0
qm set $tvmid --ipconfig0 'ip=dhcp'
# 
qm set $tvmid --sshkey $HOME/.ssh/id_rsa.pub
qm set $tvmid --ciuser varUser__root --cipassword 'varPW' 
qm set $tvmid --nameserver varNAME__168.126.63.1 
# 설정값 출력
qm cloudinit dump $tvmid user
qm template $tvmid




%%% {submenu_virt}proxmox host - backup/restore/vnc [pxb]
%%%e {submenu_virt}proxmox host - backup/restore/vnc [pxb]
# 하드웨어 문제로 host 재설치시 복구진행
# /var/lib/pve-cluster/config.db 백업해둔것으로 복구
# 상시 백업및 안전한 위치에 복사  
cp -a /var/lib/pve-cluster/config.db /var/lib/pve-cluster/config.db.bak.$(datetag2) ; ls -al /var/lib/pve-cluster/
cp -a /etc/pve /etc/pve.bak.$(datetag2) ; ls -al /etc/ | grep "pve"
# proxmox install && restore
cp -a /etc/pve /etc/pve.bak
cp -a varPathetcpve /etc/
systemctl stop pve-cluster
cp /var/lib/pve-cluster/config.db /var/lib/pve-cluster/config.db.bak
cp varPathConfig.db /var/lib/pve-cluster/
systemctl start pve-cluster
# vm data 마운트
# 
# proxmox host backup script 
# https://github.com/DerDanilo/proxmox-stuff
wget -O $HOME/prox_config_backup.sh https://raw.githubusercontent.com/DerDanilo/proxmox-stuff/master/prox_config_backup.sh
sed -i 's|^DEFAULT_BACK_DIR=.*|DEFAULT_BACK_DIR="varBackupPATH"|g' $HOME/prox_config_backup.sh
vi2 $HOME/prox_config_backup.sh
bash $HOME/prox_config_backup.sh
echo "59 22 * * 0 root $HOME/prox_config_backup.sh" >> /etc/crontab ; vi2 /etc/crontab
# restore script
wget -O $HOME/prox_config_restore.sh https://raw.githubusercontent.com/DerDanilo/proxmox-stuff/master/prox_config_restore.sh
vi2 $HOME/prox_config_restore.sh
ls -altr $( cat $HOME/prox_config_backup.sh | grep 'DEFAULT_BACK_DIR=' | awk -F'=' '{print $2}' |sed -e 's/"//g' )
bash $HOME/prox_config_restore.sh varBackupFilePath
#
# vnc server
ay tigervnc-standalone-server 
vncpasswd
# xwindow check & install 
ls /usr/bin/*wm ; ls /usr/share/xsessions/
ay $( echo mate-desktop-environment-core xfce4 dbus-x11 | pipemenu )
# select installed x-session 
tigervncserver -xstartup /usr/bin/mate-session -geometry 1280x800 -localhost no :1
tigervncserver -xstartup /usr/bin/startxfce4 -geometry 1280x800 -localhost no :1
tigervncserver -xstartup /usr/bin/xterm -geometry 1280x800 -localhost no :1
tigervncserver -kill :1
# browser install
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 
dpkg -i google-chrome-stable_current_amd64.deb && apt install -f 
google-chrome --no-sandbox
# x disable (vnc 안쓸때 부하 감소)
systemctl list-unit-files --type=service | grep dm.service
systemctl disable --now lightdm




%%% {submenu_virt}proxmox host - recover deleted vm [pxr]
%%%e {submenu_virt}proxmox host - recover deleted vm [pxr]
%% echo "vmid: $vmid vg: $vg"
# /etc/lvm/archive/*.vg /etc/pve/qemu-server/vm-*.conf
# lvm metadata 는 /etc/lvm/archive/*.vg 의 최근 백업 파일에서 복구, /etc/ 백업에서 vm-*.conf 를 복구
# recover vm name set ex) vm-105
lvs ;; vmid=varVMID__105 ; export vmid="vm-$vmid" ; export vg=$( lvs |grep $vmid|awk '{print $2}' |head -n1)
# vgcfgrestore list
vgcfgrestore --list $vg
cd /etc/lvm/archive ; ls -lt 
# 삭제한 당일 즉시 적당한 복구 파일 선택 ex) vgname_00160-955052724.vg
vgfile=varVGfile 
#
# recover 전 백업 
vgcfgbackup varVGname -f /backup/vgcfg.backup.$(datetag2).vg
vi2 $( ls -1 /backup/vgcfg.backup.*.vg | pipemenu ) 
# has unexpected transaction id *** error 발생시 현재꺼 백업후 vi 수정후 복구 
vgcfgrestore -f $( ls -1 /backup/vgcfg.backup.*.vg | pipemenu ) varVGname --force
#
# recover test - last backup file or specified file
vgcfgrestore --test $vg
vgcfgrestore --test -f $vgfile $vg
# recover force 
vgcfgrestore $vg --force
vgcfgrestore -f $vgfile $vg --force
# inactive 복구 lvm 체크
pvs;echo;vgs;echo;lvs
lvscan 
# inactive -> active
lvscan | grep inactive | awk '{print $2}' | tr -d "'" | xargs -I {} lvchange -ay {}
# (주의) 복구 실패 lvremove
!!! lvscan ; readx ; lvscan | grep inactive | awk '{print $2}' | tr -d "'" | xargs -I {} lvremove {}
#
# 생성/삭제/복구 샘플
vgcfgbackup varVGname -f /backup/vgcfg.backup.$(datetag2).vg
lvs ;; export vg=$(lvs|tail -n1|awk '{print $2}'); pool=$(lvs|tail -n1|awk '{print $5}'); echo "vg: $vg, thin-pool: $pool" 
lvcreate -n lvtest1 -L 1G $vg ; lvs | cgrep1 lvtest1
lvcreate -V 1G -T $vg/$pool -n lvtest1 ; lvs | cgrep1 lvtest1
lvremove /dev/$vg/lvtest1 ; lvs
vgcfgrestore $vg ; lvs
vgcfgrestore $vg --force ; lvs
# 복구가 되지 않은 경우 파일 탐색후 지정 
cd /etc/lvm/archive ; ls -lt
for i in $( ls -1tr|tail -n10 ) ; do echo $i ; grep "varTEXT__lvtest1" $i ;done
vi2 $( ls -1tr|tail -n10 |pipemenu ) 
vgcfgrestore -f varVGfile $vg --force ; lvs
lvscan
lvchange -ay $vg/lvtest1
# device-mapper: reload ioctl on (253:29) failed -> 복구불가
# thin volume 은 대부분 복구가 불가능한 것으로 추정




%%% {submenu_virt}proxmox host - tailscale vpn server [pxt]
%%%e {submenu_virt}proxmox host - tailscale vpn server [pxt]
# WireGuard를 기반으로 한 VPN 서비스 
# proxmox 설치 네트워크에 외부 접근 용이
curl -fsSL https://pkgs.tailscale.com/stable/debian/buster.noarmor.gpg | tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null
echo "deb [signed-by=/usr/share/keyrings/tailscale-archive-keyring.gpg] https://pkgs.tailscale.com/stable/debian bookworm main" | tee /etc/apt/sources.list.d/tailscale.list
apt update ; ay tailscale
tailscale up
# 내부 네트워크 확인 (ex. 192.168.100.0/24)
route -n |cip
tailscale up --advertise-routes=192.168.100.0/24 --accept-routes=192.168.100.0/24 --snat-subnet-routes=false
iprange=$( route -n | awk '$3 == "255.255.255.0" {print $1 "/24"}' | pipemenu ) ;; tailscale up --advertise-routes=$iprange varIPrange --accept-routes=$iprange --snat-subnet-routes=false
# Tailscale 인증 URL이 출력되면 브라우저에서 접속하여 Proxmox 호스트를 Tailscale 계정에 인증
# (https://login.tailscale.com/admin/machines)에 접속 Proxmox 노드의 "라우팅 설정" 탭이동
# "서브넷 라우팅 활성화" 스위치 on
#
vi2 /etc/sysctl.conf
echo 'net.ipv4.ip_forward = 1' | tee -a /etc/sysctl.conf
echo 'net.ipv6.conf.all.forwarding = 1' | tee -a /etc/sysctl.conf
sysctl -p /etc/sysctl.conf
#
tailscale status
tailscale ping varIP


%%% {submenu_virt}proxmox host - dhcp server [pxd]
%%%e {submenu_virt}proxmox host - dhcp server [pxd]
%% echo "iprange: $iprange vmbrN: $vmbrN"
# linux bridge vmbrN[1-9] 생성 (webgui or cli) NAT # vmbr0 와 다른 아이피 대역 선택 
# vm 에서 네트워크 vmbrN 을 선택하면 NAT 환경의 dhcp 자동 할당된 ip 획득  
cp -a /etc/network/interfaces /etc/network/interfaces.backup
iprange24=$( echo 10.0.0 10.0.1 10.0.2 192.168.0 192.168.10 192.168.100 | pipemenu ) ; iprange="${iprange24}.1/24"
iprange24=varNetworkID__192.168.0 ; iprange="${iprange24}.0/24"
vmbrN=varVmbrN__vmbr9
echo -e "auto $vmbrN\niface $vmbrN inet static\n     address $iprange\n     bridge-ports none\n     bridge-stp off\n     bridge-fd 0\n" >> /etc/network/interfaces
# NAT 설정 vmbr0 <-> vmbrN 통신 가능하도록 
echo -e "post-up echo 1 > /proc/sys/net/ipv4/ip_forward\npost-up   iptables -t nat -A POSTROUTING -s '$iprange' -o vmbr0 -j MASQUERADE\npost-down iptables -t nat -D POSTROUTING -s '$iprange' -o vmbr0 -j MASQUERADE\n" >> /etc/network/interfaces
vi2 $( ls -1 /etc/network/interfaces* | pipemenu1 )
diff /etc/network/interfaces.backup /etc/network/interfaces
# 네트워크 먹통 대비 복구 가능한 스크립트로 네트워크 재시작
declare -f rrnet
!!! rrnet yes
!!! systemctl restart networking 
#
# nat 하부 포트 포워딩 (ssh 2222/ wireguard 51820)
echo -e "post-up   iptables -t nat -A PREROUTING -i vmbr0 -p tcp --dport 2222 -j DNAT --to varVMIP:22\npost-down iptables -t nat -D PREROUTING -i vmbr0 -p tcp --dport 2222 -j DNAT --to varVMIP:22\n" >> /etc/network/interfaces
echo -e "post-up   iptables -t nat -A PREROUTING -i vmbr0 -p udp --dport 51820 -j DNAT --to varVMIP:51820\npost-down iptables -t nat -D PREROUTING -i vmbr0 -p udp --dport 51820 -j DNAT --to varVMIP:51820\n" >> /etc/network/interfaces
# NAT table 설정 체크 
iptables -t nat -L -n -v
iptables-save -t nat 
GREEN=$(tput setaf 6);RESET=$(tput sgr0);iptables-save -t nat | awk -v green="$GREEN" -v reset="$RESET" '/^-A/ {print $0; gsub("-A", "-D"); print green "iptables -t nat " $0 reset}'
#
# dhcp install 
ay isc-dhcp-server
echo "INTERFACESv4=\"$vmbrN\"" >> /etc/default/isc-dhcp-server
vi2 /etc/default/isc-dhcp-server
# ip range select 
template_view dhcp.yml 
template_copy dhcp.yml /etc/dhcp/dhcpd.conf.new 
vi2 /etc/dhcp/dhcpd.conf.new
vi2 /etc/dhcp/dhcpd.conf
cp -a /etc/dhcp/dhcpd.conf.new /etc/dhcp/dhcpd.conf
#
systemctl restart isc-dhcp-server ; systemctl status isc-dhcp-server
systemctl status isc-dhcp-server
# dhcp 서버가 구동된후 # dhcp 서버를 쓸 vm 의 네트워크 브릿지를 vmbrN 로 변경 (webgui)



%%% {submenu_virt}proxmox host - open-vswitch [ovs]
%%%e {submenu_virt}proxmox host - open-vswitch [ovs]
# install
ay openvswitch-switch
brctl show
# bridge cre
ovs-vsctl add-br varBRIDGE__ovsbr0
ovs-vsctl del-br varBRIDGE
ip l | cgrep DOWN | cgrep1 UP | cip
# 원격작업시 서버 다운될수 있으니 주의 
# webgui 에서 설정하여 오류 점검 
!!! ip l ;; ovs-vsctl add-port varBRIDGE varInterface ;pp; [ $(pingcheck) == "n" ] && for i in $( ovs-vsctl list-ports varBRIDGE ) ; do echo $i ; ovs-vsctl del-port varBRIDGE $i ; done ; [ $(pingcheck) == "n" ] && systemctl restart networking.service
!!! ip l ;; ovs-vsctl del-port varBRIDGE varInterface
# monitor
ovs-vsctl show
ovs-vsctl list-br
ovs-vsctl list bridge
ovs-vsctl list-ports varBRIDGE
ovs-vsctl list port
ovs-ofctl show varBRIDGE
ovs-ofctl dump-flows varBRIDGE
# start/stop
systemctl enable --now openvswitch-switch
systemctl disable --now openvswitch-switch
systemctl status openvswitch-switch





%%% {submenu_virt}proxmox (vmware.vmdk) to (proxmox) migration [mig]
%%%e {submenu_virt}proxmox (vmware.vmdk) to (proxmox) migration [mig]
%% echo -n "vmid: $newvmid / storage: $storage / vmdk: $vmdk" ; echo 
vmslistview | cgrep1 running
# vm create (cli or gui)
vmslistview ;; export newvmid="varVMID"
qm create $newvmid --name varVMname --ostype l26 --memory 4096 --net0 virtio,bridge=vmbr0 --sockets 1 --cores 4 --kvm 1 --machine q35 --scsihw virtio-scsi-single ; qm list | cgrepl varVMname
#
# storage check
export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo
#
# vmdk exported vmware 이미지 가져오기
# proxmox webui 의 storage - ISO 이미지 업로드 기능을 이용하여 vmdk 확장자에 .iso
# 를 추가하여 웹으로 업로드 가능. /var/lib/vz/template/iso/*.vmdk 기준
cd /var/lib/vz/template/iso ; ls -al 
export vmdk=$( find /var/lib/vz/template/iso -type f -regex ".*\.\(img\|iso\|vmdk\)$" |pipemenu ) 
export vmdk=varVmdkPATH 
# importdisk vmdk -> raw -> device-mapper
qemu-img convert -f vmdk -O raw $vmdk - | qm importdisk $newvmid - $(echo "$storage" | pipemenu)
# disk -> vm에 붙이기 (scsi or sata or ide 선택)
qm set $newvmid --scsi0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=scsi0
qm set $newvmid --sata0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=sata0
qm set $newvmid --ide0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=ide0
#
# start
qm config $newvmid ;echo; qm status $newvmid
qm start $newvmid
#
# import hdd size-up
lvextend -L+'varSIZE'G $(find /dev/ -name vm-$newvmid-disk-0) && resize2fs $(find /dev/ -name vm-$newvmid-disk-0)
#
# import 후 vmdk 원본 삭제 
rm -f $vmdk
#
# vm delete (if failed / test / unused)
qm stop $newvmid
!!! qm stop $newvmid ; qm destroy $newvmid



%%% {submenu_virt}kvm hypervisor [kvm]
%%%e {submenu_virt}kvm hypervisor [kvm]
# kvm support check cpu
# nested vm -> proxmox hypervisor vm -> (cpu-var 'host' select)
egrep -c '(vmx|svm)' /proc/cpuinfo
# virt install
!!! yy qemu-kvm libvirt virt-install bridge-utils qemu-guest-agent
!!! ay qemu-kvm libvirt-daemon-system libvirt-daemon virtinst bridge-utils libosinfo-bin
!!! yum groupinstall -y virtualization-client virtualization-platform virtualization-tools
# daemon
systemctl enable --now libvirtd ; systemctl status libvirtd
lsmod | grep -i kvm
# virt-install centos7
# 기본 NAT 네트워크 환경 -> Bridge 네트워크로 변경하여 설치 (vnc 접근 용이)
ipa;;virt-install --name centos7 --ram 2048 --disk path=/var/lib/libvirt/images/centos7.img,size=20 --vcpus 2 --os-variant centos7.0 --network bridge=varBRG__virbr0 --graphics none --console pty,target_type=serial --location 'http://mirror.kakao.com/centos/7/os/x86_64/' --extra-args 'console=ttyS0,115200n8 serial' 
# basic installed -> template copy
virt-clone --original centos7 --name template --file /var/lib/libvirt/images/centos7.template.img
# virt-install debian12
ipa;;virt-install --name debian12 --ram 4096 --disk path=/var/lib/libvrit/images/debian12.img,size=20 --vcpus 2 --os-variant debian11 --network bridge=varBRG__virbr0 --graphics none --console pty,target_type=serial --location 'http://deb.debian.org/debian/dists/bookworm/main/installer-amd64' --extra-args 'console=ttyS0,115200n8 serial' 
# list / start / shutdown / poweroff
virsh list --all
virsh list --all ;; virsh start $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu )
virsh list --all ;; virsh start $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu ) --console
virsh list --all ;; virsh console $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu )
virsh list --all ;; virsh shutdown $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu )
virsh list --all ;; virsh destroy $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu )
# vm remove 
!!! virsh undefine varVM ; rm /var/lib/libvirt/images/varVM\.img
explorer /var/lib/libvirt/images/
# img resize
cd /var/lib/libvirt/images ; ls -al
qemu-img resize varIMG.qcow2 + "varSIZE"G
#
ip addr show varBRG
# swap off
!!! swapoff -a && sed -i '/swap/s/^/#/' /etc/fstab




%%% {submenu_com}Logical Volume Manager [lvm]
%%%e {submenu_com}Logical Volume Manager [lvm]
%% echo -n "sdx:$sdx // HDD: " ; lsblk -d -n -o name | oneline
# 물리 Disk 장착후 
fdisk -l 
# 파티션 생성후 type LVM 타입으로 변경 8e 
lsblk -n -o maj:min,type,name | awk '$2 ~ /^(disk|part)$/ {print }'
: sdx set ; sdx=$( lsblk -n -o maj:min,type,name | awk '$2 ~ /^disk$/ {print $3}' |pipemenu) ;; export $sdx 
echo $sdx ; fdisk -l /dev/$sdx ;; parted -s /dev/$sdx print
# 파티션 정보 백업 (새디스크는 불필요)
sfdisk -d /dev/$sdx > ~/$sdx.partition_table.txt ;; cat ~/$sdx.partition_table.txt | cpipe
# 파티션 생성 (mbr or gpt lvm) - 파티션1번 생성후 lvm 지정 (fdisk t->8e)
!!!: fdisk-mbr ; fdisk /dev/$sdx
!!!: parted-gpt; parted /dev/$sdx mklabel gpt ;; parted /dev/$sdx mkpart primary 0% 100% ;; parted /dev/$sdx set 1 lvm on ;; partprobe /dev/$sdx
# 물리볼륨생성 (ex. pvcreate /dev/sdb1)
!!! pvcreate /dev/${sdx}1
pvdisplay | cpipe
pvs
# 볼륨그룹생성 /dev/vgname/ (ex. vgcreate vg-homegroup /dev/sdb1 /dev/sdc1 /dev/sdd1)
pvdisplay ;; vgcreate varVGname varPVs
# 볼륨그룹확장 (현재 볼륨그룹에 새로 추가한 pv ex. /dev/sdc1 추가) 
!!! vgextend varVGname varNewPV
eval varVGScmd__vgdisplay__vgdisplay@space@-v__vgs
# 논리볼륨  생성 /dev/vgname/lvname (ex. lvcreate -n lv-homefree -L 10000G vg-homegroup)
vgs ;; lvcreate -n varLVname -L varSIZE varVGname
# LVM-Thin 프로비저닝 씬풀
vgs;lvs ;; lvcreate -L varSIZE -T varVGname/varThinPool
vgs;lvs ;; lvcreate -l 100%FREE -T varVGname/varThinPool
# LVM_Thin 논리볼륨 생성 
!!! lvcreate -V varSIZE -T varVGname/varThinPool -n varLVname
lvdisplay | cpipe | less -RX
lvs
# 마운트할경우 포맷 // mount // fstab
lsblk -f 
ls -1 /usr/sbin/mkfs*
!!! mkfs.varFtype__ext4__ext3__btrfs__xfs /dev/varVGname/varLVname 
echo "#/dev/varVGname/varLVname varMountDIR ext4 defaults 1 2" >> /etc/fstab 
vi2 /etc/fstab
# lvextend -L [+|-]새로운 크기 [M|G|T] /dev/volume_group_name/logical_volume_name
!!! s=varSIZE ; lvextend -L+${s}G varLVpath
!!! lvextend -l +100%FREE varLVpath
!!! resize2fs varLVpath
# thin-pool 사용량 체크 (vm 이 사용할 수 있는 thin 전체 용량)
lvs --noheadings --units g -o lv_name,lv_size,data_percent | awk '$2 != "0.00g" && NF==3 {u=$2*$3/100; printf "%s: %s / %.2fG / %s%%\n", $1, $2, u, $3}' | column -t
fstrim -a



%%% {submenu_virt}qemu-img os-image dump/convert [qemui]
%%%e {submenu_virt}qemu-img os-image dump/convert [qemui]
# qemu-img convert
# dd dump varDevice(ex. /dev/sda) -> varDevice.raw
dd if=varDevice of=/backup/$(basename varDevice).raw
# dd dump -> qcow2
dd if=varDevice | qemu-img convert -p -f raw -O qcow2 /dev/stdin /backup/$(basename varDevice).qcow2
# raw device -> qcow2 device ex.) /dev/vg-950/vm-101-disk-1 
qemu-img convert -p -f raw -O qcow2 varDevice /backup/$(basename varDevice).qcow2
# raw img(dd,raw,img) -> qcow2
qemu-img convert -p -f raw -O qcow2 /backup/varIMG /backup/varIMG.qcow2
# raw img(dd,raw,img) -> vmdk 
qemu-img convert -p -f raw -O vmdk /backup/varIMG /backup/varIMG.vmdk
# vmdk -> qcow2
qemu-img convert -pO qcow2 -f vmdk /backup/varVMDK /backup/varVMDK.qcow2
# 
# booting img -> import disk vm (ide0)
#
# usb 에 img 파일을 굽지 않고, ide0 에 import 하며 img live booting
# ex) qm importdisk 100 /mnt/pve/smb/template/iso/OPNsense-23.7-vga-amd64.img disk2
# ex) qm set 100 --ide0 disk2:vm-110-disk-1 ; qm set 110 --boot order=ide0
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage'
qm importdisk varVMID varIMG varSTORAGE
qm set varVMID --ide0 $(qm config varVMID | awk '$1 ~ /unused0/ {print $2}') ; qm set varMVID --boot order=ide0









%%% {submenu_virt}minecraft [mc]
%%%e {submenu_virt}minecraft [mc]
screen -ls 
# screen retach
screen -ls ;; screen -x $( screen -ls |grep tach |pipemenu1 )
# start // restart
echo "eula=true" > /root/Minecraft/eula.txt ; screen -dmS varNAME__mc /root/Minecraft/run.sh nogui ; screen -x varNAME__mc 
screen -ls ;; screen -S varNAME__mc -X quit ; screen -ls ; screen -dmS varNAME__mc /root/Minecraft/run.sh nogui && screen -x varNAME__mc
# stop // stop force // java running kill
screen -ls ;; screen -S varNAME__mc -X quit ; screen -ls
ps -ef|grep "$(basename $(readlink /root/Minecraft))"|awk '{print $2}'|xargs kill -
ps -ef|grep [j]ava|awk '{print $2}'|xargs kill 2>/dev/null ; sleep 2 ; screen -ls
# bungeecord start // restart // stop
screen -dmS bungeecord /root/bungeecord/run.sh nogui && screen -x bungeecord
screen -S bungeecord -X quit && screen -dmS bungeecord /root/bungeecord/run.sh nogui && screen -x bungeecord
screen -S bungeecord -X quit 
#
# port chg (default:25565)
sed -i -E "s/(^server-port=).*/\1varPort__25565/g" /root/Minecraft/server.properties ; cat /root/Minecraft/server.properties|grep server-port
explorer /root/$(ls -1 /root|grep Minecraft|pipemenu1 )
# 
# screen dump view
screen -S $( screen -ls |grep tach |pipemenu1 ) -X hardcopy -h /root/_screendump ; cat /root/_screendump | cip |less -RX +G ; rm -f /root/_screendump





%%% {submenu_virt}minecraft install [mci]
%%%e {submenu_virt}minecraft install [mci]
# paper server install
dir="/root/Minecraft.paper" ; link="https://api.papermc.io/v2/projects/paper/versions/1.20.1/builds/43/downloads/paper-1.20.1-43.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ -L "/root/Minecraft" ] && rm /root/Minecraft ; ln -s $dir /root/Minecraft ; [ ! -f $file ] && wget $link ; echo "java -Xms1G -Xmx10G -Djava.awt.headless=true -jar $dir/$file" > $dir/run.sh ; chmod 700 run.sh 
# 
# forge server install
dir="/root/Minecraft.forge" ; link="https://maven.minecraftforge.net/net/minecraftforge/forge/1.19.2-43.2.3/forge-1.19.2-43.2.3-installer.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ -L "/root/Minecraft" ] && rm /root/Minecraft ; ln -s $dir /root/Minecraft ; [ ! -f $file ] && wget $link ; java -jar $file  -installServer ; echo "-Xms1G -Xmx10G" > user_jvm_args.txt
# 
# bungeecord https://www.spigotmc.org/wiki/bungeecord-installation/
dir="/root/Minecraft.bungeecord" ; link="https://ci.md-5.net/job/BungeeCord/lastSuccessfulBuild/artifact/bootstrap/target/BungeeCord.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ ! -L "/root/bungeecord" ] && ln -s $dir /root/bungeecord ; [ ! -f $file ] && wget $link ; echo "java -Xms1G -Xmx1G -Djava.awt.headless=true -jar $dir/$file" > $dir/run.sh ; chmod 700 run.sh
# 
vi2 $(echo "/root/Minecraft.bungeecord/config.yml /root/Minecraft/server.properties"|pipemenu )
# java & etc install
aptupup ; yyay openjdk-17-jdk wget screen


%%% >Lamp (apache,php,mysql) [lamp]
%%%e >Lamp (apache,php,mysql) [lamp]
{submenu_lamp}
%% pstree | egrep "apache|php|maria|dovecot|ftp|postgres|master|named|httpd|imapd|mysql|proftpd|sendmail"


%%% >linux_commands & utils - find swap.. [c]
%%%e >linux_commands & utils - find swap.. [c]
{submenu_com}


%%% >proxmox / kvm / minecraft virt [v]
%%%e >proxmox / kvm / minecraft virt [v]
{submenu_virt}
%% able pvesh && vmslistview|cgrep3136 running

#%% dlines $(basename "$(readlink /etc/pve/local 2>/dev/null)" 2>/dev/null )




%%% >docker / docker compose [dk] 
%%%e >docker / docker compose [dk] 
{submenu_docker}
%% dockersvcorg | column -t 
%% able docker && dockerps=$(docker ps|awknr2 2>/dev/null) && [ "${dockerps}" ] && echo && echo "$dockerps"| maxl 20 20 0 0 0 0 0 0 0 15 15 15 0 0 0 0 0|stripe |column -t





%%% ollama local llm - gemma3 [lama]
%%%e ollama local llm - gemma3 [lama]
# install https://ollama.ai/download/linux
curl -fsSL https://ollama.ai/install.sh | sh
ollama --version ; ollama --help
# start / stop 
systemctl enable --now ollama
systemctl status ollama
systemctl disable --now ollama
# gemma3 model download && local cli exec // 4b - cpu powered llm
# model: https://ollama.com/search
ollama pull gemma3:varSIZE__4b__1b__27b__12b
# everywhere "chat or ai or hi or hello" [Enter] -> ollama run gemma3
ollama run gemma3
ollama list




%%% {submenu_hidden}nvm / nodejs [js]
%%%e {submenu_hidden}nvm / nodejs [js]
# nvm (node verison manager)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
source $HOME/.nvm/nvm.sh && nvm --version
nvm --version
# nodejs 
nvm install 14.4.0
nvm use 14.4.0
nvm ls
node -v 
# nvm set/unset
explorer $HOME/.nvm/
vi $HOME/.bashrc -c /NVM
#
#
# or system nodejs install
yyay nodejs 
node -v 
apt remove nodejs
# nodejs v14 or v20 install
apt remove nodejs libnode-dev
curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash -
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
apt-get install -y nodejs
node -v 
# npm (node package manager)
npm -v 





%%% {submenu_lamp}webmail - squirrelmail [sq]
%%%e {submenu_lamp}webmail - squirrelmail [sq]
# squirrelmail - https://squirrelmail.org
cd varWebmailDir__@@var@@www@@html
# 최신 안정 스냅샷 버전 다운로드 (2025-04-10 기준)
wget -O sq.tgz https://squirrelmail.org/countdl.php?fileurl=http%3A%2F%2Fprdownloads.sourceforge.net%2Fsquirrelmail%2Fsquirrelmail-webmail-1.4.22.tar.gz
tar xvzf sq.tgz && rm -f sq.tgz
mv squirrelmail* sq ; ls -al ; chgrp -R www-data sq ; chmod 2750 sq
cd sq ; ls -al ; readxy && ./configure
vi2 config/config.php
# OR subversion 으로 최신버젼 다운로드 
yyay subversion
svn checkout https://svn.code.sf.net/p/squirrelmail/code/branches/SM-1_4-STABLE/squirrelmail
mv squirrelmail* sq ; ls -al ; chgrp -R www-data sq ; chmod 2750 sq
cd sq ; ls -al
./configure
vi2 config/config.php
# update
cd varWebmailDir__@@var@@www@html@@sq
svn update
#
# locale 언어팩 설치 (선택)
wget -O lc.tgz https://squirrelmail.org/countdl.php?fileurl=http%3A%2F%2Fprdownloads.sourceforge.net%2Fsquirrelmail%2Fall_locales-1.4.18-20090526.tar.gz
tar xvzf lc.tgz && rm -f lc.tgz
ls -al locale
./configure
explorer varWebmailDir



%%% {submenu_com}nagios cli monitoring [na]
%%%e {submenu_com}nagios cli monitoring [na]
# HOST 의 web/ pop/ imap/ ftp/ ssh/ smtp/ mysql 데몬 구동 체크 
# debian/ubuntu
ay monitoring-plugins
for i in $( dpkg -l |grep monitoring-plugins|awk2) ;do echo;echo $i ; dline ; dpkg -L $i ; done| cgrep "check_" | less -RX
# centos
yy epel-release nagios-plugins-all
for i in $( rpm -qa|grep nagios ) ; do rpm -ql $i ; done | grep "check_"
# cp main check_*
cd /usr/lib64/nagios/plugins/ || cd /usr/lib/nagios/plugins/ ; ls -al 
mkdir -p /root/checkup/ ; cp -a check_http check_pop check_imap check_ftp check_ssh check_smtp check_mysql check_tcp check_ping check_dns check_load /root/checkup/
# 호스트별로 필요한 체크리스트만 뽑아서 softlink
# /root/checkup/yourdomain/check_you_wants
h='varHost'; mkdir -p "/root/checkup/$h"; scripts=""; PS3="Select for '$h' (num): "; select opt in $(find /root/checkup -maxdepth 1 -name 'check_*' -not -name 'check_tcp' \( -type f -o -type l \) -executable -printf "%f\n" | sort ; echo all ; echo done) ; do case $opt in done) break ;; all) scripts=$(find /root/checkup -maxdepth 1 -name 'check_*' -not -name 'check_tcp' \( -type f -o -type l \) -executable -printf "%f " | sort); scripts="${scripts% }"; echo " -> all selected"; break ;; "") echo "Invalid choice '$REPLY'" ;; *) scripts="$scripts $opt"; echo " -> added $opt" ;; esac; done ; if [[ -n "$scripts" ]]; then echo; echo "Linking selected:"; for s in ${scripts# }; do ln -sv "/root/checkup/$s" "/root/checkup/$h/$s"; done ; echo; ls -l "/root/checkup/$h/" | grep check_; else echo "No scripts selected."; fi
# mysql 모니터링 할 경우 해당 host 에 가서 user 생성 // 안할경우 tcp 3306 포트만 체크
mysql -e "CREATE USER IF NOT EXISTS 'nagios_check'@'%' IDENTIFIED BY 'pw'; GRANT USAGE ON *.* TO 'nagios_check'@'%'; FLUSH PRIVILEGES;" ; ufw allow 3306/tcp ; ufw reload 
change /etc/mysql/mariadb.conf.d/50-server.cnf "bind-address            = 127.0.0.1" "bind-address = 0.0.0.0" line
# 
# 호스트별로 선택한 체크리스트로 점검
while true; do date;  P=/root/checkup; PLUGINS=/usr/lib/nagios/plugins; GREEN='\e[1;32m'; RED='\e[1;31m\a'; YELLOW='\e[1;33m'; RESET='\e[0m'; find "$P" -mindepth 1 -maxdepth 1 -type d | while read -r host_dir; do h=$(basename "$host_dir"); printf "%-20s |" "$h"; find "$host_dir" -maxdepth 1 -type l -executable | while read -r check_link; do check_name=$(basename "$check_link"); target_host="$h"; if [[ "$check_name" == "check_mysql" ]]; then status="?"; color="$RED"; mysql_args=("-H" "$target_host" "-u" "nagios_check" "-p" "pw"); timeout 2 "$PLUGINS/check_mysql" "${mysql_args[@]}" &>/dev/null; mysql_ec=$?; if [ "$mysql_ec" -eq 0 ]; then status="OK"; color="$GREEN"; else timeout 1 "$PLUGINS/check_tcp" -H "$target_host" -p 3306 &>/dev/null; tcp_ec=$?; if [ "$tcp_ec" -eq 0 ]; then status="M(TCP)"; color="$YELLOW"; else if [ "$mysql_ec" -eq 124 ]; then status="T/O(C)"; elif [ "$mysql_ec" -eq 1 ]; then status="WARN"; elif [ "$mysql_ec" -eq 2 ]; then status="CRIT"; else status="UNK"; fi; color="$RED"; fi; fi; echo -ne " ${color}${check_name}:${status}${RESET}"; else status="?"; color="$RED"; cmd_args=(); case "$check_name" in check_load) cmd_args=("-w" "5,4,3" "-c" "10,8,6");; check_tcp) cmd_args=("-H" "$target_host");; check_ping) cmd_args=("-H" "$target_host" "-w" "100,20%" "-c" "500,60%" "-p" "1" "-t" "1");; *) cmd_args=("-H" "$target_host");; esac; "$PLUGINS/$check_name" "${cmd_args[@]}" &>/dev/null; ec=$?; case $ec in 0) status="OK"; color="$GREEN";; 1) status="WARN";; 2) status="CRIT";; *) status="UNK";; esac; echo -ne " ${color}${check_name}:${status}${RESET}"; fi; done; echo; done; echo -n ">>> Quit -> [Anykey] " ; for i in $(seq 1 57); do read -p"." -t1 -n1 x && echo && break; done ; [ "$x" ] && break ; done
explorer /root/checkup/











curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose && ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose



%%% {submenu_docker}>Docker 기본 관리 가이드 [flow_docker_basic]
%%%e {submenu_docker}>Docker Basic Management Guide [flow_docker_basic]
%% echo "Docker 설치, 컨테이너/이미지/볼륨/네트워크 기본 관리 가이드입니다."
%% echo "각 단계를 완료하고 엔터 또는 'b'를 눌러 다음 단계로 이동하세요."
#----------------------------------------------------------------------
: 1단계: Docker 설치 및 기본 설정 ; dki
:   (참고) Docker 관련 프로세스 확인 ; p
:   (참고) Docker 네트워크 확인 ; dkp
#----------------------------------------------------------------------
: 2단계: Docker 컨테이너 관리 ; dkp
:   (참고) 실행중/종료된 컨테이너 확인
:   (참고) 컨테이너 시작/중지/재시작/삭제
:   (참고) 컨테이너 로그 확인 / 접속 (exec) / 상세 정보 (inspect)
#----------------------------------------------------------------------
: 3단계: Docker 이미지 관리 ; dkp
:   (참고) 로컬 이미지 목록 확인 / 이미지 삭제 (rmi)
:   (참고) Docker Hub 이미지 검색 ; dks
:   (참고) Docker Hub 이미지 받기 (pull)
#----------------------------------------------------------------------
: 4단계: Docker 볼륨 및 데이터 관리 ; dkp
:   (참고) 볼륨 목록 확인 / 상세 정보 (inspect) / 삭제 (rm)
:   (참고) 사용하지 않는 리소스 정리 (prune) ; dki
#----------------------------------------------------------------------
: 5단계: 개별 컨테이너 실행 (docker run 예시) ; dkr
:   (예시) Portainer (웹 UI 관리 도구) 실행
:   (예시) Nginx 웹서버 실행
:   (예시) MySQL/MariaDB 데이터베이스 실행
:   (예시) WordPress 블로그 실행
:   (예시) phpMyAdmin 실행
#----------------------------------------------------------------------
: Docker 기본 관리 가이드 완료! Compose는 [flow_docker_compose] 메뉴를 참고하세요.
: 다음 단계로 이동 (Compose 메뉴) ; flow_docker_compose



%%% {submenu_docker}>Docker Compose 활용 가이드 [flow_docker_compose]
%%%e {submenu_docker}>Docker Compose Usage Guide [flow_docker_compose]
%% echo "Docker Compose 설치 확인 및 다양한 서비스 배포/관리 가이드입니다."
%% echo "각 서비스 항목 선택 시 설정 및 실행 메뉴로 이동합니다."
#----------------------------------------------------------------------
: 1단계: Docker Compose 설치 확인 ; dki
#----------------------------------------------------------------------
: 2단계: Compose 프로젝트 실행 및 관리 (서비스 선택)
# --- 웹/관리 도구 ---
:   Ansible UI (Semaphore) ; dkse
:   Nagios 모니터링 ; dkna
:   Portainer (별도 실행 권장) ; dkr
:   Nginx Proxy Manager ; dknpm
:   Traefik (리버스 프록시) ; dktf
:   Guacamole (원격 데스크톱) ; dkg
# --- 협업/CMS/클라우드 ---
:   Rocket.Chat (메신저) ; dkro
:   Rhymix CMS (Nginx/MariaDB) ; dkrm
:   WordPress + phpMyAdmin ; dkwp
:   Nextcloud (개인 클라우드) ; dkc
# --- 미디어/백업 ---
:   Immich (사진/비디오 백업) ; dkim
# --- 네트워크/유틸리티 ---
:   WireGuard VPN (wg-easy) ; dkw
:   Caddy (웹서버) ; dkca
# --- 스마트홈 ---
:   Home Assistant ; dkha
# --- 프로젝트 관리 ---
:   (도구) 파일 탐색기 (프로젝트 폴더 이동) ; ex
:   (참고) 각 프로젝트 폴더에서 docker-compose 명령어 직접 실행
#----------------------------------------------------------------------
: 3단계: 기타 Docker 관련 리눅스 명령어 ; c
:   (참고) 포트 사용 현황 확인 ; varS__p__n
:   (참고) 방화벽 포트 개방 ; fw # 위에서 만든 방화벽 선택 메뉴
:   (참고) 디스크 사용량 확인 ; f
:   (참고) 프로세스/리소스 확인 ; p
#----------------------------------------------------------------------
: Docker Compose 활용 가이드 완료! 이전 단계는 [flow_docker_basic] 메뉴를 참고하세요.
: 이전 단계로 이동 (기본 관리 메뉴) ; flow_docker_basic








%%% {submenu_docker}docker install / reset [dki]
%%%e {submenu_docker}docker install / reset [dki]
%% dockersvc
yyay apt-transport-https ca-certificates curl gnupg lsb-release
# gpg key add // repo add
: debian_gpg ;curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ; echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list ; vi2 /etc/apt/sources.list.d/docker.list
: ubuntu_gpg ;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ;echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list ; vi2 /etc/apt/sources.list.d/docker.list
# docker install
aptupup ; yyay docker.io  
# group user add
cat /etc/group|grep  "," ;; usermod -aG varGroup__docker varUser ; vi2 /etc/group
# 
# docker compose install
yyay docker-compose-plugin
curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose ; ln -s /usr/local/bin/docker-compose /usr/bin/
docker-compose --version
systemctl status docker ; docker --version
#
# docker volume / images list
docker volume ls | awknr2 | awk2
docker images | awknr2 | awk1 
# prune
!!! docker container prune
!!! docker image prune -a
!!! docker network prune
!!! docker volume prune
# docker all stop 
docker stop $( docker ps -a --filter "status=running" |awk1|awknr2 ) ; docker ps -a 
# unused all prune
!!! docker system prune -a 
# 
systemctl disable --now docker



%%% {submenu_docker}docker ps [dkp]
%%%e {submenu_docker}docker ps [dkp]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# docker ps // start // stop 
docker ps 
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker restart $( docker ps -a --filter "status=running" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
# rm
!!! docker ps -a ;; docker rm $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
# image
docker images
!!! docker image rm $( docker images | awk 'NR>1 {print $1}' | pipemenu1cancel ) ; echo ; docker images
# pull
docker pull varCTName__nginx
# volume
docker volume create varDATA__portainer_data
docker volume inspect $( docker volume ls | awknr2|awk2|pipemenu) 
!!! docker volume rm  $( docker volume ls | awknr2|awk2|pipemenu) 
cd /var/lib/docker/volumes ; explorer /var/lib/docker/volumes
# exec -it (interative tty container) 
docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varSH__bash__sh__ash
# inspect
docker ps -a ;; docker inspect $( docker ps -a --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
# top // logs
docker ps ;; docker top $( docker ps --format "{{.Names}}"|pipemenu1 )
docker ps ;; docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )
# network 
docker network ls
docker network ls ;; docker network inspect $( docker network ls | awk 'NR>1 {print $1}' | pipemenu1 ) |cip
#



%%% {submenu_docker}docker search [dks]
%%%e {submenu_docker}docker search [dks]
# stars rank docker-images
curl -s "https://hub.docker.com/v2/repositories/library/?page_size=100" |  jq -r '.results[] | [.name, .star_count, .pull_count, .description] | @tsv' | sort -k 2 -nr|  column -s $'\t' -t | stripe | less -r
docker search varSearch__nginx
docker search varSearch__ubuntu__centos__debian__wordpress__rhymix__cms
# pull image ( 1-100 )
docker pull $( curl -s "https://hub.docker.com/v2/repositories/library/?page_size=100" |  jq -r '.results[] | [.name, .star_count ] | @tsv' | sort -k 2 -nr | awk1 | pipemenu )
docker images
!!! docker image rm $( docker images | awk 'NR>1 {print $1}' | pipemenu1cancel ) ; echo ; docker images


%%% {submenu_docker}docker run [dkr]
%%%e {submenu_docker}docker run [dkr]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# portainer 
docker start portainer || docker run -d --name portainer --restart on-failure -p varWPORT__9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
# nginx
docker start nginx || mkdir -p varWebroot__@@data@@docker ; docker run -d --name nginx -p varPort__80:80 -v varWebroot:/usr/share/nginx/html nginx
# mysql 
docker start mysql || docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=varRootPW__wppass -e MYSQL_DATABASE=wp -e MYSQL_USER=wp -e MYSQL_PASSWORD=varPassword__wppass -v mysql_data:/var/lib/mysql mysql
# wordpress
docker start wordpress || docker run -d --name wp -p varPort__8888:80 --link mysql:wp -e WORDPRESS_DB_HOST=wp -e WORDPRESS_DB_USER=wp -e WORDPRESS_DB_PASSWORD=varPassword__wppass -e WORDPRESS_DB_NAME=wp -v wordpress_data:/var/www/html wordpress
# minecraft
docker start minecraft || docker run -d --name mcserver --rm -e MEMORYSIZE='varMEM__1G' -v mc_data:/data:rw -p varPort__25565:25565 -i marctv/minecraft-papermc-server:latest
# phpmyadmin ( depend on running db ) 
docker start phpmyadmin || docker run --name mypma --rm -d --link $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ):db -p varPort__3307:80 phpmyadmin/phpmyadmin
# phpmyadmin ( all host ) 
docker start phpmyadmin || docker run --name mypmaall --rm -d -e PMA_ARBITRARY=1 -p varPort__3300:80 phpmyadmin
# derkades/webdav
docker start webdav || mkdir -p varMountPath__@@data@@webdav ; docker run -d --name webdav-instance --restart=unless-stopped -v varMountPath__@@data@@webdav:/data -p varPort__8010:80 -e USERNAME=varUser__admin -e PASSWORD=varPassword__gosh derkades/webdav
# wetty web-ssh 
docker start Wetty || docker run --name Wetty -d --rm -p 3000:3000 wettyoss/wetty --ssh-host $publicip --ssh-port 22 --base
#
# upgrade docker image
: upgrade; docker ps |awk99c ;; docker pull $(docker inspect varCName__portainer --format '{{.Config.Image}}') && docker stop varCName && docker rm varCName && echo "Select ---> Docker run varCName"
# docker ps // start // stop // rm
: ps; docker ps
: start; docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
: stop; docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
: rm; docker ps -a ;; docker rm $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps



%%% {submenu_docker}docker linux [dkl]
%%%e {submenu_docker}docker linux [dkl]
%% dockersvc
# linux docker image
docker run -it ubuntu bash
docker run -it centos bash
docker run -it debian bash
docker run -it fedora bash
# node.js ...
docker run -it node bash
docker run -it python bash
docker run -it mysql bash
docker run -it redis bash
docker run -it nginx bash




%%% {submenu_docker}docker teldrive [dkt]
%%%e {submenu_docker}docker teldrive [dkt]
%% echo "tg-uploads-encryption-key: ${tguploadsencryptionkey}"
%% echo "tg-jwtsecret: ${jwtsecret}"
%% echo "tg-app-id: ${telegramappid}"
%% echo "tg-app-hash: ${telegramapphash}"
# telegram api app_id, app_hash
# https://my.telegram.org/auth?to=myapp
# 차단될 수 있으니, 주사용 telegram 아이디는 주의
# teldrive daemon 운영 희망시 --> tel [Enter]
mkdir -p varDIR__@@data@@teldrive ; cd varDIR ; ls -al
mkdir -p varDIR__@@data@@teldrive@@{teldrive_data,postgres_data} ; cd varDIR ; ls -al
explorer varDIR
# teldrive
docker network create teldrive-net
docker run -d --name postgres-db --net teldrive-net -p 5432:5432 -v ./postgres_data:/var/lib/postgresql/data -e POSTGRES_USER=teldrive -e POSTGRES_PASSWORD=password -e POSTGRES_DB=teldrive iquiw/pgroonga-on-postgres:latest
docker run -d --name teldrive -p 8080:8080 --net teldrive-net -v ./teldrive_data:/data teldrive/teldrive:latest --db-data-source "postgres://teldrive:password@postgres-db:5432/teldrive?sslmode=disable" --jwt-secret "$jwtsecret" --tg-app-id "$telegramappid" --tg-app-hash "$telegramapphash" --tg-uploads-encryption-key "$tguploadsencryptionkey"
#
docker restart teldrive
docker stop postgres-db ; docker rm postgres-db
docker stop teldrive ; docker rm teldrive 
docker logs postgres-db
docker logs teldrive
# 
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1cancel )
docker exec -it $( docker ps -a --format "{{.Names}}"|pipemenu1cancel ) varCMD__bash__sh__ash
# env
echo "tguploadsencryptionkey=$(openssl rand -hex 32)" >> ~/go.private.env
echo "jwtsecret=$(openssl rand -hex 32)" >> ~/go.private.env
echo "telegramappid=varAppID" >> ~/go.private.env
echo "telegramapphash=varAppHash" >> ~/go.private.env
source ~/go.private.env
env | sort | cpipe | less -rX




%%% {submenu_docker}docker compose lamp 1 - apache/mysql/php [dklamp]
%%%e {submenu_docker}docker compose lamp 1 - apache/mysql/php [dklamp]
%% dockersvc
%% echo "lampdir: $lampdir"
export lampdir="varLampPath__@@data@@lamp"; cd $lampdir || mkdir -p $lampdir
mkdir -p ${lampdir:-/data/lamp}/{www,db_data,backups} ; cd $lampdir
explorer ${lampdir:-/data/lamp}
# 2. docker-compose // index.php
template_edit lamp.yml dk_lamp_index.php dockerfile.php dockerfile-cms.php
template_view lamp.yml dk_lamp_index.php dockerfile.php dockerfile-cms.php
template_copy lamp.yml ${lampdir:-/data/lamp}/docker-compose.yml ; cat $lampdir/docker-compose.yml
template_copy dk_lamp_index.php ${lampdir:-/data/lamp}/www/index.php ;; cat $lampdir/www/index.php
vi3 ${lampdir:-/data/lamp}/docker-compose.yml $lampdir/www/index.php $lampdir/Dockerfile.php 
# 3. Dockerfile.php: 1 or 2
# 3-1 php-mysql 연동 /data/lamp/Dockerfile.php
template_copy dockerfile.php ${lampdir:-/data/lamp}/Dockerfile.php ;; cat $lampdir/Dockerfile.php
# or 3-2 cms 설치용 php 확장옵션 Dockerfile (mod-php8.2)
template_copy dockerfile-cms.php ${lampdir:-/data/lamp}/Dockerfile.php ;; cat $lampdir/Dockerfile.php
#
# IP:8080 web // IP:8081 phpmyadmin
nmap localhost
# mysqldump
docker exec lamp_mysql_db sh -c 'exec mysqldump --all-databases -u root -p"$MYSQL_ROOT_PASSWORD"' > /data/lamp/backups/backup_$(date +%Y%m%d_%H%M%S).sql && ls -al /data/lamp/backups/
# phpmyadmin start / stop 보안상 필요할때만 on
docker-compose varS__start__stop phpmyadmin
#
: ps; cd ${lampdir:-/data/lamp}; docker-compose ps
: up; cd ${lampdir:-/data/lamp}; docker-compose up -d --remove-orphans --build ; docker-compose stop phpmyadmin
: logs; cd ${lampdir:-/data/lamp}; docker-compose logs -f 
: sh; cd ${lampdir:-/data/lamp}; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
: down; cd ${lampdir:-/data/lamp}; docker-compose down
!!! cd ${lampdir:-/data/lamp}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )



%%% {submenu_docker}docker compose lamp 2 - cms install  [dklampc]
%%%e {submenu_docker}docker compose lamp 2 - cms install  [dklampc]
%% dockersvc
%% echo "lampdir: $lampdir"
export lampdir="varLampPath__@@data@@lamp"; cd $lampdir || mkdir -p $lampdir
cd ${lampdir:-/data/lamp} ; ls -al ;; ls -al ./www
explorer ${lampdir:-/data/lamp}
# docker lamp 가 실행된 상태에서 cms 를 www 에 다운로드 하여 서비스 
# 1. www 폴더가 docker mount 된 상태 -> www 정리 
!!! : rm www/* ; cd ${lampdir:-/data/lamp} && shopt -s dotglob && rm -rf ./www/* && shopt -u dotglob && ls -al ./www
# 2-1. cms download - rhymix - https://rhymix.org/
: download; cd www ; wget -O rhymix.zip https://rhymix.org/files/attach/releases/rhymix-2.1.22.zip
: unzip; unzip rhymix.zip && mv rhymix/* rhymix/.[a-z]* . && ls -al ./ ;; ls -al rhymix/ && rm -r rhymix && ls -al 
: perm; mkdir -p ./files && chmod -R 777 ./files && id -un 33 && chown -R 33:33 ./ && ls -al
# 2-2. cms download - gnuboard5 - https://sir.kr/g5_pds/3220
: download; cd www ; wget -O gnu.zip https://github.com/gnuboard/gnuboard5/zipball/master
: unzip; unzip gnu.zip && mv gnuboard*/* gnuboard*/.[a-z]* . && ls -al ./ ;; ls -al gnuboard*/ && rm -r gnuboard*/ && ls -al 
: perm; mkdir -p ./data && chmod -R 777 ./data && id -un 33 && chown -R 33:33 ./ && ls -al
# 2-3. cms download - wordpress - https://ko.wordpress.org/
: download; git clone --depth 1 https://github.com/WordPress/WordPress.git ./www ; cd ./wwww ; ls -al
: perm; mkdir -p ./wp-content && chmod -R 777 ./wp-content && id -un 33 && chown -R 33:33 ./ && ls -al
# db_host: "db" // db_name: "mydatabase" // db_user: "myuser" // db_pw: "mypassword"
: lynx or web; lynx http://$publicip:8080
: rm zip; rm *.zip ; ls -al
#
: ps; cd ${lampdir:-/data/lamp}; docker-compose ps
: up; cd ${lampdir:-/data/lamp}; docker-compose up -d --remove-orphans --build ; docker-compose stop phpmyadmin
: logs; cd ${lampdir:-/data/lamp}; docker-compose logs -f
: sh; cd ${lampdir:-/data/lamp}; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
: down; cd ${lampdir:-/data/lamp}; docker-compose down
!!! cd ${lampdir:-/data/lamp}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )
: docker lamp jump ; dklamp






%%% {submenu_docker}docker compose lemp nginx/mysql/php [dklemp]
%%%e {submenu_docker}docker compose lemp nginx/mysql/php [dklemp]
%% dockersvc
%% echo "lempdir: $lempdir"
export lempdir="varLempPath__@@data@@lemp"; cd $lempdir || mkdir -p $lempdir
mkdir -p ${lempdir:-/data/lemp}/{www,db_data,backups}
cd ${lempdir:-/data/lemp} ; ls -al ${lempdir:-/data/lemp} 
explorer ${lempdir:-/data/lemp}
# docker-compose // nginx.conf // index.php
template_edit lemp.yml nginx.conf dk_lemp_index.php
template_view lemp.yml nginx.conf dk_lemp_index.php
template_copy lemp.yml ${lempdir:-/data/lemp}/docker-compose.yml ; cat $lempdir/docker-compose.yml
template_copy nginx.conf ${lempdir:-/data/lemp}/nginx.conf ;; cat $lempdir/nginx.conf
template_copy dk_lemp_index.php ${lempdir:-/data/lemp}/www/index.php ;; cat $lempdir/www/index.php
vi3 ${lempdir:-/data/lemp}/docker-compose.yml $lempdir/nginx.conf $lempdir/Dockerfile.php
# php-mysql 연동 /data/lemp/Dockerfile.php
echo -e "FROM php:fpm-alpine\nRUN docker-php-ext-install pdo_mysql\n" > ${lempdir:-/data/lemp}/Dockerfile.php ;; cat $lempdir/Dockerfile.php
# IP:8080 web // IP:8081 phpmyadmin
nmap localhost
# mysqldump
docker exec lemp_mysql_www_latest sh -c 'exec mysqldump --all-databases -u root -p"$MYSQL_ROOT_PASSWORD"' > /data/lemp/backups/backup_$(date +%Y%m%d_%H%M%S).sql && ls -al /data/lemp/backups/
# phpmyadmin start / stop 보안상 필요할때만 on
docker-compose varS__start__stop phpmyadmin
#
: ps; cd ${lempdir:-/data/lemp}; docker-compose ps
: up; cd ${lempdir:-/data/lemp}; docker-compose up -d --remove-orphans --build ; docker-compose stop phpmyadmin
: logs; cd ${lempdir:-/data/lemp}; docker-compose logs -f 
: sh; cd ${lempdir:-/data/lemp}; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
: down; cd ${lempdir:-/data/lemp}; docker-compose down
!!! cd ${lempdir:-/data/lemp}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )



%%% {submenu_docker}docker compose media_center jellyfin/navidrome/filebrowser [dkav]
%%%e {submenu_docker}docker compose media_center jellyfin/navidrome/filebrowser [dkav]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@media"; cd $varl1 || mkdir -p $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/media}/{movies,tvshows,music,navidrome_data,jellyfin_config,jellyfin_cache,filebrowser} ; chown 1000:1000 ${varl1:-/data/media}/ -R
cd ${varl1:-/data/media} ; ls -al ${varl1:-/data/media}
touch ./filebrowser/database.db ; chown 1000:1000 $_ ; chmod 660 $_ 
# docker-compose
template_edit media.yml 
template_view media.yml 
template_copy media.yml ${varl1:-/data/media}/docker-compose.yml ; cat $varl1/docker-compose.yml
vi2 ${varl1:-/data/media}/docker-compose.yml
# IP:8096 jellyfin // IP:4533 navidrome // IP:8082 file_browser
nmap localhost
#
: ps; cd ${varl1:-/data/media}; docker-compose ps
: up; cd ${varl1:-/data/media}; docker-compose up -d --remove-orphans --force-recreate 
: logs; cd ${varl1:-/data/media}; docker-compose logs -f 
: sh; cd ${varl1:-/data/media}; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
: down; cd ${varl1:-/data/media}; docker-compose down
!!! cd ${varl1:-/data/media}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )



%%% {submenu_docker}docker compose ansible webui semaphore [dkse]
%%%e {submenu_docker}docker compose ansible webui semaphore [dkse]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@semaphore"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/semaphore}/
cd ${varl1:-/data/semaphore} ; ls -al ${varl1:-/data/semaphore} 
cat ${varl1:-/data/semaphore}/docker-compose.yml
#
!!! template_copy semaphore.yml ${varl1:-/data/semaphore}/docker-compose.yml ; cat ${varl1:-/data/semaphore}/docker-compose.yml
vi2 ${varl1:-/data/semaphore}/docker-compose.yml
# IP:3000 admin / changeme
cd ${varl1:-/data/semaphore}; docker-compose ps
cd ${varl1:-/data/semaphore}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/semaphore}; docker-compose logs -f 
cd ${varl1:-/data/semaphore}; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/semaphore}; docker-compose down
!!! cd ${varl1:-/data/semaphore}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )




%%% {submenu_docker}docker compose nagios [dkna]
%%%e {submenu_docker}docker compose nagios [dkna]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@nagios"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/nagios}/{nagios/{etc,var},custom-plugins,nagiosgraph/{var,etc}}
cd ${varl1:-/data/nagios} ; ls -al ${varl1:-/data/nagios} 
cat ${varl1:-/data/nagios}/docker-compose.yml
#
!!! template_copy nagios.yml ${varl1:-/data/nagios}/docker-compose.yml ; cat ${varl1:-/data/nagios}/docker-compose.yml
vi2 ${varl1:-/data/nagios}/docker-compose.yml
# nagiosadmin / nagios
cd ${varl1:-/data/nagios}; docker-compose ps
cd ${varl1:-/data/nagios}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/nagios}; docker-compose logs -f 
cd ${varl1:-/data/nagios}; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/nagios}; docker-compose down
!!! cd ${varl1:-/data/nagios}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 




%%% {submenu_docker}docker compose Rocket.Chat [dkro]
%%%e {submenu_docker}docker compose Rocket.Chat [dkro]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@rocketchat"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/rocketchat}/{uploads,data/db,data/dump}
cd ${varl1:-/data/rocketchat} ; ls -al ${varl1:-/data/rocketchat} 
cat ${varl1:-/data/rocketchat}/docker-compose.yml
#
template_edit rocketchat.yml
template_view rocketchat.yml
!!! template_copy rocketchat.yml ${varl1:-/data/rocketchat}/docker-compose.yml ; vi2 ${varl1:-/data/rocketchat}/docker-compose.yml
!!! curl -L https://go.rocket.chat/i/docker-compose.yml -o ${varl1:-/data/rocketchat}/docker-compose.yml
vi2 ${varl1:-/data/rocketchat}/docker-compose.yml
#
cd ${varl1:-/data/rocketchat}; docker-compose ps
cd ${varl1:-/data/rocketchat}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/rocketchat}; docker-compose logs -f 
cd ${varl1:-/data/rocketchat}; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/rocketchat}; docker-compose down
!!! cd ${varl1:-/data/rocketchat}; docker-compose down -v
#
cd ${varl1:-/data/rocketchat}; docker-compose exec mongo mongosh --eval "rs.initiate()"
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 



%%% {submenu_docker}docker compose wg-easy wireguard [dkw]
%%%e {submenu_docker}docker compose wg-easy wireguard [dkw]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@wireguard"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/wireguard}/data
cd ${varl1:-/data/wireguard}/data ; ls -al ${varl1:-/data/wireguard} ${varl1:-/data/wireguard}/data
cat ${varl1:-/data/wireguard}/docker-compose.yml
#
template_view wireguard.yml 
!!! template_copy wireguard.yml ${varl1:-/data/wireguard}/docker-compose.yml ; vi2 ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's/ WG_HOST=.*/ WG_HOST='"$publicip"'/' ${varl1:-/data/wireguard}/docker-compose.yml
hostname ; readx ; sed -i 's/ WG_HOST=.*/ WG_HOST='"$(hostname)"'/' ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's/PASSWORD=.*$/PASSWORD='varPassword'/' ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's|- /data/wireguard/data|- '"${varl1:-/data/wireguard}"'/data|g' ${varl1:-/data/wireguard}/docker-compose.yml
vi2 ${varl1:-/data/wireguard}/docker-compose.yml
#
cd ${varl1:-/data/wireguard}/data ; docker-compose ps
cd ${varl1:-/data/wireguard}/data ; docker-compose up -d
# key // eth0(vpn->outbound->proxmox->vmbr0.edit) check
vi2 ${varl1:-/data/wireguard}/data/wg0.conf
cd ${varl1:-/data/wireguard}; docker-compose exec wg genkey | tee wg pubkey
cd ${varl1:-/data/wireguard}; docker-compose logs -f 
cd ${varl1:-/data/wireguard}/data ; docker-compose down
!!! cd ${varl1:-/data/wireguard}/data ; docker-compose down -v
#
: webpage; lynx "http://$publicip:51821" ;; echo "http://$publicip:51821" 
# nat table check 
: nat ; GREEN=$(tput setaf 6);RESET=$(tput sgr0);iptables-save -t nat | awk -v green="$GREEN" -v reset="$RESET" '/^-A/ {print $0; gsub("-A", "-D"); print green "iptables -t nat " $0 reset}'
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 


%%% {submenu_docker}docker compose rhymix/nginx/mariadb [dkrm]
%%%e {submenu_docker}docker compose rhymix/nginx/mariadb [dkrm]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@rhymix"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/rhymix}
cd ${varl1:-/data/rhymix}; ls -al ${varl1:-/data/rhymix}
cd $( dirname ${varl1:-/data/rhymix} ) ; git clone https://github.com/devjiro76/rhymix_docker.git rhymix 
# 서비스 포트 수정 
vi2 ${varl1:-/data/rhymix}/docker-compose.yml
explorer ${varl1:-/data/rhymix}/
cd ${varl1:-/data/rhymix}; vi2 init.sh
# php7.1 -> 7.4up
!!! template_copy php74.docker.yml ${varl1:-/data/rhymix}/dockers/php-fpm/Dockerfile
cd ${varl1:-/data/rhymix}; sh init.sh
# /usr/share/nginx/html/common/manual/server_config/rhymix-nginx.conf: 최하단 location / 범위 주석
cd ${varl1:-/data/rhymix}; vi2 web/common/manual/server_config/rhymix-nginx.conf
#
cd ${varl1:-/data/rhymix}; docker-compose ps
cd ${varl1:-/data/rhymix}; docker-compose up -d
cd ${varl1:-/data/rhymix}; docker-compose logs -f 
cd ${varl1:-/data/rhymix}; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Image}}"|pipemenu1cancel ) varCmd__sh
docker run -it $( docker ps -a --filter "status=running" --format "{{.Image}}"|pipemenu1cancel ) varCmd__sh
cd ${varl1:-/data/rhymix}; docker-compose down
!!! cd ${varl1:-/data/rhymix}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 



%%% {submenu_docker}docker compose wordpress / phpmyadmin [dkwp]
%%%e {submenu_docker}docker compose wordpress / phpmyadmin [dkwp]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@wordpress"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/wordpress}/{db,data}
cd ${varl1:-/data/wordpress}; ls -al ${varl1:-/data/wordpress}
cat ${varl1:-/data/wordpress}/docker-compose.yml
#
# template -> wp:latest / mysql:latest / phpmyadmin
template_edit wordpress.yml
template_view wordpress.yml
!!! template_copy wordpress.yml ${varl1:-/data/wordpress}/docker-compose.yml ; cat ${varl1:-/data/wordpress}/docker-compose.yml
sed -i 's|VOLUMEPATH|'"${varl1:-/data/wordpress}"'/data|g' ${varl1:-/data/wordpress}/docker-compose.yml
sed -i 's|- "8080:80"|- "varPort:80"|g' ${varl1:-/data/wordpress}/docker-compose.yml
vi2 ${varl1:-/data/wordpress}/docker-compose.yml
#
cd ${varl1:-/data/wordpress}; docker-compose ps
cd ${varl1:-/data/wordpress}; docker-compose up -d
cd ${varl1:-/data/wordpress}; docker-compose logs -f 
cd ${varl1:-/data/wordpress}; docker-compose down
!!! cd ${varl1:-/data/wordpress}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 


%%% {submenu_docker}docker compose immich [dkim]
%%%e {submenu_docker}docker compose immich [dkim]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@im"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/im}/photos ; cd $varl1 
git clone https://github.com/immich-app/immich.git ; push ; ls -al
explorer ${varl1:-/data/im}
cd ${varl1:-/data/im}/immich
cd ${varl1:-/data/im}/immich/docker ; cp example.env .env 
# 환경파일 수정 
sed -i 's|UPLOAD_LOCATION=.*$|UPLOAD_LOCATION='"${varl1:-/data/im}"'/varUPLOAD__photos|g' ${varl1:-/data/im}/immich/docker/.env
vi2 ${varl1:-/data/im}/immich/docker/.env
# 버젼 업데이트: docker down -> .env 버젼수정 -> docker pull -> docker up -d
cd ${varl1:-/data/im}/immich/docker ; docker-compose down && docker-compose pull && docker-compose up -d
#
cd ${varl1:-/data/im}/immich/docker ; docker-compose ps
cd ${varl1:-/data/im}/immich/docker ; docker-compose up -d
cd ${varl1:-/data/im}/immich/docker ; docker-compose restart $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel )
cd ${varl1:-/data/im}/immich/docker ; docker-compose down
cd ${varl1:-/data/im}/immich/docker ; docker-compose pull
!!! cd ${varl1:-/data/im}/immich/docker ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps





%%% {submenu_docker}docker compose traefik [dktf]
%%%e {submenu_docker}docker compose traefik [dktf]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@traefik"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/traefik}/data
cd ${varl1:-/data/traefik}/data ; ls -al ${varl1:-/data/traefik} ${varl1:-/data/traefik}/data
cat ${varl1:-/data/traefik}/docker-compose.yml
#
# template -> 
!!! template_copy traefik.yml ${varl1:-/data/traefik}/docker-compose.yml ; cat ${varl1:-/data/traefik}/docker-compose.yml
vi2 ${varl1:-/data/traefik}/docker-compose.yml
#
cd ${varl1:-/data/traefik}/data ; docker-compose ps
cd ${varl1:-/data/traefik}/data ; docker-compose up -d
cd ${varl1:-/data/traefik}/data ; docker-compose restart $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel )
cd ${varl1:-/data/traefik}/data ; docker-compose down
!!! cd ${varl1:-/data/traefik}/data ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps




%%% {submenu_docker}docker compose guacamole [dkg]
%%%e {submenu_docker}docker compose guacamole [dkg]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@guacamole"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/guacamole}/data
cd ${varl1:-/data/guacamole}/data ; ls -al ${varl1:-/data/guacamole} ${varl1:-/data/guacamole}/data
# git clone 
git clone "https://github.com/boschkundendienst/guacamole-docker-compose.git" 
cd guacamole-docker-compose && ./prepare.sh
cd ${varl1:-/data/guacamole}/data ; mv guacamole-docker-compose/* ..
cat ${varl1:-/data/guacamole}/docker-compose.yml
#
vi2 ${varl1:-/data/guacamole}/docker-compose.yml
#
# guacamole guacd nginx postgres 
# https://publicip:8443 (guacadmin/guacadmin)
#
cd ${varl1:-/data/guacamole}/data ; docker-compose ps
cd ${varl1:-/data/guacamole}/data ; docker-compose up -d
cd ${varl1:-/data/quacamole}/data ; docker-compose restart $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel )
cd ${varl1:-/data/guacamole}/data ; docker-compose down
!!! cd ${varl1:-/data/guacamole}/data ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps



%%% {submenu_docker}docker compose home assistant os [dkha]
%%%e {submenu_docker}docker compose home assistant os [dkha]
%% dockersvc
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@haos"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/haos}/config
cd ${varl1:-/data/haos}/ ; ls -al ${varl1:-/data/haos}/ 
#
# template 
!!! template_copy haos.yml ${varl1:-/data/haos}/docker-compose.yml ; cat ${varl1:-/data/haos}/docker-compose.yml
vi2 ${varl1:-/data/haos}/docker-compose.yml
# http://yourdomain.com:8123
cd ${varl1:-/data/haos}/ ; docker-compose ps
cd ${varl1:-/data/haos}/ ; docker-compose up -d
cd ${varl1:-/data/haos}/ ; docker-compose logs -f 
cd ${varl1:-/data/haos}/ ; docker-compose down
!!! cd ${varl1:-/data/haos}/ ; docker-compose down -v
cd ${varl1:-/data/haos}/ ; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varSH__bash
#
curl $( echo localhost localhost/index.php $HOSTNAME |pipemenu):varPort__80 





%%% {submenu_docker}docker compose nginx-proxy-manager [dknpm]
%%%e {submenu_docker}docker compose nginx-proxy-manager [dknpm]
%% dockersvc
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@npm"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/npm}/{data,letsencrypt} 
cd ${varl1:-/data/npm}/ ; ls -al ${varl1:-/data/npm}/ 
explorer ${varl1}
# https://github.com/NginxProxyManager/nginx-proxy-manager
# template -> nginx-proxy-manager.yml
template_view nginx-proxy-manager.yml
!!! template_copy nginx-proxy-manager.yml ${varl1:-/data/npm}/docker-compose.yml ; cat ${varl1:-/data/npm}/docker-compose.yml
vi2 ${varl1:-/data/npm}/docker-compose.yml
# http://yourdomain.com:81 -> admin@example.com // changeme
cd ${varl1:-/data/npm}/ ; docker-compose ps
cd ${varl1:-/data/npm}/ ; docker-compose up -d
cd ${varl1:-/data/npm}/ ; docker-compose logs -f 
cd ${varl1:-/data/npm}/ ; docker-compose down
!!! cd ${varl1:-/data/npm}/ ; docker-compose down -v
cd ${varl1:-/data/npm}/ ; docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varSH__bash
#
curl $( echo localhost localhost/index.php $HOSTNAME |pipemenu):varPort__80 







%%% {submenu_docker}docker compose next-cloud [dkc]
%%%e {submenu_docker}docker compose next-cloud [dkc]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@nextcloud"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/nextcloud}/{nextcloud,apps,config,data,theme}
cd ${varl1:-/data/nextcloud}/ ; ls -al ${varl1:-/data/nextcloud}/ ${varl1:-/data/nextcloud}/*
cat ${varl1:-/data/nextcloud}/docker-compose.yml
#
# template -> nextcloud,mariadb,tikaserver,elasticsearch
!!! template_copy nextcloud.yml ${varl1:-/data/nextcloud}/docker-compose.yml ; cat ${varl1:-/data/nextcloud}/docker-compose.yml
# 
vi2 ${varl1:-/data/nextcloud}/docker-compose.yml
#
cd ${varl1:-/data/nextcloud}/ ; docker-compose ps
cd ${varl1:-/data/nextcloud}/ ; docker-compose up -d
cd ${varl1:-/data/nextcloud}/ ; docker-compose down
cd ${varl1:-/data/nextcloud}/ ; docker-compose exec nextcloud bash
!!! cd ${varl1:-/data/nextcloud}/ ; docker-compose down -v
#
curl $( echo localhost localhost/index.php localhost/phpmyadmin localhost:3300 $HOSTNAME |pipemenu) 
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps





%%% {submenu_docker}docker compose caddy [dkca]
%%%e {submenu_docker}docker compose caddy [dkca]
%% dockersvc
%% [ "$mydomain" ] && echo "mydomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 공사중
# 내도메인 정보 환경파일에 넣거나 직접 입력 
[ ! "$mydomain" ] && echo "mydomain=varMyDomain" >> ~/go.private.env && . ~/go.private.env
export mydomain=varMyDomain
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@caddy"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/caddy}/site 
cd ${varl1:-/data/caddy}
ls -al ${varl1:-/data/caddy}/ ${varl1:-/data/caddy}/*
cat ${varl1:-/data/caddy}/docker-compose.yml
#
# template -> caddy.yml Caddyfile
!!! template_copy caddy.yml ${varl1:-/data/caddy}/docker-compose.yml ; cat ${varl1:-/data/caddy}/docker-compose.yml
!!! template_copy caddyfile.yml ${varl1:-/data/caddy}/Caddyfile ; cat ${varl1:-/data/caddy}/Caddyfile
sed -i 's|example.com|varYourDomain|g' ${varl1:-/data/caddy}/Caddyfile ; cat ${varl1:-/data/caddy}/Caddyfile
!!! rbackup ${varl1:-/data/caddy}/site/index.html && echo -e "hi caddy" > ${varl1:-/data/caddy}/site/index.html ; cat ${varl1:-/data/caddy}/site/index.html
#
vi2 ${varl1:-/data/caddy}/docker-compose.yml
vi2 ${varl1:-/data/caddy}/Caddyfile
vi2 ${varl1:-/data/caddy}/site/index.html
#
cd ${varl1:-/data/caddy}; docker-compose ps
cd ${varl1:-/data/caddy}; docker-compose up -d
cd ${varl1:-/data/caddy}; docker-compose down
cd ${varl1:-/data/caddy}; docker-compose logs -f
!!! cd ${varl1:-/data/caddy}; docker-compose down -v
#
docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) ash
#
curl $( echo https://localhost localhost/index.html http://$mydomain https://$mydomain| pipemenu) 
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps















%%% {submenu_com}ansible 관리 자동화 [ansible]
%%%e {submenu_com}ansible Management Automation [ansible]
# python3 와 ssh 를 이용하여 서버관리 자동화
# 가상환경의 경우 ansible 위치 조정 
source ansible_venv/bin/activate
echo "source ansible_venv/bin/activate" >> ~/.bashrc
# 
# hosts
rbackup /etc/ansible/hosts ; mkdir -p /etc/ansible/ ; echo "127.0.0.1" > /etc/ansible/hosts
# example hosts
echo -e "google.byus.net\n\n[web]\ng1.byus.net\ng2.byus.net\nhh.byus.net\n\n[db]\nhh.byus.net" >> /etc/ansible/hosts ; cat /etc/ansible/hosts
vi2 /etc/ansible/hosts
# hosts 에 지정된 서버는 ssh 공개키를 심어서 비번없이 로그인이 가능한 상태로 설정
#
ansible all -m ping 
ansible web -m ping
# 
ansible all -a "bash -c 'hostname && pstree && sleep 2'"
ansible all -a "bash -c 'varCommands'"
# 서버 모든 정보 확인 
ansible web -m setup
ansible all -m setup -a "filter=ansible_dist*"
# install sample
!!! template_copy playbook.yml ~/nginx_install.yml ; cat ~/nginx_install.yml 
vi2 varPlaybookPATH__@@root@@nginx_install.yml ; ansible-playbook varPlaybookPATH__@@root@@nginx_install.yml
# script exec sample
!!! template_copy playbook_script.yml ~/playbook_script.yml ; cat ~/playbook_script.yml
echo "pstree; ps -ef |grep -E \"ssh|go.sh\"" > /root/pstree.sample.sh
vi2 varPlaybookPATH__@@root@@playbook_script.yml ; ansible-playbook varPlaybookPATH__@@root@@playbook_script.yml 
#
vi2 varPlaybookPATH ;; ansible-playbook varPlaybookPATH
#
#
ansible --version  
explorer $HOME/ansible_venv/
# install
yyay python3 
yyay ansible
# 가상환경일때 install
yyay python3-venv
python3 -m venv ansible_venv
pip install ansible




%%% {submenu_com}GitHub / Git [git]
%%%e {submenu_com}GitHub / Git [git]
# clone
cd varDIR__@@root
git clone varProjectURL
# init && push
mkdir -p $HOME/varProjectDIR__git_project && cd $HOME/varProjectDIR__git_project
cd $HOME/varProjectDIR
git init ; ls -al
git remote add origin https://github.com/varName/varProjectDIR
git add .
git commit -m "varCommit"
git branch -M main 
git push -u origin main
# edit
git add varFILE
git commit -m "varCommitEdit"
git push -u origin main
# branch
git branch
git branch varNewBranch
git checkout -b varBranch
git branch -d varBranch
# push_branch
git add .
git commit -m "varCommitEdit"
git push -u origin varBranch
#
# install && config https://github.com/ (account+)
yyay git ; echo ; git --version
git config --global user.name varName
git config --global user.email varEmail
git config --list
explorer $HOME/.gitconfig







%%% {submenu_hidden}java/ php/ perl/ python [java]
%%%e {submenu_hidden}java/ php/ perl/ python [java]
# apache2-utils
htpasswd -nb varAdmin__admin varPW__web_auth_pw || yyay apache2-utils
# java
yyay openjdk-17-jdk
# jdk8 repo
echo "deb http://ftp.debian.org/debian stretch-backports main" | tee -a /etc/apt/sources.list.d/stretch-backports.list ;
echo "deb http://deb.debian.org/debian oldoldstable main" | tee -a /etc/apt/sources.list.d/bookworm-oldoldstable.list
echo "deb http://deb.debian.org/debian/ oldoldstable main" >> /etc/apt/sources.list 
add-apt-repository ppa:webupd8team/java
vi2 /etc/apt/sources.list 
aptupup
yyay -t stretch-backports openjdk-8-jdk
yyay openjdk-8-jdk
yyay oracle-java8-installer
# default java setting
which java
update-alternatives --list java
update-alternatives --config java
# linux_version check
lsb_release -a


%%% {submenu_sys}annyung3 linux (centos7 base) [an3]
%%%e {submenu_sys}annyung3 linux (centos7 base) [an3]
# centos7 minimal 설치후 an3 로 변경
# https://joungkyun.gitbook.io/annyung3-installation-guide/chapter1
yum install -y perl
cd ; curl -o bootstrap $( echo http://mirror.oops.org/pub/AnNyung/3/inst/bootstrap http://ftp.kr.freebsd.org/pub/AnNyung/3/inst/bootstrap | pipemenu) 
bash $HOME/bootstrap
vi2 $HOME/bootstrap
vi2 /usr/share/AnNyung/functions
yum -y update
# oops-firewall 
yum -y install kmod-geoip
# geoip download & database
cd /usr/share/GeoIP ; curl -O http://mirror.oops.org/pub/Security/GeoIP-Legacy/GeoIPCountryWhois.csv ; curl -O http://mirror.oops.org/pub/Security/GeoIP-Legacy/GeoIPv6.csv ; /usr/bin/geoip-csv2bin 1 ; ls -al
# ex) RU/CN ban , ssh KR only
echo "%-A INPUT -m geoip --src-cc RU -j DROP" >> /etc/oops-firewall/user.conf 
echo "%-A INPUT -m geoip --src-cc CN -j DROP" >> /etc/oops-firewall/user.conf 
echo "%-A INPUT -p tcp --dport 22 -m geoip ! --src-cc KR -j DROP" >> /etc/oops-firewall/user.conf
vi2 /etc/oops-firewall/user.conf
systemctl restart oops-firewall
systemctl enable oops-firewall ; systemctl start oops-firewall ; systemctl status oops-firewall
systemctl status oops-firewall
# repo list 
for repo in $(yum repolist 2>/dev/null | awk '$1 == "*" {print $2}' | sed 's/:$//'); do filename=$(echo $repo | sed 's/://g') ; yum --disablerepo='*' --enablerepo="$repo" list available 2>/dev/null > "/root/${filename}.repo.list.txt" ; done ; cat /root/AN*.list.txt | sort -u > /root/AN.repo.list.txt.all ; ls -al /root/*.repo.list.txt*
vi2 $( ls -1 /root/*.list.txt /root/*.list.txt.all | pipemenu )
grep -i "varSearch" /root/*.repo.list.txt | cgrep varSearch
yum -y install varPackage
yy lynx wget curl 
explorer /etc/yum.repos.d/


%%% {submenu_sys}annyung2 linux (centos6 base) vault.repo set [an2]
%%%e {submenu_sys}annyung2 linux (centos6 base) vault.repo set [an2]
# fast mirror enable -> 0 
vi2 /etc/yum/pluginconf.d/fastestmirror.conf 
# 기존 repolist 백업 
mkdir -p /etc/yum.repos.d/backup-repo && mv /etc/yum.repos.d/CentOS-*.repo* /etc/yum.repos.d/backup-repo/
# fast jp server set
!!! template_copy centos-vault.repo /etc/yum.repos.d/centos-vault.repo
vi2 /etc/yum.repos.d/centos-vault.repo
# or default vault server set
!!! template_copy vault.repo /etc/yum.repos.d/centos-vault.repo
vi2 /etc/yum.repos.d/centos-vault.repo
# epel6 기존 백업및 archive repo 갱신
mv /etc/yum.repos.d/epel*.repo* /etc/yum.repos.d/backup-repo/
!!! template_copy epel6.repo /etc/yum.repos.d/epel6.repo
vi2 /etc/yum.repos.d/epel6.repo
# 
yum clean all ; yum repolist
yum update
explorer /etc/yum.repos.d/
# centos6 ranger install (epel6 base)
yy zstd ranger 
# centos6 ranger install (python2 base)
yy git 
cd /backup ; git clone https://github.com/ranger/ranger.git
cd ranger ; git checkout v1.8.1 ; make install






%%% {submenu_sys}annyung1 linux (centos5 base) [an]
%%%e {submenu_sys}annyung1 linux (centos5 base) [an]
pkgdb -v
pkgsysupdate -v
pkgkernel -v
pkgkernel -i varKernel__kernel-bigmem
!!! pkgkernel -r varA 
pkginfo -l > /root/pkginfo.txt ; cat /root/pkginfo.txt | less -RX 
vi2 /root/pkginfo.txt
# pkg install
pkgadd -u $( cat /root/pkginfo.txt |grep "설치 안됨"|awk '{print $1}'|sort -u| pipemenu )
pkgadd -u varPKGname
rpm -ql varPKGname
# apm
pkginfo -l -v varPKGname__apache
pkginfo -l -v php
pkginfo -l -v mysql
# daemon set
ntsysv
vi2 /etc/sysconfig/mysql
vi2 /etc/sysconfig/i18n
vi2 /etc/sysconfig/hwconf
explorer /etc/
# etc
[ ! "$(grep "/bin/pass" /etc/shells)" ] && echo "/bin/pass" >> /etc/shells



%%% {submenu_sys}epel repo add [epel]
%%%e {submenu_sys}epel repo add [epel]
# EPEL 는 RHEL/CentOS의 일부가 아니지만 모니터링등 많은 오픈 소스
# 패키지를 제공하여 주요 Linux 배포판용으로 설계. 
#
# CentOS 7
yum install epel-release
# CentOS 6 (expired) -> epel6 기존 백업및 archive repo 갱신
mkdir -p /etc/yum.repos.d/backup-repo ; mv /etc/yum.repos.d/epel*.repo* /etc/yum.repos.d/backup-repo/
!!! template_copy epel6.repo /etc/yum.repos.d/epel6.repo
vi2 /etc/yum.repos.d/epel6.repo
# RHEL 9
subscription-manager repos --enable codeready-builder-for-rhel-9-$(arch)-rpms
dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
# RHEL 8
subscription-manager repos --enable codeready-builder-for-rhel-8-$(arch)-rpms
dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm
# Rocky/AlmaLinux 9
dnf config-manager --set-enabled crb
dnf install epel-release
# Rocky/AlmaLinux 8
dnf config-manager --set-enabled powertools
dnf install epel-release
#
yum clean all ; yum repolist
yum update



%%% {submenu_com}irc chat [irc]
%%%e {submenu_com}irc chat [irc]
irssi
# irssi config
mkdir -p ~/.irssi/ ; echo -e 'servers = (\n  {\n    address = "varIRCServer__irc.dankun.net";\n    chatnet = "Dankun";\n    port = "6667";\n    password = "";\n    use_ssl = "no";\n    ssl_verify = "no";\n    autoconnect = "yes";\n  }\n);\n\nchatnets = {\n  Dankun = {\n    type = "IRC";\n    nick = "varNick";\n    autosendcmd = "/join #gosh";\n  };\n};\n\nsettings = {\n  core = { real_name = "varNick"; user_name = "varNick"; nick = "varNick"; };\n};' > ~/.irssi/config
vi2 ~/.irssi/config
# irc client install
yyay irssi 


%%% {submenu_com}termux (android-linux) [ter]
%%%e {submenu_com}termux (android-linux) [ter]
# https://f-droid.org/repo/com.termux_118.apk
termux-wake-lock ; termux-setup-storage 
( whoami ; ifconfig ; curl ifconfig.me ) | push
whoami ; passwd
# termux 실행시 sshd / crond 구동 .bashrc
echo -e 'termux-wake-lock\n(( $(ps -ef|grep -c [s]shd ) == 0 )) && sshd\n(( $(ps -ef|grep -c [c]rond ) == 0 )) && crond\n' >> $HOME/.bashrc ; echo -e 'export VISUAL=vim; export EDITOR="$VISUAL"' >> ~/.bashrc ; echo -e "alias l='ls'\nalias ll='ls -l'\nalias la='ls -al'\nalias go='bash $HOME/go.sh'" >> $HOME/.bashrc 
ln -s /data/data/com/termux/files/usr $HOME/root ; ln -s /data/data/com/termux/files/usr/etc $HOME/etc ; ln -s /data/data/com/termux/files/usr/var $HOME/var ; ln -s /data/data/com/termux/files/usr/spool/cron $HOME/cron ; ln -s /data/data/com/termux/files/usr/tmp $HOME/tmp 
# ssh
vi2 $( echo $HOME/.bashrc $HOME/.ssh/config $HOME/etc/ssh/sshd_config $HOME/cron/$(whoami) | pipemenu )
!!! pkill sshd; sshd
ps -ef|grep -E "sshd|crond|autossh"
(( $(ps -ef|grep -c [s]shd ) == 0 )) && sshd ; (( $(ps -ef|grep -c [c]rond ) == 0 )) && crond ; (( $(ps -ef|grep -c [a]utossh ) == 0 )) && [ -f $HOME/.termux/boot/autossh.sh ] && bash $HOME/.termux/boot/autossh.sh
# pkg
pkg update -y ; pkg upgrade -y
pkg list-all > $HOME/pkglist.txt ; vi2 $HOME/pkglist.txt
cat $HOME/pkglist.txt |grep varSEARCH
pkg install -y varPKG
pkg install -y vim wget proot openssh termux-api autossh termux-services python ranger
pkg list-installed
# termux-setup-storage
explorer /data/data/com.termux/files/home/storage/downloads/ 
# 외부에서 스마트폰 ssh 접속 key set
ssh-copy-id -p 8022 -i id_rsa.pub varTerMuxHOST
ssh -p 8022 varTermuxUser@varTerMuxHOST
# 역터널링 설정(외부에서 폰:8022 접속) 공인ip접근시 공유기포트포워딩
ssh -f -N -R varPort__2222:localhost:8022 root@varRemotehost -o ServerAliveInterval=60 -o ServerAliveCountMax=1440 
# 역터널링 접속 스크립트 전송
echo "ssh $(whoami)@localhost -p varPort__2222" | ssh root@varRemotehost "cat > $HOME/termux.con.sh"
# 리모트 서버에서 termux 서버 접속 
cat $HOME/termux.con.sh && readx &&  eval $(cat $HOME/termux.con.sh )
# 역터널링 해제 ( 리모트 or termux 로컬 )
lsof -i:varPort__2222 | awknr2 | awk2 | xargs kill 
lsof -i:varPort__8022 | awknr2 | awk2 | xargs kill 
# 역터널링 autossh runit sv add 
mkdir -p /data/data/com.termux/files/usr/var/service/autossh/ && echo -e "#!/data/data/com.termux/files/usr/bin/sh\nexec autossh -M 0 -N -R varPort__2222:localhost:8022 root@varRemotehost" > /data/data/com.termux/files/usr/var/service/autossh/run ; chmod +x /data/data/com.termux/files/usr/var/service/autossh/run
# runit
svc=$( echo autossh crond sshd | pipemenu ) ;; sv-enable $svc ; sv up $svc
svc=$( echo autossh crond sshd | pipemenu ) ;; sv-disable $svc ; sv down $svc
svc=$( echo autossh crond sshd | pipemenu ) ;; sv status $svc
pkg install -y runit
explorer /data/data/com.termux/files/usr/var/service/





# out
export rootpart=varRhostRootpartiton ; export rootpartnew=${rootpart//sda/sdb}
export bootpart=varRhostBootpartiton__@@dev@@sda1 ; export bootpartnew=${bootpart//sda/sdb}
: !검토 tgz ; echo "time ssh $rhost \"tar czfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / \" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | tar xzfp - -C /mnt/$(basename $rootpartnew)/"


%%% {submenu_sys}물리서버->가상서버 online migration [p2v]
%%%e {submenu_sys}Physical Server to Virtual Server Online Migration [p2v]
%% echo "host:$rhost boot:$bootpart bootnew:$bootpartnew root:$rootpart rootnew:$rootpartnew rootpartsize=${rootpartsize}M"
# 가상서버에 쓰일 sda 를 임시 리눅스 sdb 에 연결후 임시 리눅스에서 p2v 작업
# 물리서버 호스트/부트파티션/루트파티션 설정 (ex.abc.com /dev/sda1 /dev/sda7)
export rhost=varRhost
ssh $rhost "fdisk -l;echo;df" ; echo ; fdisk -l /dev/sdb
# root boot 지정
export rootpart=$( ssh $rhost "df" | awk '$6 == "/" {print $1}') ; export rootpartnew=${rootpart//sda/sdb} ; export bootpart=$( ssh $rhost "df" | awk '$6 == "/boot" {print $1}') ; export bootpartnew=${bootpart//sda/sdb} ; export rootpartsize=$( ssh $rhost "df -m" |awk '$6 == "/" {print $3}') 
# MBR copy
fdisk -l ; df 
!!! ssh $rhost "dd if=/dev/sda bs=512 count=1" | dd of=/dev/sdb bs=512 count=1
# MBR partition table copy 
# 디스크 사이즈가 정확히 일치하지 않는경우, Extended/End 파티션 체크
!!! ssh $rhost "sfdisk -d /dev/sda" > /root/sda.partition_table.sfdisk ; cat /root/sda.partition_table.sfdisk
vi2 /root/sda.partition_table.sfdisk 
sfdisk /dev/sdb < /root/sda.partition_table.sfdisk
fdisk /dev/sdb
# boot partiiion copy (무압축/zstd)
!!! time ssh $rhost "dd if=$bootpart bs=4M" | dd of=$bootpartnew bs=4M ; push
!!! time ssh $rhost "dd if=$bootpart bs=4M | zstd" | zstd -d | dd of=$bootpartnew bs=4M ; push
# root/ boot mount
varMKFsType__mkfs.ext3 $rootpartnew 
mkdir -p /mnt/$(basename $rootpartnew)/ ; mount $rootpartnew /mnt/$(basename $rootpartnew) ; ls -al /mnt/$(basename $rootpartnew) ; mkdir -p /mnt/$(basename $rootpartnew)/{boot,proc,mnt,sys,tmp} ; mount $bootpartnew /mnt/$(basename $rootpartnew)/boot ; ls -al /mnt/$(basename $rootpartnew)/boot ; df
# sda mount partiation create ex) boot,clone,tmp,var,home 
export sdap=$( ssh $rhost "df" | grep "/dev/sda" | awk '{print $NF}' | sed -e 's/\///g' -e '/^$/d' | paste -sd, )
export exclude=$( ssh $rhost "df" | grep "/dev/sd" | awk '{if ($NF != "/") print "--exclude="$NF}' | paste -sd' ' - )
echo "$sdap" ; echo ; echo "$exclude"
eval "mkdir -p /mnt/$(basename $rootpartnew)/{$sdap}" ; explorer /mnt/$(basename $rootpartnew)/
# 별도 마운트 파티션을 제외한 sda root partition copy -> 검토/zstd/gzip
: !검토 zst ; echo "time ssh $rhost \"tar cfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / | zstd\" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | zstd -d | tar xfp - -C /mnt/$(basename $rootpartnew)/"
!!! : !zstd copy ; eval "time ssh $rhost \"tar cfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / | zstd\" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | zstd -d | tar xfp - -C /mnt/$(basename $rootpartnew)/" ; push
!!! : !gzip copy ; eval "time ssh $rhost \"tar czfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / \" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | tar xzfp - -C /mnt/$(basename $rootpartnew)/" ; push
# 별도 마운트 파티션 mkfs && 수동 마운트후 copy (ncp func) / swap 파티션체크
ssh $rhost "df;echo" ;echo $sdap ;; mkdir -p /mnt/$(basename $rootpartnew)/$(basename varF) ; explorer /mnt/$(basename $rootpartnew)/
varMKFsType__mkfs.ext3 varPartition ; mount varPartition /mnt/$(basename $rootpartnew)/$(basename varF)
!!! time ssh $rhost 'cd varF/ && tar cfp - *| zstd' | { pv 2>/dev/null || cat ; } | zstd -d| tar xfp - -C /mnt/$(basename $rootpartnew)/$(basename varF) ; push
!!! time ssh $rhost 'cd varF/ && tar cfp - *| gzip' | { pv 2>/dev/null || cat ; } | gunzip | tar xfp - -C /mnt/$(basename $rootpartnew)/$(basename varF) ; push
: label 82 swapon ; fdisk -l /dev/sdb ;; mkswap varP
# lilo 혹은 grub 에서 더이상 진행이 안될경우 rescue-mode (boot cd) 로 진입하여 mbr 재설정 
# dd 로 sda img 를 뜨거나 (느린속도) / offline 에서 clonezilla 로 sda img 를 떠서 p2v 도 가능함 










%%% {submenu_hidden}역터널링 / 터널링 [tn]
%%%e {submenu_hidden}Reverse Tunneling / Tunneling [tn]
# R 역터널링: ex) 핸드폰이 lte 모드일때 핸폰에서 역터널링 접속을 해두면, 원격에서 
# 핸드폰 termux 로 ssh 접속이 가능함 ssh localhost -p 2222 (서버->클라이언트접속)
ssh -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
# 터널링만 유지 (터널링이 끊어지면 24시간 동안 재접속시도)
ssh -f -N -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost -o ServerAliveInterval=60 -o ServerAliveCountMax=1440 
# 마찬가지로 외부에서 접속이 안되는 서버 포트 열기 (ex.rdp)
# 윈도우의 경우 putty 로 터널링 연결가능 
ssh -R varRemotePORT__3389:localhost:varLocalPORT__3389 root@varRemotehost
# 접속 유지에 특화 autossh 
# autossh (-M 모니터링포트 -M 0 -> keep-alive)
autossh -M varMonitorPort__0 -f -N -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
# 터널링 끊기
lsof -i:varPort__2222 
lsof -i:varPort__2222 | awknr2 | awk2 | xargs kill 
# L 터널링 (클라이언트->서버접속)
ssh -L varLcalPORT__2222:localhost:varRemotePORT__8022 root@varRemotehost
# D 터널링 (SOCKS 프록시) 브라우저 설정후 이용
ssh -D varProxyPORT__8080 root@varRemotehost
# LD / RD 터널링 (혼합)
ssh -D varProxyPORT__8080 -L varLocalPORT__2222:localhost:varRemotePORT__8022 root@varRemotehost
ssh -D varProxyPORT__8080 -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
#
yyay autossh



%%% {submenu_hidden}패키지 관리 snap / git / pip [aa]
%%%e {submenu_hidden}Package Management snap / git / pip [aa]
%% echo -n "Able:" ; { which snap ; which git ; which pip ; } 2>/dev/null | tr "\n" " " ; echo
# snap install
yy epel-release
yyay snapd
systemctl enable --now snapd.socket
ln -s /var/lib/snapd/snap /snap
# git install
yyay git ; echo ; git --version
# pip install
yyay python3 python3-pip ; ln -s /usr/bin/pip3 /usr/bin/pip
# Subversion install
yyay subversion






%%% {submenu_sys}tmp 폴더와 파일 / 난수 [tmp]
%%%e {submenu_sys}tmp Folder and Files / Random Number [tmp]
# tmpfile 생성 
: ${TMPDIR:=/tmp}; tmpfile=$(mktemp ${TMPDIR%/}/my_tmp_file.XXXXXX) || { echo "Failed to create temp file"; exit 1; } ; echo $tmpfile ; ls -al $tmpfile ; rm -f $tmpfile
# tmpdir 생성
: ${TMPDIR:=/tmp}; tmpdir=$(mktemp -d ${TMPDIR%/}/my_tmp_dir.XXXXXX) || { echo "Failed to create temp directory"; exit 1; } ; echo $tmpdir ; ls -ld $tmpdir ; rm -rf $tmpdir
# 임의의 6자리 숫자 생성 (인증키용) 
echo $(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))
echo $RANDOM ; echo $RANDOM$RANDOM|cut -c -6 ; echo $RANDOM$RANDOM|rev|cut -c -6|rev 
printf "%.06d\n" "$(shuf -i 0-999999 -n 1)"
printf '%.06s\n' "$(head -n3 /dev/urandom | tr -dc 0-9)"
# 난수 알파벳 생성 (6바이트 3바이트)
openssl rand -base64 6 ; openssl rand -base64 3 ; printf '%.6s\n' "$(openssl rand -base64 6)"
# 고유ID 
uuidgen;uuidgen;uuidgen
# 영어와숫자로된 6자리 난수
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc A-Za-z0-9)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc a-z0-9)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc a-z)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc 0-9)"
# 임의의 단어 난수
shuf -n 1 /usr/share/dict/words
shuf -n 1 /usr/share/dict/korean
# 단어를 배열에 넣고 출력 (메모리사용/속도지연)
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)]; }' /usr/share/dict/words
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)]; }' /usr/share/dict/korean
# 줄수를 가져와 랜덤줄수 sed (파일2회i/o)
f="/usr/share/dict/words"; l=$(wc -l < "$f"); r=$(( ($RANDOM$RANDOM) % l + 1)); sed -n "${r}p" "$f"
f="/usr/share/dict/korean"; l=$(wc -l < "$f"); r=$(( ($RANDOM$RANDOM) % l + 1)); sed -n "${r}p" "$f"
#
# 단어 난수2개 이어쓰기
shuf -n 2 /usr/share/dict/korean | tr -d '\n'; echo
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)] lines[int(rand() * NR + 1)]; }' /usr/share/dict/korean
f="/usr/share/dict/korean"; l=$(wc -l < "$f"); r1=$(( ($RANDOM$RANDOM) % l + 1)); r2=$(( ($RANDOM$RANDOM) % l + 1)); word1=$(sed -n "${r1}p" "$f"); word2=$(sed -n "${r2}p" "$f"); printf "%s%s\n" "$word1" "$word2"
# 영단어 패키지 설치 
yy words || ay wamerican
curl http://byus.net/koreane.txt -o /usr/share/dict/korean
curl http://byus.net/koreanu.txt -o /usr/share/dict/korean



%%% {submenu_hidden}중복실행방지 코드삽입 [dup]
%%%e {submenu_hidden}Code Insertion to Prevent Duplicate Execution [dup]
# 시스템 감시 용도의 스크립트등 중복으로 실행되면 안되는 경우 
# 아래의 runlockadd 함수를 스크립트에 삽입하여, 중복실행을 방지합니다.
# ex) cron 1분 간격 실행, load 가 높아 1분 안에 종료 않는 경우 중복 실행 방지
#
# test
export tmpscript="${TMPDIR:=/tmp}/tmp.sh"
echo -e "#!/bin/bash\ntop" > $tmpscript ; chmod 700 $tmpscript ; RED1 ; cat $tmpscript ; RST 
runlockadd $tmpscript; echo; RED1 ; cat $tmpscript.1 ; RST ; echo ; YEL1; cat $tmpscript ; RST 
cdiff $tmpscript.1 $tmpscript
screen -dmS test-top $tmpscript ;; ps -ef|grep tmp.sh ;; readx ; $tmpscript
# test end
ps -ef|grep tmp.sh|awk2 |xargs kill 
unset tmpscript
#
# 
declare -f runlockadd
runlockadd varScriptPATH ; vi2 varScriptPATH
# ###########################################################
# 부모를 체크하여 재귀실행방지
# ###########################################################
ps -o cmd= -p $PPID | grep -q "$(basename "$0")" && echo "$(basename "$0")가 이미 실행 중입니다. (재귀 실행 방지)" && exit 1
#
# ###########################################################
# 프로세스를 체크하여 중복실행방지
# ###########################################################
SCRIPT_NAME=$(basename "$0"); RUNNING_INSTANCES=$(ps -efww | grep -v grep | grep -c "$SCRIPT_NAME"); [ "$RUNNING_INSTANCES" -gt 1 ] && echo "$SCRIPT_NAME가 이미 실행 중입니다. (중복 실행 방지)" && exit 1



%%% {submenu_hidden}bash 변수 사용예제 [var]
%%%e {submenu_hidden}bash Variable Usage Examples [var]
# 변수 디폴트값 출력혹은 설정
unset var; echo "Result: ${var:=default}"; echo "\$var = $var"
unset var; echo "Result: ${var:-default}"; echo "\$var = $var"
unset var; echo "Result: ${var:+default}"; echo "\$var = $var"
unset var; echo "Result: ${var:?error}"; echo "\$var = $var" 2>/dev/null
# 변수 길이
var="value"; echo "Result: ${#var}"; echo "After: \$var = $var"
# 변수 자르기
var="hello"; echo ${var#?}; echo ${var%${var#?}} ; echo ${var:0:1}
var="/path/to/file.txt"; echo "Result: ${var#*/}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var##*/}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var%/*}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var%%/*}"; echo "After: \$var = $var"
# dirname / basename 
echo "$0 // $(dirname $0) //  $(basename "$0" )  // $(basename "$0" .sh)"
echo "$0 // ${0%/*} // ${0##*/} // $( t=${0##*/}; echo ${t%.*})"
# 변수 편집 // realpath
var="/root/./home/user"; echo "Result: ${var//\/\./}"; echo "After: \$var = $var"
var="/root/../home/user/./folder"; echo "Before: \$var = $var"; var=$(echo "$var" | sed -e 's/\/\.\//\//g' | awk -F'/' -v OFS="/" '{top=1; for (i=2; i<=NF; i++) {if ($i == "..") {top--; delete stack[top];} else if ($i != "") {stack[top]=$i; top++;}} for (i=0; i<top; i++) {printf "%s", stack[i]; printf i==top-1?"":OFS;}}');echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(readlink -f "$var"); echo "Result: $result" ;echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(realpath "$var");echo "Result: $result";echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(cd "$(dirname "${var}")" ; echo $(pwd));echo "Result: $result";echo "After: \$var = $var"
# 변수 배열 ; 배열 출력
array=($(seq 1 5)); for i in "${array[@]}"; do echo $i; done
# printf
printf "%-15s %5d\\n" "Apples" 5
printf "%.2f\\n" 3.141592
printf "%x\\n" 15
printf "%+10s\\n" "hello"
printf "%.5s\\n" "abcdefghijk"
printf "Hello\\tworld! \\n"
# 서브쉘과 현재쉘 변수 
c=0 ; ( a=1; b=2 ; c=$(( a + b )) ) ; echo $c
c=0 ; { a=1; b=2 ; c=$(( a + b )); } ; echo $c
# 간접변수참조
a=b ; b=c ; echo ${!a}




%%% {submenu_hidden}1750 sticky-bit / 2750 setgid / 4750 setuid [stbit]
%%%e {submenu_hidden}1750 sticky-bit / 2750 setgid / 4750 setuid [stbit]
# chmod 1750 - sticky bit rwxr-t---
# 디렉토리일 경우, 파일을 해당 소유자만 삭제 가능하도록 제한
# 공용 협업 디렉토리 보호에 적합 /tmp
mkdir share
chmod 1750 share
chgrp sharedgroup share
ls -ld share
ls -ld /tmp
#
# chmod 2750 - setgid rwxr-s---
# 디렉토리일 경우, 하위 파일/디렉토리는 같은 그룹으로 생성됨
# 팀 작업 시 그룹 권한 일관성 유지 가능
# 개발자가 만든 파일도 자동으로 www-data 그룹 소속이 되어 웹서버가 접근 가능
mkdir /var/www/site
chgrp www-data /var/www/site
chmod 2750 /var/www/site
# 
# chmod 4750 - setuid rwsr-x---
# 누가 실행하든 해당 파일의 소유자 권한으로 실행
# 실행 파일에 사용됨
ls -l /usr/bin/passwd


%%% {submenu_hidden}awk/sed 변수 사용예제
%%%e {submenu_hidden}awk/sed Variable Usage Examples
# 네모
awk 'BEGIN{OFS=""; ORS="\n"; for(i=1; i<=5; i++){for(j=1; j<=5; j++)$j="#"; print}}'
# 세모
awk 'BEGIN{OFS=""; ORS="\n"; for(i=1; i<=5; i++){for(j=1; j<=i; j++)$j="#"; print}}'
# 여러 개의 연속된 공백을 하나의 공백으로 
df | sed 's/ \+/ /g'
df | awk '{$1=$1}1'




%%% {submenu_hidden}dialog [dia]
%%%e {submenu_hidden}dialog [dia]
# msgbox
dialog --title "Message" --msgbox "This is a sample message box." 10 50
height=$(($(tput lines)*70/100)) ; width=$(($(tput cols)*70/100)); dialog --title "Message" --msgbox "This is a sample message box." $height $width
# yesno
dialog --stdout --title "Question" --yesno "Do you want to continue?" 10 50 ; echo "You chose: $?"
# inputbox
dialog --stdout --title "Inputbox - To take input from you"  --backtitle "Linux Shell Script Tutorial" --inputbox "Enter your name please" 8 60 
# checklist
CHOICES=$(dialog --stdout --checklist "Choose toppings:" 10 40 3 1 Cheese on 2 "Tomato Sauce" off 3 Anchovies off ); fclear; echo "You chose: $CHOICES"
# menulist
CHOICE=$(dialog --stdout --title "Menu" --menu "Choose an option:" 10 30 3 1 "Option 1" 2 "Option 2" 3 "Option 3" ); fclear; echo "You chose: $CHOICE"
# radiolist
CHOICE=$(dialog --stdout --title "Radio Menu" --radiolist "Choose an option:" 10 30 3 1 "Option 1" off 2 "Option 2" off 3 "Option 3" off ); fclear; echo "You chose: $CHOICE"
# progress
for i in `seq 1 100`; do echo $i; sleep 0.02; done | dialog --gauge 'File copy progress'  10 60
# update example
dialog --title "System Update" --yesno "Do you want to update the system?" 10 60; response=$?; case $response in 0) echo "System update in progress..." && apt-get update && apt-get upgrade;; 1) echo "Update cancelled.";; esac
# proxmox pct example
vmid=$(dialog --title "VMID Selection" --menu "Choose VMID from the following list:" 22 76 16 $(pct list | awk 'NR>1 {print $1,$3"__"$2}') 3>&1 1>&2 2>&3); fclear; cmd=$(dialog --title "PCT Command" --menu "Choose command" 22 76 5 1 "Start" 2 "Stop" 3 "Reboot" 4 "Config" 5 "Enter" 3>&1 1>&2 2>&3); fclear; case $cmd in 1) cmd="start";; 2) cmd="stop";; 3) cmd="reboot";; 4) cmd="config";; 5) cmd="enter";; esac; fclear; if [ -n "$vmid" ]; then fclear && echo "Executing 'pct $cmd $vmid'" && pct $cmd $vmid; else fclear && echo "No VMID selected."; fi ; echo ; pct list |cgrep1 running
# proxmox qm example
vmid=$(dialog --title "VMID Selection" --menu "Choose VMID from the following list:" 22 76 16 $(qm list | awk 'NR>1 {print $1,$2"__"$3}') 3>&1 1>&2 2>&3); fclear; cmd=$(dialog --title "QM Command" --menu "Choose command" 22 76 4 1 "Start" 2 "Stop" 3 "Reset" 4 "Config" 3>&1 1>&2 2>&3); fclear; case $cmd in 1) cmd="start";; 2) cmd="stop";; 3) cmd="reset";; 4) cmd="config";; esac; fclear; if [ -n "$vmid" ]; then fclear && echo "Executing 'qm $cmd $vmid'" && qm $cmd $vmid; else fclear && echo "No VMID selected."; fi ; echo ; qm list |cgrep1 running
# fdialog (행변수) / fdialog1 (열변수)
declare -f fdialog;echo; declare -f fdialog1
/bin/df -h | fdialog
ls -1 / | fdialog
ls -ld /* | grep ^d | awk '{dir=$NF; $NF=""; print dir,$0}' | fdialog
ls -ld /* | grep ^d | awk '{dir=$NF; $NF=""; print dir,$0}' | fdialogw
ls | fdialog1
eval $( echo env top htop bashtop neofetch iftop dfmonitor | fdialog1 ) 
# install
yyay dialog


%%% {submenu_hidden}luit compile [luit]
%%%e {submenu_hidden}luit compile [luit]
# ubuntu 24. which luit ... "" - source compile
# encoding chg
git clone https://git.launchpad.net/ubuntu/+source/luit
cd luit
apt update
apt install build-essential pkg-config git autoconf automake libtool xutils-dev
apt install libx11-dev libfontenc-dev zlib1g-dev
./configure
make
make install
which luit
luit -encoding EUC-KR ssh varADD



%%% {submenu_hidden}telegram cli [tg]
%%%e {submenu_hidden}telegram cli [tg]
# https://github.com/vysheng/tg
cd ~/ ; git clone --recursive https://github.com/vysheng/tg.git && cd tg
# http://core.telegram.org/api
apt-get install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython-dev make 
cd ~/tg/ ; ls -al 
explorer ~/tg/
# make 
./configure
make



%%% {submenu_hidden}stress [stress]
%%%e {submenu_hidden}stress [stress]
# 단일 코어 부하 주기: yes
yes > /dev/null & ;; jobs
kill %1
kill %2
jobs
kill -9 `jobs -p`
# dd + 해시 계산 // 여러 코어에 부하 분산
dd if=/dev/zero | md5sum > /dev/null & ;; jobs
kill %1
pkill dd
# 수학 계산으로 부하 주기: bc 로 원주율 계산
echo "scale=5000; 4*a(1)" | bc -l > /dev/null & ;; jobs
# stress
yyay stress-ng
# CPU 코어 4개에 60초 동안 부하 주기
stress-ng --cpu 4 --timeout 60s
# 모든 CPU 코어에 60초 동안 부하 주기
stress-ng --cpu 0 --timeout 60s


%%% {submenu_hidden}search gosh menu [sear]
%%%e {submenu_hidden}search gosh menu [sear]
%% echo "ex) search mail"
search varMenu

%%% {submenu_hidden}test menu [test]
%%%e {submenu_hidden}test menu [test]
# test menu ---> conf [Enter] && play 
# 쉼표 하나는 쭉 실행. 쉼표 두개는 앞에거 실행후 뒤에꺼 실행
# 실행전 var 변수가 보이면 변수값 요청 
printarr shortcutarr # scr
echo "$shortcutstr" ;; echo "$shortcutstr" | cgrep varA  # sc
ls -d /var/log/* ; tail -f varLogFile
ls -d /var/log/* ;; tail -f varLogFile
tail -f $( ls -d /var/log/* | pipemenu1 ) 
echo varVAR__abc ; echo varVAR
echo varVAR__abc ;; echo varVAR
echo varVAR__abc.conf ;; echo varVAR
echo varVAR.conf ;; echo varVAR__.conf
echo varVAR__abc@@dd ;; echo varVAR
echo varVAR__a@space@b ;; echo varVAR |less -RX
echo $( echo "a b c" | pipemenu what you want )
echo $( echo "a b c" | pipemenu )
echo $( echo "a b c" | pipemenu )
# var default value -> space_add @space@
systemctl varVAR__disable@space@--now__enable@space@--now atd ;; systemctl status atd
bell
# VAR set ? 
echo varVAR ; echo varVAR
echo varVAR ;; echo varVAR
: abc : def ; echo varVAR
# space -> , chg 
echo "varVMSnospace"
echo "hihihi hohooho hahaha" ; echo $lastarg
echo "hihihi hohooho hahaha" ;; echo $lastarg
#
vara=abcc ;; varVAR=$vara ;; echo "varVAR -> $varVAR"
# Caution commands
!!! echo varVAR ;; echo varVAR
# VAR reuse or bug check or setpass
echo varVAR__ ;; echo varVAR__reuse ;; echo varVAR___
echo varVAR__a__b__c  ;; echo varVAR
echo varVAR__i@space@love@space@you__b__c  ;; echo varVAR
echo "varVAR__100__200__300"G ; stg="varVAR" ; echo "your stg set : ${stg}G"
echo "varVAR__\"100\""
# var export
a=varA ; echo $a
a=varA ;; echo $a
export a=varA ;; echo $a
echo $a
env | sort | cpipe | less -rX
tac $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) |cpipe|less -RX 
tac $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) |cpipe|less 
tac $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) |less -RX
tac $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) |cpipe
tac $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) 
f=$( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) ; echo $f
find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu


%%% {submenu_hidden}test menu 2page [test2]
%%%e {submenu_hidden}test menu 2page [test2]
# 활성변수확인
declare -p
set
# 지역변수
declare -p | grep -v 'declare -x'
# 환경변수
declare -p | grep 'declare -x'
# gosh변수 ex) varVAR
a=varVARa ;; echo "varVARa" ;; echo $a
b=varVARb ;; echo "varVARb" ;; echo $b
declare -p | grep "^declare -x var[A-Z]"
declare -p | grep "^declare -x var[A-Z]" | awk3
# save & exit 
declare -p | grep '^declare -x var' > ~/.go.private.var ; chmod 600 ~/.go.private.var
# save incremental
declare -p | grep '^declare -x var' >> ~/.go.private.var ; chmod 600 ~/.go.private.var
# load 동일한 변수가 기록된 경우 가장 나중에 기록된 변수가 활성화
echo "varVARa:$varVARa // varVARb:$varVARb" # load 전 
cat ~/.go.private.var
# 변수를 가져와야 하나, 서브쉘에서 source 가 되어 부모쉘에서 쓸수가 없음
# go.sh 에서 source 불러오면 작동가능
source ~/.go.private.var 
declare -p | grep 'varVAR'
echo "varVARa:$varVARa // varVARb:$varVARb" # load 전 
# gosh변수 저장 -> 스크립트 재시작시 불러오기
saveVAR
# go.sh auto load
loadVAR
ff saveVAR ;; ff loadVAR
echo -e "사과\n바나나\n오렌지\n사과\n바나나\n포도" | seen
echo -e "사과\n바나나\n오렌지\n사과\n바나나\n포도" | lastseen
echo "varPKG__lynx__power_up__enable@space@--now__space@space@power__screen__bat__at__net-tools__apt-file"
echo "$(echo $base $basefile $readlinkf |pipemenu)" 
echo "varA varAA varAAA"
declare -f vi2
declare -f ff
declare -f varFunc__vi2
declare -f varVAR__vi2
declare -f varVAR__ff
declare | wc -l 
declare |grep vi2
declare |grep ff
vi2="" ; ff vi2




%%% {submenu_hidden}one menu test [testone]
%%%e {submenu_hidden}one menu test [testone]
echo "Hello go.sh" && sleep 1





%%% {submenu_hidden}test3 [test3]
%%%e {submenu_hidden}test3 [test3]
%% echo "1. xxx"
# pre excute menu 가 돌아가기 때문에 이곳에 스크립트를 불러와 실행할 수도 있다.
# 너가 만든 그 스크립트!!!!!!!!!!!!!
%% [ -f ~/test.sh ] && bash test.sh 
# 테스트로 top 를 출력하는 test.sh 를 생성한다.
echo "top -bn 1|head -n10" > ~/test.sh
# 생성후 이메뉴에 재진입하면, ~/test.sh 가 바로 실행된다.
# 이제 언제 써먹으면 좋을지 생각한다.
cat ~/test.sh
rm ~/test.sh
echo "1 only one menu ; direct execute ; kiss me?"
%% dline
%% echo "2. xxx"
echo "2 only one menu ; direct execute ; kiss me?"
%% echo "3. xxx"
echo "3 only one menu ; direct execute ; kiss me?"
echo "varA_isvara"
echo "varA_"
echo "varA__"
echo "varA___"
echo "varA__a_b"
echo "varA__a_b__c_d___e_f"
echo "varA__a_b__c_d___e_f____g_h"
echo up_down updown up down downup




%%% {submenu_hidden}test menu 4page [test4]
%%%e {submenu_hidden}test menu 4page [test4]
%% echo "VAR1: $VAR1 VAR2: $VAR2"
# @@ -> / 
echo "varVAR__@@etc@@fstab__@@etc@@network"
# direct / -> not var Element
echo "varVAR__/etc/fstab__/etc/network"
echo "varVAR__abc.com__bbc.com"
echo "varVAR.abc.com"
echo "varVAR@varVARR__abc@bbb.com"
# 변수기본값도 있지만 이전 사용한 값도 있을때.. 사전값우선
echo "varVAR" ;; echo "varVAR__abc" 
#
# HereDocument auto var chg // cat << EOF > file // cf. cat << 'EOF' > file
template_edit heredocutest.conf
# 환경변수가 보이면 자동으로 변환 되어 출력 'EOF' 대신 EOF 로 해야 작동 
export VAR1="change1" ; export VAR2="change2" 
# 변수값 직접 지정
export VAR1="varVAR1" ; export VAR2="varVAR2"
template_view heredocutest.conf 
!!! template_copy heredocutest.conf ~/heredocutest.conf ;; cat ~/heredocutest.conf | cgrep1 VAR1 change
change ~/heredocutest.conf VAR1 varvarvar ;; cat ~/heredocutest.conf
vi ~/heredocutest.conf
rm -f ~/heredocutest.conf
echo -e "-3rd line\n-2nd line\n-1st line\nfor your service\n1st line\n2nd line\n3rd line" > tmp.$datetag.txt ;; ls -al tmp.$datetag.txt ;; cat tmp.$datetag.txt
hash_add tmp.$datetag.txt "for" 
hash_add tmp.$datetag.txt "for" 2
hash_add tmp.$datetag.txt "for" -2
hash_add tmp.$datetag.txt "for" +-2
hash_remove tmp.$datetag.txt "for" 2
hash_remove tmp.$datetag.txt "for" -2
hash_remove tmp.$datetag.txt "for" +-2
hash_remove tmp.$datetag.txt "for" 
hash_restore tmp.$datetag.txt
cat tmp.$datetag.txt
vi tmp.$datetag.txt
rm -f tmp.$datetag.txt
vi2 $(ls -1 |pipemenu)
vi2 varS__a__b__c__.bashrc
vi3 a b c .bashrc
: x ; vi2 varPath__$(ls -1)
: x ; echo varPath__$(pwd)
: x ; echo varPath__Excute_ls-1
echo abcvarPort__22
cd /etc/ ; las -al
echo "$(readlink /etc/pve/local)"
echo "$(basename "$(readlink /etc/pve/local)")"



%%% {submenu_hidden}test menu 5page [test5]
%%%e {submenu_hidden}test menu 5page [test5]
echo "varTime__12@colon@00"
echo "varNo__1__1abc__12__12@dot@11__12@space@12__11@colon@11__99@colon@99"
echo "abcvarNN__aaa"
echo "-pvarPosrt__22"
echo "varPassword"
echo "varPW"
echo "lkfjea jfelk8eyu aefae 8e7wfah jefkajf fffje fkajf feaf e89ea jklefajf el7ew" |cgrepn e89ea 8e7wfah  
echo "lkfjea jfelk8eyu aefae 8e7wfah jefkajf fffje fkajf feaf e89ea jklefajf el7ew" |cgrepn e89ea 8e7wfah  -1
echo "lkfjea jfelk8eyu aefae 8e7wfah jefkajf fffje fkajf feaf e89ea jklefajf el7ew" |cgrepn e89ea 8e7wfah  -2
echo "lkfjea jfelk8eyu aefae 8e7wfah jefkajf fffje fkajf feaf e89ea jklefajf el7ew" |cgrepn e89ea 8e7wfah  1
echo "varID:varID"
echo "varID-varID"
echo "varID varID"
echo "varID varIDD"
echo "up.varID varIDD"
ls ; cat varFile
ls ;; cat varFile
df -h | cpipe |column -t
cmd=$( echo "echo cat" | pipemenu ) ; $cmd 1






%%% {submenu_hidden}update log [logg]
%%%e {submenu_hidden}update log [logg]
# 250320 local llm gemma3 -> after install -> everywhere 'hi'
# 250321 b / bb shortcut -> move back or 2back
# 250321 shortcut use everywhere
# 250322 saveVAR func -> exit & exec gosh -> reuse varVAR ~/.go.private.var
# 250323 menu move logic improve (relay menu)
# 250324 array use -> exec go.sh drop -> menufunc {sub} {title} // stop restart go.sh
# 250324 cat go.my.env >> go.env / Add server-specific go.my.env
# 250325 varVAR default value -> mult select or all select available
# 250326 assh func edited >> euc-kr encoding add ( old server ssh -> kr crash )
# 250326 .go.env tmpfile read/write >> disk -> mem chg ( i/o down ) /dev/shm/.go.tmp
# 250326 No match, trying .bashrc alias: cmd_choice & choice
# 250326 last if choice cmd_choice ---> if -> case chg 
# 250327 cmd 메뉴 탈출 bug check (재귀호출로 인한 bug -> break / continue 로 해결)
# 250328 change insert eprintf func add
# 250329 varVAR path "/" add && varVAR__ bug fix 
# 250331 hash_add hash_remove func ex) hash_add filename "search" -> "^#....search"
# 250401 nagios edit
# 250401 teldrive daemon add [tel] // teldrive docker [dkt] // teldrive rclone [telr]
# 250402 unset var -> unset -v var chg ( func delete bug )
# 250403 history update check // ctrl d -> quit
# 250406 pre_commands bug fix // varPassword hide
# 250407 load func - anilize load avg // ff func - reculsive declare -f 
# 250414 ranger 경로 저장 $(</dev/shm/pwd) ;; cd path -> 저장하여 ranger 에서 사용 eee
# 250415 certbot - wild card ssl - hook 이용하여 auto publish && renew 
# 250419 docker update
# 250422 watch_pve func 
# 250423 vm func ( all of vm command ) 
# 250424 pipemenu cancel no.0 fix // pipemenu1 pipemenulist all fix 
# 250426 move move move highlight
# todo 
# todo var_valeu ' " bug
# todo echo varPath__Excute_ls-1 
conf





%%% {submenu_hidden}go.sh GitHub push [gosh]
%%%e {submenu_hidden}go.sh GitHub push [gosh]
%% echo "GITHUB_TOKEN: $GITHUB_TOKEN"
%% ls -al $base/go.sh
%% ls -al $base/go.env
# go.sh github push
cd ~ ; git clone https://github.com/forsys02/linux_console_manager.git
cd ~/linux_console_manager
explorer ~/linux_console_manager
#
git status
git diff go.env /script/go.env
git diff go.sh /script/go.sh
cp -a /script/go.{env,sh} ~/linux_console_manager/ && git add go.env go.sh && git commit -m "update"
git push origin main
# auto push (do not write id/token)
export GITHUB_TOKEN="varTOKEN" 
git push https://forsys02:${GITHUB_TOKEN}@github.com/forsys02/linux_console_manager.git main
#
shfmt -i 4 -s -w $gofile
#### all_in_one ####
shfmt -i 4 -s -w /script/go.sh ; cd ~/linux_console_manager ; cp -a /script/go.{env,sh} ~/linux_console_manager/ ; git add go.env go.sh && git commit -m "update" && git push https://forsys02:${GITHUB_TOKEN}@github.com/forsys02/linux_console_manager.git main
# auth
git remote -v
# Personal Access Token
# -> github.com login, Settings -> Developer settings -> Personal access tokens -> Generate new token
# env add
echo "GITHUB_TOKEN=varTOKEN" >> ~/go.private.env && . ~/go.private.env
vi2 ~/go.private.env





%%% {submenu_hidden}debug menu [debug]
%%%e {submenu_hidden}debug menu [debug]
### gosh debug 
: on ; debugon
: off ; debugoff
head $base/go.sh
#
# shell-check 
apt install shellcheck
shellcheck $gofile | cgrep warning | cgrep1 info style | less -RX
#
# re-format (Google Shell Style Guide)
apt install shfmt
shfmt -i 4 -s $gofile | less -RX
shfmt -i 4 -s $gofile > ~/go.sh.shfmt
cdiff $gofile ~/go.sh.shfmt
vi2 ~/go.sh.shfmt
# backup ymdhms
cp -a $gofile ~/go.sh.$(datetag2)
!!! cp -a ~/go.sh.shfmt $gofile
# write now
!!! shfmt -i 4 -s -w $gofile
#
# func list 
grep -E '^[a-zA-Z0-9_]+\(\) \{' $gofile | awk '{print $1}' | tr -d '()' |sort -u | paste -s -d' ' -
# func view 
declare -f $(grep -E '^[a-zA-Z0-9_]+\(\) \{' $gofile | awk '{print $1}' | tr -d '()' |sort -u | pipemenu) 
# func edit
conff "varFunc()"














%%% {submenu_hidden}ansi code [ansi]
%%%e {submenu_hidden}ansi code [ansi]
%% echo ; { echo -e "\033[0m TcBc: Reset \033[0m [0m] \033[1m Tc: Bold \033[1m [1m] \033[3m Tc: Italic \033[0m [3m]\n\033[4m Tc: Underline \033[0m [4m] \033[7m Bc: Invert \033[0m [7m] \033[9m Tc: Strike \033[0m [9m]\n\033[22m Bold off \033[0m [22m] \033[23m Italic off \033[0m [23m] \033[24m Under off \033[0m [24m]\n\033[27m Invert off \033[0m [27m] \033[29m Strike off \033[0m [29m] \033[30m Tc: Blk \033[0m [30m]\n\033[31m Tc: Red \033[0m [31m] \033[32m Tc: Grn \033[0m [32m] \033[33m Tc: Yel \033[0m [33m]\n\033[34m Tc: Blu \033[0m [34m] \033[35m Tc: Mag \033[0m [35m] \033[36m Tc: Cyn \033[0m [36m]\n\033[37m Tc: Wht \033[0m [37m] \033[39m Default Tc \033[0m [39m] \033[40m Bc: Blk \033[0m [40m]\n\033[41m Bc: Red \033[0m [41m] \033[42m Bc: Grn \033[0m [42m] \033[43m Bc: Yel \033[0m [43m]\n\033[44m Bc: Blu \033[0m [44m] \033[45m Bc: Mag \033[0m [45m] \033[46m Bc: Cyn \033[0m [46m]\n\033[1;47m Bc: Wht \033[0m [1;47m] \033[49m Default Bc \033[0m [49m]" ;echo "-";echo "-";echo; paste <(for i in `seq 40 47`; do echo -e "\033[01;37;${i}m ABCDEFG [1;37;${i}m] \033[0m"; done) <(for i in `seq 40 47`; do echo -e "\033[01;4;37;${i}m ABCDEFG [1;4;37;${i}m] \033[0m"; done) <(for i in `seq 30 37`; do echo -e "\033[0;4;5;${i};47m ABCDEFG [0;4;5;${i};47m] \033[0m"; done); } | column -t ; echo -e "\033[0m" 
#
for code in $(seq 0 107); do printf "\\e[${code}m%s\\e[0m\\n" "ANSI Code $code"; done |less -RX
echo -e "\\e[1;33;44m e escape code \\e[0m"
echo -e "\\033[1;33;44m 0133 8bit 27 escape code \\e[0m"
echo -e "\\x1b[1;33;44m x1b 16bit 27 escape code \\e[0m"
# 안시 제거
echo -e "\\033[1;3m2;2;3m\\033[0m" | perl -p -e 's/\\e\[[0-9;]*[MKHJm]//g' 2>/dev/null



%%% SSL 인증서 LetsEncrypt [ssl] (sslw,sslwr)
%%%e SSL Certificate LetsEncrypt [ssl] (sslw,sslwr)
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
# 내도메인 정보 환경파일에 넣거나 직접 입력 
[ ! "$mydomain" ] && echo "mydomain=varMyDomain" >> ~/go.private.env && . ~/go.private.env
export mydomain=varMyDomain
# dns-01 챌린지 과정중 나오는 txt 레코드 복사후 도메인 네임서버 등록사에 가서 등록
# ex) _acme-challenge.yourdomain.com.  IN  TXT "Somewhat long key string"
# 레코드 등록에 시간이 소요될 수 있으며 챌린지 실패시 시간 간격을 두어 재시도
# txt 레코드는 총 2회 인증 요청됨 (인증실패가 계속되면 일정시간 블락)
certbot certonly --manual --preferred-challenges dns --manual-public-ip-logging-ok --agree-tos --no-bootstrap --server https://acme-v02.api.letsencrypt.org/directory -d "$mydomain" -d "*.$mydomain"
# webroot key 로 인증하여 인증서 발급 // 와일드카드 인증서는 webroot 방식으로는 불가
export webroot_path="varWWWrootPath__@@var@@www@@html" ; export cert_email="varYourEmail"
certbot certonly --webroot -w "$webroot_path" -d "$mydomain" -d "www.$mydomain" -d "m.$mydomain" -d "webmail.$mydomain" -d "mail.$mydomain" --agree-tos -m "$cert_email"
# 발급받은 인증서는 3개월간 유효 (2개월후부터 갱신가능)
ls -al /etc/letsencrypt/live/$mydomain/; cat /etc/letsencrypt/live/$mydomain/fullchain.pem; cat /etc/letsencrypt/live/$mydomain/privkey.pem
# 유효기간 확인 및 스케즐 등록 
certbot certificates | cgrepn Domains Validity 10  # 유효기간 확인
certbot certificates ;; alarm 00001100varExdate__61 "$mydomain SSL 인증서 발급 varExdate__61일이 지났습니다. 수동 갱신하세요." 
# 인증서 자동 갱신 crontab 일요일 새벽 3시 dry-run 으로 체크요망 
echo "0 3 * * 0 /usr/bin/certbot renew --webroot -w /var/www/html --quiet" >> /etc/crontab
# 최신 방식: systemd 타이머 기반 자동 갱신 certbot.timer -> crontab 추가 할필요없음
systemctl status certbot.timer ;; systemctl list-timers | grep certbot
# 자동 갱신을 위해선 doamin txt key 인증받은것과 마찬가지로 인증이 필요하며
# 아래 방법은 웹루트에 토큰파일을 자동으로 심어서 인증받는 방법으로 갱신 
certbot renew --webroot -w varWWWrootPath__@@var@@www@@html --dry-run
# 인증서 수동 갱신 (3개월이전)
certbot renew --manual-public-ip-logging-ok --force-renewal
# nginx apply sample
echo -e "server { \n    listen 443 ssl default_server;\n    http2 on;\n    server_name $mydomain *.$mydomain;\n    root /source;\n    ssl_certificate /etc/letsencrypt/live/$mydomain/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/$mydomain/privkey.pem;\n}\n"
# apache2 apply sample
vi2 /etc/apache2/sites-available/$mydomain.conf
echo -e "<VirtualHost *:443>\n  ServerName $mydomain\n  ServerAlias *.$mydomain\n  DocumentRoot /var/www/html\n  SSLEngine on\n  SSLCertificateFile /etc/letsencrypt/live/$mydomain/fullchain.pem\n  SSLCertificateKeyFile /etc/letsencrypt/live/$mydomain/privkey.pem\n  CustomLog ${APACHE_LOG_DIR}/access.log combined\n  ErrorLog ${APACHE_LOG_DIR}/error.log\n</VirtualHost>\n"
systemctl reload nginx || systemctl reload apache2
explorer /etc/letsencrypt/renewal/
yyay certbot
: wildcard ssl; sslw


%%% {submenu_sys}SSL Wildcard 인증서 자동 발급/갱신 [sslw]
%%%e {submenu_sys}SSL Wildcard Certificate Auto Renewal [sslw]
%% [ "$mydomain" ] && echo "Mydomain: $mydomain / MyEmail: $myemail / zone_file:$zone_file / certpath:$certpath" 
# wild card *.domain 갱신할 도메인 설정 / bind9 등 직접 네임서버 운영기준 
# 네임서버가 구동중인 서버에서 작업 - hook 파일을 이용하여 자동화
export mydomain="varMyDomain" 
export myemail="varEmail"
export zone_path="varZonepath__@@etc@@bind" ; export zone_file="$zone_path/db.$mydomain" ; ls -l $zone_file 
# 도메인 챌린지용 txt 레코드 획득 및 zone 추가/ *.domain 인증서 발급 / txt 제거 
mkdir -p /etc/letsencrypt/scripts/ 
template_view hook.sh 
template_copy hook.sh "/etc/letsencrypt/scripts/hook-${mydomain}.sh"; f="$_" && [ -f $f ] && chmod +x $f && cat $f
template_view cleanup.sh
template_copy cleanup.sh "/etc/letsencrypt/scripts/cleanup-${mydomain}.sh"; f="$_" && [ -f $f ] && chmod +x $f && cat $f
# challenge txt 레코드 확인후 인증서 발급 // 레코드 삭제 
# Wild card 인증서 자동발급 -> 갱신 자동 갱신(cron)
certbot certonly --manual --preferred-challenges dns --manual-auth-hook "/etc/letsencrypt/scripts/hook-${mydomain}.sh" --manual-cleanup-hook "/etc/letsencrypt/scripts/cleanup-${mydomain}.sh" --agree-tos --no-eff-email --email $myemail -d "$mydomain" -d "*.$mydomain"
cat $zone_file
# 인증서 확인
ls -l /etc/letsencrypt/live/ ; echo ; find /etc/letsencrypt/live/ -mmin -10 ; readxy "cat?" && cat3 $( find /etc/letsencrypt/live/ -mmin -10 ) 
vi3 /etc/letsencrypt/scripts/hook-${mydomain}.sh /etc/letsencrypt/scripts/cleanup-${mydomain}.sh /etc/letsencrypt/scripts/renew-${mydomain}.sh 
# 인증서 갱신 cron 작업 / 6일에 한번씩 갱신시도 / (90일 유효에 60일부터 갱신가능)
export certpath=$( ls -1 /etc/letsencrypt/live/ |grep "\." | pipemenu ) 
template_view renew.sh
template_copy renew.sh "/etc/letsencrypt/scripts/renew-${mydomain}.sh"; f="$_" && [ -f $f ] && chmod +x $f && cat $f
# dry-run -> 아래 출력물을 마우스로 복사하여 실행한다.
echo "$(cat /etc/letsencrypt/scripts/renew-${mydomain}.sh) --dry-run"
# cron
echo "0 6 */6 * * root /etc/letsencrypt/scripts/cert_renew-${mydomain}.sh >> /var/log/renew_cert.log 2>&1" >> /etc/crontab ;; tail /etc/crontab
vi2 /etc/crontab
cat /var/log/renew_cert.log | cpipe | less -RX +G
# 기존에 개별 인증서 부분은 와일드카드 인증서로 교체
# apache / mail 등 
#
# 불필요 인증서 삭제
cert=$( ls -1 /etc/letsencrypt/live/ | grep "\." | pipemenu ) && [ -f "/etc/letsencrypt/live/$cert" ] && certbot delete --cert-name $cert
explorer /etc/letsencrypt/live/ /etc/letsencrypt/renewal/ /etc/letsencrypt/scripts/ $HOME
template_edit hook.sh cleanup.sh renew.sh hookremote.sh



%%% {submenu_sys}원격 DNS 기반 Wildcard SSL (sshfs + certbot) [sslwr]
%%%e {submenu_sys}Remote Wildcard SSL via SSHFS+Certbot [sslwr]
%% [ "$yourdomain" ] && echo "yourdomain: $yourdomain $yourdomaincut / Email: $myemail / zone_file:$zone_file"
%% echo "sshrhost:$sshrhost / rzone_path: $rzone_path"
# wild card *.domain 갱신할 도메인 설정 / 네임서버가 원격에 존재
# 원격에서 네임서버가 구동중인 서버로 접근 - hook 파일을 이용하여 자동화
export yourdomain="varYourdomain" ;; export yourdomaincut=${yourdomain%%.*} 
[ -z "$myemail" ] && export myemail="varEmail"
export zone_path="varZonepath__@@mnt@@remote_named" ; export zone_file="$zone_path/$yourdomaincut.zone"
export sshrhost="varSSHRhost" ; export rzone_path="varRZonepath__@@var@@named" 
# 1) 로컬 마운트 디렉토리 생성 후 sshfs 마운트 (이미 마운트됐으면 스킵)
mkdir -p "$zone_path" && mountpoint -q "$zone_path" || sshfs -o reconnect,ServerAliveInterval=5,ServerAliveCountMax=3 "$sshrhost:$rzone_path" "$zone_path" ;; df -h
# 1-2) mount check
df -h | cgrepline "$rzone_path" ; echo;; ls -ltr "$zone_path" | tail ;; tail $zone_file
# 2) 후크 스크립트 템플릿 복사 및 실행 권한 부여
template_view hook-sslwr.sh 
template_copy hook-sslwr.sh "/etc/letsencrypt/scripts/hook-sslwr-${yourdomain}.sh"; f="$_" && [ -f $f ] && chmod +x $f && cat $f
vi2 /etc/letsencrypt/scripts/hook-sslwr-${yourdomain}.sh
# 3) certbot DNS‑01 인증 및 발급 (auth+cleanup hook 지정) (rsa2048)
certbot certonly --manual --preferred-challenges dns --manual-auth-hook "/etc/letsencrypt/scripts/hook-sslwr-$yourdomain.sh auth-hook" --manual-cleanup-hook "/etc/letsencrypt/scripts/hook-sslwr-$yourdomain.sh cleanup-hook" --key-type rsa --rsa-key-size 2048 -d "*.$yourdomain" -d "$yourdomain" --agree-tos --manual-public-ip-logging-ok --email "$myemail" -v
# 4) txt 레코드 추가 된것 확인후, 원격 네임서버(named) 재시작
tail -f $zone_file
: systemd; find $zone_path/reload.flag -mmin -3 -exec rm {} \; && ssh "$sshrhost" "systemctl restart named" || echo "[!] Failed." >&2
: init.d; find $zone_path/reload.flag -mmin -3 -exec rm {} \; && ssh "$sshrhost" "/etc/init.d/named restart" || echo "[!] Failed." >&2
# 5) DNS 전파 확인 (dig으로 TXT 레코드 조회)
dig +short TXT _acme-challenge."$yourdomain" @$sshrhost
dig +short TXT _acme-challenge."$yourdomain" @8.8.8.8
# 6) 발급된 인증서 확인 / 해당 서버에 복사 
echo $yourdomain ; ls -al "/etc/letsencrypt/live/$yourdomain" | cgrep $yourdomain
openssl x509 -in "/etc/letsencrypt/live/$yourdomain/cert.pem" -noout -text | grep DNS: | cgrep $yourdomain
cp -arL /etc/letsencrypt/live/$yourdomain $zone_path/ ;; ls -al $zone_path/|grep $yourdomain ;; ls -al $zone_path/$yourdomain ; chmod 711 $zone_path/$yourdomain
# install
yyay sshfs 
umount -l $zone_path 2>&1 | cgrep target is busy ;; df -h | cgrep $zone_path
template_edit hook-sslwr.sh




%%% {submenu_sys}인코딩/ 디코딩/ 암호화/ 복호화 [enc]
%%%e {submenu_sys}Encoding/Decoding/Encryption/Decryption [enc]
# web - url{en,de}coding
echo "varWORD" | od -t x1 -A n | tr " " %
echo "varENCWORD" | echo -en "$(sed 's/+/ /g; s/%/\\x/g')"
#
# base64 {en,de}coding 이진 데이터를 ASCII 문자열로 변환 (메일의첨부파일등) 
echo "varWORD" | base64
echo "varENCWORD" | base64 --decode
# base64 (perl) 
echo "varWORD" | perl -MMIME::Base64 -ne 'print encode_base64($_);'
echo "varENCWORD" | perl -MMIME::Base64 -ne 'print decode_base64($_)'
#
# 암호화/복호화 
key=varKEY__mykey; echo -n "varWORD" | openssl enc -aes-256-cbc -e -k $key -A -a -pbkdf2 -iter 100000 ; echo
key=varKEY__mykey; echo -n "varENCWORD" | openssl enc -aes-256-cbc -d -k $key -A -a -pbkdf2 -iter 100000 ; echo
# old_openssl
key=varKEY__mykey; echo -n "varWORD" | openssl enc -des-ede3-cbc -e -k $key -A -a ; echo
key=varKEY__mykey; echo -n "varENCWORD" | openssl enc -des-ede3-cbc -d -k $key -A -a ; echo
# encrypt / decrypt func
declare -f encrypt ; echo ; declare -f decrypt
echo varWORD | encrypt varKEY__key
echo varEncWORD | decrypt varKEY__key
echo varWORD | encrypt varKEY__key | decrypt varKEY__key 




%%% {submenu_sys}로그인시 go.sh 자동실행 설정 [startup]
%%%e {submenu_sys}Enable go.sh Auto Start on Login [startup]
%% echo "gofile: $gofile"
export gofile="varGoPath"
# .bashrc 에 로그인후 표준 출력이 터미널인 경우에 go.sh 실행 ( scp 같은 경우 실행x ) 
# 이미 go.sh 실행상태인지 체크하여 선별적으로 구동 
echo "if [[ -t 1 ]] && [[ \$- == *i* ]] && [ -z \"\$guestip\" ] && [ -x $gofile ]; then $gofile || echo \"go.sh failed. You are now in bash shell.\"; fi" >> ~/.bashrc && tail ~/.bashrc
tail ~/.bashrc | cgrep1 go.sh 
vi2 ~/.bashrc
# 비활성화 주석처리 
hash_add ~/.bashrc "go.sh failed. You are now in bash shel" 
#
#
# 디스크립터 의미
# -t 0	표준 입력이 터미널인가?
# -t 1	표준 출력이 터미널인가?
# -t 2	표준 에러가 터미널인가?


%%% {submenu_sys}>flow hidden page [ext1]
%%%e {submenu_sys}>flow hidden page [ext1]
{submenu_lamp_ext}



%%% {submenu_sys}>히든메뉴 [hid]
%%%e {submenu_sys}>Hidden Menu [hid]
{submenu_hidden}



%%% 텔레그램과 푸시알람 [te]
%%%e Telegram and Push Notifications [te]
%% env | grep telegram_
%% [ "$( atqq )" ] && CYN && atqq && RST
%% ps -ef |grep [a]larm_task|awknf8|cgrep "alarm_task_$input"|grep -v "awk"
# 스크립트 에서 텔레그램봇으로 메세지를 전송 
# push - 최초 사용시 텔레그램 정보(챗봇ID,토큰) 입력 (cf. push1 는 정보없으면 bell로 대체)
# ex) push varMSG // echo varMSG | push // push
# 스크립트의 결과를 텔레그램으로 받고 싶을때 사용 
push varMSG__hello.gosh
echo "varMSG__hello.gosh" | push
w | push
# 결과를 명령어와 에러유무를 메세지를 받고 싶을때
eval "sleepdot 10 ; echo i love gosh !!!" ; push "Task ended command: $_  result: $?"
# 결과를 화면과 메세지로 받고 싶을때
sleepdot 10 ; pstree | push
# make 같은 오랜 작업 완료를 메세지로 받고 싶을때 -> 알람용도 
# 인수도 없고 파이프도 없을 경우 $HOSTNAME push 
sleepdot 30 ; bell ; push
# 지정한 시간에 텔레그램으로 푸시 발송
# go.sh 메인화면에서 ex) "005 [Enter]" 타이머 설정가능
# 060 은 60초후 푸시 0060 은 60분후 푸시 00001300 은 13시에 푸시
# alarm 명령어 생략해도 실행 가능 ( 메인/서브 메뉴 선택화면에서 패턴 인식 ) 
alarm 001  
alarm 005 라면타임
alarm 0060 10분 휴식
alarm $( echo 0010 0030 0060 00120 00180 | pipemenu ) 
alarm varTIMESET_0000xy_or_00xy varMSG
# timer 00 // alarm 0000 
alarm 00001700 퇴근 17시에 합시다.
alarm 000020001 내일 20시 축구.
# 알람삭제, 모든알람삭제
atqq ;; atrm varATNUM
atqq ;; for i in $( atq | awk1 ) ; do echo "atrm $i" && atrm $i ; done ;; atqq
# 
# 환경변수 수정
echo "telegram_chatid=varChatID" >> ~/go.private.env 
echo "telegram_token=varToken" >> ~/go.private.env && chmod 600 ~/go.private.env
vi2 ~/go.private.env
#
yyay at curl
# push function 
declare -f varFunc__push__push1__alarm__atqq__sleepdot
: proxmox- alert- telegram push- set menu go ; pxup






%%% 설명서 / 업데이트 [help]
%%%e Manual / Update [help]
%% export PATH=$PATH:$(cd "$(dirname "${0}")" ; echo $(pwd)) ; echo "PATH: $PATH"
%% printf "basefile: $basefile // base: $base \n"
# 리눅스 콘솔에서 서버 관리를 용이하게 할수 있도록 메뉴 구성 
# wget http://byus.net/go.sh && bash go.sh 로 바로 시작가능
# 파일구성 go.sh // go.env // opt. explorer.sh(0.01ver)
# /bin/gosh 로 soft link 생성되어, 최초 실행후 gosh [Enter] 로 진입가능
# go.env 파일에 콘솔 명령어들을 입력 하여 메뉴 화면 구성 
# go.env 수정시 메인메뉴에서 conf [Enter] 하면 백업후 vi 수정모드 
# %%% 로 메인 메뉴 시작 - 빈줄로 메뉴 끝 // %% - 서브 메뉴 시작시 사전 명령 실행
# 메뉴 단축키 지원 [a-zzz] 형식 // 모든 메뉴 선택창에서 단축키 이동지원
# 콘솔에서 직접 입력 명령 그대로 최대한 사용 // 난 객관식 체질인분 환영
# ;; 로 이어진 명령들은 순차적으로 실행 (앞의 결과를 보고 뒤의 변수를 입력 가능)
# var[A-Z][a-zA-Z0-9_.@]* 는 사용자 변수로 직접 입력 지원 
# varABC__default : 사용자변수 끝에 __기본값 형태로 default 값 사전설정 가능 (ex varPort__22)
# 변수 기본값에 경로가 필요한 경우 -> @ 2개 -> / 로 변환됨 
# 명령문에 있는 모든 varABC 가 치환된 후에, bash 에게 전달. 
# ~/go.private.env 개인 환경변수 파일 불러와 이용이 가능. 
# 개인 환경변수 -> var=abc 형태로 등록하며, 스크립트 실행후 env 로 확인가능.
# !!! 는 주의명령으로 명령 실행여부를 한번더 확인 
# 함수 지정하여 호출하여 사용 // go.sh 하단에 함수 설정 예) awk1() { awk '{print $1}' ; }
# 함수 vi2 는 파일 rotate 백업후 vi 를 진행하는 함수 (a a.1.bak ... a.4.bak)
# bash2 기준으로 대부분의 리눅스에서 에러 없이 구동되도록 호환성 유지
# 현재 콘솔 한글 환경을 추적하여 euc-kr/utf8 한글 메뉴 지원 (강제변경지원:ko) 
# locale 을 체크하여 kr 환경이 아닌경우, 영어메뉴 출력 (console)
# redhat / centos / debian / ubuntu 기준 주요 명령어 기재
# 메인메뉴에서 update [Enter] 로 최신 스크립트 다운로드 가능 
# 제작: 손희태 (forsys02@gmail.com)
# https://github.com/forsys02/linux_console_manager
: go.sh update ; update
: go.sh update - github; cd $base ; rbackup go.{sh,env} && rm -f go.{sh,env} ; wget --clobber --no-cache https://raw.githubusercontent.com/forsys02/linux_console_manager/refs/heads/main/go.{sh,env} && bash go.sh $scut
: 로그인 시 go.sh 자동 실행 설정; startup
# $(env) add/edit -> export var (ex. myname=tina)
: edit ; go=$( echo $gofile $envorg $base/go.my.env ~/go.private.env ~/.go.private.var | pipemenu ) ;; [ "$go" != "Cancel" ] && vi2 "$go"
# your private go.env -> init go.my.env --> edit: confmy [Enter]
echo -e "\n\n%%% varTitle_Eng__mymenu [varScut__my]\n%%%e varTitle_Eng [varScut]\nconf\nconfmy\nyour_command_here" >> $base/go.my.env && tail $base/go.my.env && echo -e "\nrestart $basefile" && readx && exec $basefile $scut
# go.sh 내장 함수의 내용을 보고 싶을때 ex) ff func_name
declare -f varFunc__vi2 | { batcat -l bash || cat ; }
declare -f varFunc__update__rbackup__cper__ff__cip__cgrep__idpw__rollback__bell__insert__change__hash_add__hash_remove | { batcat -l bash || cat ; }




