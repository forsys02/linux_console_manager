# 메인메뉴는 %%% 로 시작하고, 메뉴와 메뉴사이는 공백줄로 구분합니다.
# %%% 로 시작하지 않는 문단은 모두 주석처리가 됩니다.
# 즉 이글도 메뉴에 반영이 되지 않는 주석문에 해당됩니다.
# 메모등을 담을 수 있습니다.

# 메뉴의 서브 메뉴를 만들 수 있으며, 아래 예제문을 참조하여 직접 추가하실 수 있습니다.
# %%%e 는 한글환경이 아닌경우 영어메뉴가 출력될때 사용됩니다.
# 특정 메뉴에서 구성을 수정을 하고 싶을때, vi 로 go.env 를 직접열지 않고, 메뉴에서 conf [엔터] 로 바로 수정하실 수 있습니다.




%%% 시스템 정보 / 프로세스 관리 [p]
%%%e System Information / Process Management [p]
%% uname -a ;echo
%% echo "hostname: $(hostname) ; local_ip: $(hostname -i) ; public_ip: $(wget -q -O - http://icanhazip.com)";echo
%% w
# uptime
{ echo -ne "$(date) ; LANG: $LANG\n "; echo ; hostname ; hostname -i ; curl -s icanhazip.com ; echo ; uname -a ; echo ; { lsb_release -a 2>/dev/null && echo ; };  echo ; who am i ; echo ; w ; } | cip
vmstat ; echo ; iostat 2>/dev/null ; free -m ; echo ; df -h |cper
varCMD__env__top__htop__bashtop__neofetch__iftop__dfmonitor
# resource check (tmux window-chg ctrl-b n/p)
tmux -u new-session -d 'bashtop' \; new-window 'top' \; new-window 'iftop' \; new-window 'sh -c "pstree; exec bash"'; tmux attach
# pstree find PID -> ps -ef 
pstree ;; v="$( pstree -pl | grep -E -- "-varFIND__bash\(|-\{varFIND\}" )" ; p="$(echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s|", $i; print ""}' |sed 's/|$//g')" ; echo "$v"|column -t ; [ "$p" ] && echo "$p" && ps -ef|gfind 2 "$p" | cpipe
# pstree find PID -> lsof
pstree ;; v="$( pstree -pl | grep -E -- "-varFIND__bash\(|-\{varFIND\}" )" ; p="$(echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s|", $i; print ""}' |sed 's/|$//g')" ; echo "$v"|column -t ; [ "$p" ] && echo "$p" && lsof|gfind 2 "$p" | cpipe 
# pstree searched PID allkill // not PPID 1
!!! pstree -pl ;; v="$(pstree -pl | grep -E -- "-varFIND__go.sh\(|-\{varFIND\}")" ; p="$( echo $v | awk -F '[()]' '{for(i=2; i<=NF; i+=2) printf "%s ", $i}{print ""}')" ; pg=$(echo $p|tr ' ' '|' |sed 's/|$//g') ; [ "$p" ] && echo "search: $p" && p="$( ps -ef | awk -v pg="$pg" '$2 ~ pg && $3 != 1 {printf "%s ",$2}')" && echo -n "match : $p" ; echo -n "---> kill? [Enter] " ; read x && echo $p | xargs kill
#
# top cpu rank 1~5 PID -> ps -ef
p="$(top -bn1 | head -n30 | grep -A30 "PID USER " | awk 'NR>=2 && NR<=6 && $1>999 {printf "%s|", $1}'|sed 's/|$/\n/g')" ; [ "$p" ] && echo "$p" && ps -ef|gfind 2 "$p"
ps -ef | cpipe | less -RX 
renice -n 19 -p varPID ; ionice -c2 -n7 -p varPID
!!! ps -ef | grep varFIND | awk $3 != 1 '{printf "%s ",$2}' |xargs kill -9 
!!! kill -9 varPID
# last log
last | cip24 | less -RX 
{ last | head -n20 | tac ; echo ; w ; } | cip24
netstat -tulpn | grep -v :::|grep LISTEN|sort -k4 
nmap varHOST__localhost 
yyay varPKG__psmisc__bashtop__htop__neofetch__iftop__tmux__screen__bsdextrautils__less__net-tools__nmap__ncurses__all



%%% 서버 데몬 관리 [d]
%%%e Server Daemon Management [d]
%% pstree | grep -E "httpd|apache|mysql|named|mail" | awk -F '-' '!seen[$2]++ {print $0}' | sort -u
systemctl status | cpipe | less -RX
systemctl status $( systemctl list-unit-files --type=service|grep able|awk -F'.service' '{print $1}'|pipemenu1) 
systemctl --all --type=service
systemctl --all --type=socket
systemctl list-unit-files
systemctl list-unit-files --type=service
systemctl list-unit-files --type=service | grep varFIND
systemctl list-unit-files --type=service --state=enabled 
systemctl list-unit-files --type=service --state=disabled
# daemon stat chg
daemon=$( systemctl list-unit-files --type=service|grep able|awk -F'.service' '{print $1}'|pipemenu1) ;; systemctl varMode__start__stop__restart__status__enable__disable__enable@space@--now__disable@space@--now $daemon ; [ "varMode" != "status" ] && systemctl status $daemon
service $( ls -1 /etc/init.d/ | pipemenu ) $( echo restart start stop status | pipemenu )
#
systemctl start varDaemon && systemctl enable varDaemon ; systemctl status varDaemon
systemctl stop varDaemon && systemctl disable varDaemon ; systemctl status varDaemon
systemctl restart $( systemctl list-unit-files --type=service|grep able|awk -F'.service' '{print $1}'|pipemenu1) 
systemctl status varDaemon
# firewall port open 
firewall-cmd --permanent --add-service=varDaemon__ssh && firewall-cmd --reload
ufw allow varDaemon__ssh
ufw $(echo "enable disable status"|pipemenu)
netstat -tulpn | grep -v :::|grep LISTEN|sort -k4
# daemon on/ off app
: Systemd  ; systemctl-ui || yum install systemctl-ui
: SysVinit ; sysv-rc-conf || apt install sysv-rc-conf
: SysVinit ; ntsysv || yum install ntsysv
# 
explorer $( ls -d /etc/systemd/  /etc/systemd/system/ /etc/rc.d/init.d/ /etc/init.d/ /lib/systemd/system 2>/dev/null | pipemenu ) 
# target mode
systemctl get-default
!!! systemctl set-default multi-user.target
!!! systemctl set-default graphical.target
!!! systemctl isolate graphical.target





%%% 패키지 관리 yum/apt [a] etc (aa)
%%%e Package Management yum/apt [a] etc (aa)
%% echo -n "Able:" ; { which yum ; which dnf ; which apt ; which pkginfo ; which dpkg ; which rpm ; } 2>/dev/null | tr "\n" " " ; echo
# yum ####################################
yum install -y varPKG
!!! yum -y remove varPKG
yum list updates |less -RX 
yum update -y
# search && install
yum search varPKG 
yum list varPKG* 
yum list installed|less -RX
yum install -y "$( yum search varPKG|awk -F: '{print $1}' |grep varPKG |pipemenu)"
# search installed PACKAGE
yum whatprovides $(which varCMD)
repoquery -qf */varCMD
rpm -qf $(which varCMD__find)
rpm -qa | grep varPKG
rpm -ql varPKG
# apt ###################################
apt update -y && apt upgrade -y
apt install -y varPKG
!!! apt remove varPKG
# search command and install
apt search varPKG__php8.3 | cgrep varPKG | less -RX
apt install software-properties-common ;; add-apt-repository universe ;; apt update -y
apt-file search varCMD | grep 'bin/' | cgrep varCMD | less -RX || apt-file update
apt install "$(apt-file search varCMD|grep "/varCMD$"|awk -F: '{print $1}'|seen|pipemenu1cancel)"
# search installed PACKAGE / PACKAGE file list
dpkg -S $(which varCMD__find) # 명령어로 패키시 설치 검토
dpkg-query -S varPATH__@@etc@@ssh # path 로 설치 검토
dpkg -L varPKG__openssh-server | cgrepl etc bin | less -RX # 설치된 패키지의 리스트 출력
dpkg -l | grep varPKG__sql # 설치된 패키지 필터 검색
# lamp check
yum list installed| grep -E "php|maria|mysql|apache|httpd"|sort
apt list --installed| grep -E '^php[0-9]|^maria|^mysql|^apache|httpd'|sort
pkginfo -l|grep -E "apache|maria|mysql|php|httpd"|sort
rpm -qa|egrep -E "php|maria|mysql|apache|httpd"|sort
# install
apt install -y varPKG__lynx__screen__bat__at__net-tools__apt-file__all && apt-file update
yum install -y yum-utils epel-release && yum repolist && yum update
vi2 $( ls -1 /etc/apt/sources.list /etc/apt/sources.list.d/* /etc/yum.conf 2>/dev/null |pipemenu1 ) 
explorer $( ls -1d /etc/apt /etc/yum.repos.d yum 2>/dev/null |pipemenu1 )




%%% 사용자 관리 [u] / 환경변수 설정 (en)
%%%e User Management [u] / Environment Variable Settings (en)
useradd varUSER ; passwd varUSER
passwd varUSER
# id/pw auth check
idpw varID varPW varHOST__localhost varPORT__22
# group
groupadd varGroup
# del
!!! userdel varUSER
!!! groupdel varGroup
# usermod id-add
cat /etc/group|grep  "," ;; usermod -aG varGroup__sudo varSudoUSER
# owner / perm
chown varUSER:varGroup varFILE
chmod varPerm varFILE
# lock / unlock / unban 
passwd -l varLockUSER
passwd -u varUnlockUSER
pam_tally2 --user varID --reset
# 
vi2 "$( echo "/etc/passwd /etc/shadow /etc/group /etc/pam.d/password-auth" | pipemenu )"
# users
awk -F: '$3 > 499' /etc/passwd 
awk -F: '$3 > 999' /etc/passwd
# system  
awk -F: '$3 < 500' /etc/passwd ; echo ; awk -F: '$2 ~ /^[\*!]+$/' /etc/shadow ; echo; awk -F: '$3 < 500' /etc/group
awk -F: '$3 < 1000' /etc/passwd ; echo ; awk -F: '$2 ~ /^[\*!]+$/' /etc/shadow ; echo; awk -F: '$3 < 1000' /etc/group
# lock users
awk -F: 'BEGIN { while (getline < "/etc/passwd") if ($3 > 999) uid[$1]=1 } { if ($2 ~ /^!/ && uid[$1]) print $1 }' /etc/shadow
[ -f /etc/passwd.merged ] && awk -F: '($3 > 999) && ($2 ~ /^[\*!]/) {print $1}' /etc/passwd.merged
# passwd.merged 
sh -c 'cp /etc/passwd /etc/passwd.bak && cp /etc/shadow /etc/shadow.bak && pwunconv && cp /etc/passwd /etc/passwd.merged && pwconv && chmod 600 /etc/passwd.merged && chown root:root /etc/passwd.merged'
# install
yyay expect





%%% 시스템 로그 / 열린파일 관리 [l]
%%%e System Log / Open File Management [l]
%% echo "find /var/log/ -maxdepth 1 -type f -mmin -60"
%% echo $(find /var/log/ -maxdepth 1 -type f -mmin -60)
dmesg | cpipe | less -r 
journalctl -e # end 1000 line
journalctl -f # realtime
journalctl -fk # realtime kernel log
journalctl -r -u $( systemctl list-unit-files --type=service|grep enable|awk -F'.service' '{print $1}'|pipemenu ) # unit log reverse
journalctl $( echo -e "-b\n-b -1\n-rb -1\n-b -2\n-rb -2\n-b -3\n-rb -3" |pipemenulist)	# booting log
journalctl --since $( echo -e "-1hour\n-2hour\n-3hour\n-12hour\n-1day\n-7day" | pipemenulist ) 
journalctl -rp $( echo "info warning err" |pipemenu ) # log level
journalctl -rx # 문제가 발생한 부분과 부가 정보를 포함한 로그
tail -f /var/log/syslog |cpipe 
tail -f $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) |cpipe 
tac $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) |cpipe|less -RX
cat $( find /var/log/ -maxdepth 1 -type f -mmin -60 | pipemenu ) |cpipe|less -RX +G
tac $( ls -1 /var/log/cron /var/log/auth.log /var/log/daemon.log /var/log/kern.log /var/log/messages /var/log/secure /var/log/maillog /var/log/pveam.log /var/log/httpd/access_log /var/log/httpd/error_log  2>/dev/null | pipemenu ) |cpipe|less -RX
explorer /var/log/
# 
# List open files
lsof -i		 | cpipe
lsof -i tcp  | cpipe
lsof -i udp  | cpipe
# port
lsof -i:varPort__22 | cpipe
lsof -i:varPort__23__25__80__443 | cpipe
for pid in $(lsof -i:varPort | awk 'NR>1 {print $2}'); do ps -p $pid -o pid,user,%cpu,%mem,comm,args; done | cpipe
# path
lsof +D varPATH__@@etc@@ | cpipe 
lsof +D varPATH__@@root@@ | cpipe 
lsof +D varPATH__@@script@@__@@var__@@usr | cpipe | less -RX
# install
yyay lsof 




# trash
iftop -n -P -t -s varSec__10
stdbuf -oL iftop -n -P -t -L5 | cip24
!!! systemctl restart network
hostname; [ ! -f /tmp/go_route.txt ] && route > /tmp/go_route.txt && chmod 600 /tmp/go_route.txt ; cat /tmp/go_route.txt |awk 'NR>1 1' 





%%% 네트워크 관리 [n] / DDoS 점검 (dd)
%%%e Network Management [n] / DDoS Check (dd)
%% echo "$(hostname)($([ -x timeout ] && timeout 1s hostname -i || hostname -i ))" ; echo "local_ip_v4:$localip// public_ip_v4:$publicip"
# ip setting
vi2 $( ls -1 /etc/sysconfig/network /etc/sysconfig/network-scripts/ifcfg-* /etc/netplan/*.yaml /etc/network/interfaces /etc/network/interfaces.new /etc/network/interfaces.org  /etc/resolv.conf /etc/hosts /etc/hostname /etc/sysctl.conf /etc/udev/rules.d/70-persistent-net.rules  2>/dev/null |pipemenu1 )
# net restart ( safe restart? -> [rnet gosh.menu] )
!!! : debian9 ; which ifreload && sudo ifreload -a || sudo systemctl restart networking.service 
!!! : centos9 ; systemctl restart NetworkManager
!!! : ubuntu ; netplan $( echo try apply | pipemenu )
!!! : redhat ; /etc/init.d/network restart
# 
ping varHOST__168.126.63.1
traceroute varHOST__google.com || yyay traceroute
{ ip a ; echo ; ip a |gipa ; echo ; ip a | gip2 ; echo ; ip a | gip2 | awknr2; } |cip
ifconfig -a |cip
route |cip
{ ip -4 a ;echo; ip r ;echo; ip l ;echo; ip -4 n; } | cip
# iface top / iface speed check  
iftop
iftop -n -P -t || yyay iftop
ethtool $( ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | pipemenu ) | cgrep "Speed:"
# firewall / iptables
!!! ufw $(echo "enable disable"|pipemenu)
!!! iptables -F
iptables-save > ~/_iptables_save.$(datetag2) && tail ~/_iptables_save.$(datetag2)
iptables -L -v -n 
# dig
host -a varHOST varDNS__168.126.63.1 | cip 
# my ip
who am i|awk -F'[():]' '{print $3}'
# interface
ip -br a | awk '$3 != "" {print $1, $3}' | cip
ip l | awk -F ': ' '/^[0-9]+:/ {gsub(/:$/, "", $2); if ($2 != "lo") print $2}'
# public_ip 
curl -m1 -s icanhazip.com || wget -qO- icanhazip.com || curl -m1 -s checkip.amazonaws.com
# subnetcalc 
subnetcalc varIPCIDR__192.168.0.1@@26 || yyay subnetcalc




# trash
# nmtui network-manager 
nmcli || { yyay network-manager || yyay NetworkManager ; nmcli ; }
nmtui || { yyay network-manager net-tools NetworkManager-tui wget curl ; nmtui ; }
# ipv6 off
echo -e "net.ipv6.conf.all.disable_ipv6 = 1\nnet.ipv6.conf.default.disable_ipv6 = 1\nnet.ipv6.conf.lo.disable_ipv6 = 1\n" >> /etc/sysctl.conf && vi2 /etc/sysctl.conf && sysctl -p





%%% {submenu_hidden}DDoS 공격 관리 [dd]
%%%e {submenu_hidden}DDoS Attack Management [dd]
# IP 추출/차단시 제외할 아이피 목록을 설정 (/tmp/go_exceptips.private.txt or go.env)
# ex) 127.0.0.0|123.123.123.0|255.255.255.0
%% nobanip="127.0.0.0|61.111.255.0|61.111.254.0|210.118.193.0" ; ( [ -s /tmp/go_exceptips.private.txt ] && cat /tmp/go_exceptips.private.txt || echo "$nobanip" ) | tr '|' '\n' > /tmp/go_exceptips.txt ; chmod 600 /tmp/go_exceptips.txt
%% [ ! -f /tmp/go_route.txt ] && route > /tmp/go_route.txt && chmod 600 /tmp/go_route.txt ; cat /tmp/go_route.txt | awk '{while(match($0, /[0-9]+\.[0-9]+\.[0-9]+/)) {print substr($0, RSTART, RLENGTH) ".0"; $0 = substr($0, RSTART+RLENGTH)}}' | sort -u >> /tmp/go_exceptips.txt
%% who am i|awk -F'[()]' '{print $2}' | awk -F. '{print $1"."$2"."$3".0"}' >> /tmp/go_exceptips.txt
%% grep -v '^\s*$' /tmp/go_exceptips.txt | sed -e 's/\([0-9]*\.[0-9]*\.[0-9]*\.\)[0-9]*/\1/' > /tmp/go_exceptips_grep.txt ; chmod 600 /tmp/go_exceptips_grep.txt # 아이피세자리 
%% echo "Exceptips(/24): $(cat /tmp/go_exceptips.txt|grep -v '^\s*$'|sort -u|tr "\n" " ")"
# 아이피 랭킹 port 22~25 / 53 / 80 ---> ip & port count
na="$(netstat -anp)" ; { echo "$na" | gip | eip5 | sort -k5 ; echo ; ip_ranking="$(echo "$na" | awk '($4 ~ /:(443|80|22|23|24|25|53)$/) && ($5 ~ /:/) { split($4, svr_ip_port, ":"); split($5, ip_port, ":"); if (ip_port[2] > 999) { split(ip_port[1], ip_parts, "."); print ip_parts[1] "." ip_parts[2] "." ip_parts[3] ".0", svr_ip_port[2] } }' | sort | uniq -c| sort -nr | eip )" ; sorted_ip_ranking="$(echo -e "$ip_ranking" | sort -k2)" ; paste <(echo -e "$ip_ranking") <(echo -e "$sorted_ip_ranking") | column -t ; } | cip16
# 제한치(hit) 보다 상회하는 아이피 추출 ( >= $hit )
hit=varHIT ; netstat -anp | awk '($4 ~ /:(443|80|22|23|24|25|53)$/) && ($5 ~ /:/) { split($5, ip_port, ":"); if (ip_port[2] > 999) { split(ip_port[1], ip_parts, "."); print ip_parts[1] "." ip_parts[2] "." ip_parts[3] ".0" } }'|sort|eip|uniq -c|sort -nr | awk -v hit=$hit '{if($1>=hit) print $2}' > /tmp/go_ddosips.txt ; chmod 600 /tmp/go_ddosips.txt ; cat /tmp/go_ddosips.txt | tee /dev/tty | sed -e 's/.0$/./g' > /tmp/go_ddosips_grep.txt ; chmod 600 /tmp/go_ddosips_grep.txt
# 추출 아이피 차단 (추출한지 5분 이내)
!!! [ -s /tmp/go_ddosips.txt ] && [ "$(find /tmp/go_ddosips.txt -mmin -5)" ] && for i in $( cat /tmp/go_ddosips.txt ) ; do echo "iptables -A INPUT -s ${i%/*}/24 -j DROP" ; done > /tmp/go_ddosipsban.txt && for i in $( cat /tmp/go_ddosips.txt ) ; do echo "iptables -D INPUT -s ${i%/*}/24 -j DROP" ; done > /tmp/go_ddosipsbanrev.txt && chmod 600 /tmp/go_ddosipsban.txt /tmp/go_ddosipsbanrev.txt && echo && bash /tmp/go_ddosipsban.txt && echo ">>> 차단완료" &&  cat /tmp/go_ddosipsban.txt && echo ">>> 방화벽 차단내역 조회" && iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | grep -Ef /tmp/go_ddosips.txt
# 추출한 아이피 whois 조회 
for i in $( cat /tmp/go_ddosips.txt ) ; do echo "$i" ; whois -h whois.nic.or.kr $i ; readx ; echo ; done 
# 추출 아이피 차단 해제 
bash /tmp/go_ddosipsbanrev.txt && echo -e  ">>> 해제완료" && cat /tmp/go_ddosipsbanrev.txt
# 최근 차단 아이피 조회 // 추출 아이피 차단 조회
iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | gip | cip
iptables -L -v -n |awk 'BEGIN{RS=""} /Chain INPUT \(policy/' |tail -n20 | grep -Ef /tmp/go_ddosips.txt | gip | cip
# 예외 설정 아이피 확인 
cat /tmp/go_exceptips.txt ; echo ; cat /tmp/go_exceptips_grep.txt ; 
# 아이피 수동 차단 (다수 아이피 가능) 
ips="varIPS" ;"$( echo ipban ipban24 ipban16 | pipemenu )" $ips
# 아이피 수동 해제 (다수 아이피 가능)
iptables -L -v -n | tail -n20 | gip | cip16 ;; "$( echo ipallow ipallow24 ipallow16 | pipemenu )" "varIPS"
# 웹로그 server-status // dom sort
while :; do weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip24 ; echo ; printf "5초후 리프래시 or 종료시 -> [Enter] " && read -t5 -n1 x && break ; echo ; done
# 웹로그에서 추출 아이피 검색 및 차단
weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip16 |grep -Ef /tmp/go_ddosips_grep.txt
weblogresult="$(weblog | sed -e 's/www\.//g' -e '/NULL/d' | awk '{print $12,$11,$0}' | sort -k1,2 | cut -d' ' -f 3- | gip|eip|cip16 |grep -Ef /tmp/go_ddosips_grep.txt)" ; echo -e "$weblogresult" ; ipban24 "$(echo "$weblogresult" | awk '{print $11}'| noansi| seen |pipemenu1cancel)" 


%%% {submenu_com}device-mapper 관리 [dmsetup]
%%%e {submenu_com}device-mapper Management [dmsetup]
dmsetup info -c
dmsetup table $( dmsetup info -c | awk 'NR>1 {print $1}' | pipemenu ) 
dmsetup status $( dmsetup info -c | awk 'NR>1 {print $1}' | pipemenu ) 
fdisk -l /dev/mapper/$( dmsetup info -c | awk 'NR>1 {print $1}' | pipemenu )
# delete
!!! dmsetup remove $( dmsetup info -c | awk 'NR>1 {print $1}' | pipemenu )
# garbage clear
!!! dmsetup remove_all ; dmsetup status








%%% >시스템 초기설정과 기타 [i]
%%%e >System Initial Settings and Others [i]
{submenu_sys}
%% 




%%% 파일시스템 관리 [f] / (lvm) (swap)
%%%e File System Management [f] / (lvm) (swap)
%% echo -n "HDD: " ; lsblk -d -n -o name | oneline
mount | cpipe
# mount all from fstab
vi2 /etc/fstab
mount -a ; df -h | cper 
df -h | cper
fdisk -l | cpipe | less -RX ;; parted -l | cpipe | cgrepline Model | less -RX ;; { lsblk ; echo ; blkid ; } | less -RX
fdisk -l /dev/varHDD 
sgdisk -p /dev/varHDD
lsblk ;; fdisk /dev/varHDD
blkid | grep varFIND
blkid /dev/varHDD
# S.M.A.R.T. 
smartctl -a /dev/$( lsblk -d -n -o name | pipemenu ) | cgrep1 PASSED FAILED UNKNOWN
# uuid -> tee -a fstab 
cat /etc/fstab ;; blkid ;; blkid2fstab /dev/varPARTITION varDIR && mkdir -p varDIR && vi2 /etc/fstab
# mkfs
!!! fdisk -l ;; "$( ls -1 /usr/sbin/mkfs* |pipemenu1 )" /dev/varPARTITION
# mkfs.ext4 all/selected Linux partition
!!! fdisk -l ;; echo ; for i in $( fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}' ) ; do mkfs.ext4 $i ; done
!!! fdisk -l ;; echo ; mkfs.ext4 $(fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}' |pipemenu1)
# mkfs.xfs all/selected Linux partition
!!! fdisk -l ;; echo ; for i in $( fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}' ) ; do mkfs.xfs $i ; done
!!! fdisk -l ;; echo ; mkfs.xfs $(fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}' |pipemenu1)
# umount /tmp force
!!! fuser -km /tmp ; umount /tmp
# pid kill -> fsck
!!! df ;; fuser -km varMountDIR ; umount varMountDIR ; e2fsck -jp -y /dev/varPATITION ; mount /dev/varPARTITION varMountDIR ;
!!! umount /dev/varPARTITION ; e2fsck -jp -y /dev/varPARTITION
# hdd speed test
hdparm -t /dev/varHDD
# mount all Liuux part /dev/sdb1 -> /mnt/sdb1 
for i in $( fdisk -l /dev/varHDD|grep Linux$|awk '{print $1}'|awk -F/ '{print $3}' ); do mkdir /mnt/$i; mount /dev/$i /mnt/$i; done ; df
# growpart /dev/sda 3 
!!! growpart /dev/varDEV varPARTNO || ay cloud-guest-utils
# fdisk -> reboot -> resize2fs /dev/sda3
!!! resize2fs /dev/varPARTNO







%%% 로컬백업 [lb] / 원격백업 (rb)
%%%e Local Backup [lb] / Remote Backup (rb)
mkdir -p varBackupDIR__@@backup ; chmod 700 varBackupDIR__@@backup
# etc backup
rbackup /etc/passwd /etc/shadow /etc/group /etc/crontab /etc/named.conf /etc/fstab /etc/hosts 
# /etc /root 압축백업 
rbackup varBackupDIR__@@backup/etc_daily.tgz ; tar cvzf varBackupDIR__@@backup/etc_daily.tgz /etc/ 
rbackup varBackupDIR__@@backup/root_daily.tgz ; tar cvzf varBackupDIR__@@backup/root_daily.tgz --exclude=/root/.cache /root/
# 지정폴더 압축백업 
f="$(basename varDestFolder)" ; rbackup varBackupDIR__@@backup/$f.tgz ; tar -cvzf varBackupDIR__@@backup/$f.tgz varDestFolder ; ls -al varBackupDIR__@@backup/$f.tgz ; push
f="$(basename varDestFolder)" ; rbackup varBackupDIR__@@backup/$f.tgz ; tar -I zstd -cvf varBackupDIR__@@backup/$f.zst varDestFolder ; ls -al varBackupDIR__@@backup/$f.zst ; push
#
# rsync 증분백업 로컬 (삭제/변경된파일 원본유지) 백업본1,백업본7*24
# cron 에 삽입시에는 % 앞에 역슬래시 추가 
rsync -ar --backup --suffix=.bak --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@ ; push
rsync -ar --backup --suffix=.bak_$(date +%w%H) --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@ ; push
# rsync 동기화백업 로컬
rsync -arz --delete --exclude='varExclude__@@.err@@' varSource__@@home varBackupDIR__@@backup@@ ; push
# rsync 증분백업 로컬->원격(압축전송) // (삭제/변경된파일 원본유지)
rsync -arz --backup --suffix=.bak --exclude='varExclude__@@.err@@' varRhost:varSource__@@home varBackupDIR__@@backup@@ ; push
rsync -arz --backup --suffix=.bak_$(date +%w%H) --exclude='varExclude__@@.err@@' varRhost:varSource__@@home varBackupDIR__@@backup@@ ; push
# rsync 동기화백업 로컬->원격(압축전송)
rsync -arz --delete --exclude='varExclude__@@.err@@' varSource__@@home varRhost:varBackupDIR__@@backup@@ ; push
#
# lftp 증분백업 로컬->원격 (s?ftps?,https?,fish,torrent)
lftp -u varUsername,varPassword ftp://varRhost -e "set ftp:list-options -a; lcd varSource__@@home; cd varBackupDIR__@@backup@@home ; mirror --exclude-glob varExclude__@@.err@@ ; bye"
# lftp 동기화백업 로컬->원격 
lftp -u varUsername,varPassword ftp://varRhost -e "set ftp:list-options -a; lcd varSource__@@home; cd varBackupDIR__@@backup@@home ; mirror --delete --exclude-glob varExclude__@@.err@@ ; bye"
#
# dbs all dump
mkdir -p varBackupDIR__@@backup@@mysqldump/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1'); do echo "$i DB dumping..." ; mysqldump -Q $i | gzip > varBackupDIR__@@backup/${i}.$(datetag1).sql.gz; done ;  chmod 600 varBackupDIR__@@backup@@mysqldump/*.sql.gz
# dbs all dump // week rotate
mkdir -p varBackupDIR__@@backup@@mysqldump/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1'); do echo "$i DB dumping..." ; mysqldump -Q $i | gzip > varBackupDIR__@@backup/${i}.$(datetagw).sql.gz; done ;  chmod 600 varBackupDIR__@@backup@@mysqldump/*.sql.gz
#
yyay lftp rsync



%%% {submenu_hidden}원격 백업 관리 [rb]
%%%e {submenu_hidden}Remote Backup Management [rb]
# 원격지 홈폴더 select 백업 (ncp) // pv 진행바 // zstd 네트워크 효율 좋음 
list="$( ssh varRhost "find / -maxdepth 2 -type d \( -regex \"/home[^/]*\" -o -regex \"/home.*/.*\" -o -regex \"/backup/mysqldump/.*\"  \)" )" ; d="$(echo "$list"|pipemenu1cancel)" ; [ "$d" ] && [[ ! "$d" == *Cancel* ]] && { echo -n "Execute: ncp varRhost $d varLocalBackupPath varPORT__22 [Enter] " && read x && mkdir -p varLocalBackupPath && time ncp varRhost $d varLocalBackupPath varPORT__22 && ls -al varLocalBackupPath ; }
# 
# 원격지 선택 폴더 하부의 숨김폴더 제외 하고 각각 백업 ex) /home/{all but .hide} 
# 제외할 폴더 다수개 입력 가능 var1 var2 -> */var1* */var2*
# 로컬에 복사할 폴더가 있는 경우 skip (이어받기 가능)
pwd;; h="varRHOST"; d="varRBackupFolderPath"; l="varLocalBackupPath"; except="varExcept__except_path_here"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : " ; echo $list ; echo ; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list ; do [ ! -d $l$i ] && { CYN ; echo "[$count/$total_count] $i copying... " && ncp $h $(realpathf $i) $l$d varPORT__22 ; } || { RED1 ; echo "[$count/$total_count] $i skipped... " ; } ; count=$((count+1)); echo ; done ; } ; cd $l
#
# 로컬 압축파일로 저장 // 기존재 파일 skip 지원 // ex) /home 계정별로 전체 압축하고 싶을때 
pwd;; h="varRHOST"; d="varRBackupFolderPath"; l="varLocalBackupPath"; except="varExcept__except_path_here"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : "; echo $list; echo; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list; do [ ! -f "${l}${d}/$h.$(basename "$i").tar.zst" ] && [ ! -f "${l}${d}/$h.$(basename "$i").tgz" ] && { CYN ; echo "[$count/$total_count] $i copying... " && ncpzip $h $(realpathf $i) $l$d varPORT__22 ; } || { RED1 ; echo "[$count/$total_count] $i skipped... " ; } ; count=$((count+1)); echo; done ; } ; cd $l 
#
# 업데이트된 파일만 추가 백업 // 기존 백업 tar.zst or tgz 파일을 참조함 
pwd;; h="varRHOST"; d="varRBackupFolderPath"; l="varLocalBackupPath"; except="varExcept__except_path_here"; except="$(echo "$except" | xargs -n1 printf "! -path '*/%s*' ")" ; mkdir -p $l$d; [ "$d" ] && list="$(ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $h "find $d -maxdepth 1 -mindepth 1 -type d ! -path '*/\.*' ! -path '*/lost+found*' $except |sort ")"; [ "$list" ] && list="$( realpathf $list )" && { echo -n "list : "; echo $list; echo; total_count="$(echo "$list" | wc -l)"; count=1; for i in $list; do [ -f "${l}${d}/$h.$(basename "$i").tar.zst" ] || [ -f "${l}${d}/$h.$(basename "$i").tgz" ] && { CYN ; echo "[$count/$total_count] $i update checking... " && ncpzipupdate $h $(realpathf $i) $l$d varPORT__22 ;RST; } || { RED ; echo "[$count/$total_count] $i skipped... ";RST ; } ; count=$((count+1)); echo; done ; } ; cd $l ; find ./ -type f -size 0 -exec rm {} \;

#
ncp varRemoteHOST varRemotePATH varLocalPATH varPORT__22 ; explorer varLocalPATH
ncpr varLocalPATH varRemoteHOST varRemotePATH varPORT__22 ; 
ncpzip varRemoteHOST varRemotePATH varLocalPATH__@@backup varPORT__22 ;
ncpzipupdate varRemoteHOST varRemotePATH varLocalPATH__@@backup varPORT__22 ;
# 하드 I/O (df) && process monitor 
dfmonitor
#




%%% 클라우드 관리 [cl] / rclone (cc)
%%%e Cloud Management [cl] / rclone (cc)
# ncp 서버간 압축(tar/zstd) 전송(ssh) 함수 
# ncp(원격지파일폴더->로컬로복사)// ncpr(로컬파일폴더->원격지서버로복사)// ncpzip(tgz저장)
ncp varRemoteHOST varRemotePATH varLocalPATH varPORT__22 ; push ; explorer varLocalPATH
ncpr varLocalPATH varRemoteHOST varRemotePATH varPORT__22 ; push
ncpzip varRemoteHOST varRemotePATH varLocalPATH__@@backup varPORT__22 ; push
ncpzipupdate varRemoteHOST varRemotePATH varLocalPATH__@@backup varPORT__22 ; push
#
# 원격지(ssh) 폴더를 로컬 폴더로 마운트 (sshfs:sftp)
[ ! -d /mnt/varLocalDIR__sshfs.mount ] && mkdir -p /mnt/varLocalDIR__sshfs.mount; nohup sshfs root@varRHOST:varRDIR /mnt/varLocalDIR__sshfs.mount -pvarSshPort__22 &>/dev/null & sleep 2 ; df |grep /mnt 
# 원격지(ftp) 폴더를 로컬 폴더로 마운트 (curlftpfs:ftp)
# curlftpfs ftp://[FTP_계정]:[FTP_비밀번호]@[FTP_서버_주소]:[FTP_포트]/[원격_FTP_경로] [로컬_마운트_디렉토리]
[ ! -d /mnt/varLocalDIR__ftpfs.mount ] && mkdir -p /mnt/varLocalDIR; nohup curlftpfs varFTPid:varFTPpw@varRHOST:varPORT__21/varRDIR /mnt/varLocalDIR &>/dev/null & sleep 2 ; df |grep /mnt 
#
# nfs mount 
mkdir -p /mnt/varLocalDIR__nfs.mount ; mount -t nfs -o nolock varRHOST:varRDIR/ /mnt/varLocalDIR__nfs.mount
# smb mount
mkdir -p /mnt/varLocalDIR__smb.mount ; mount -t cifs -o "username=varSMBusername,password=varSMBpassword" "//varSMBhost/varRDIR/" /mnt/varLocalDIR__smb.mount
#
# nfs fstab add
echo "# varRHOST:varRDIR/ /mnt/varLocalDIR__nfs.mount nfs nolock,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab
# smb fstab add
echo "# //varSMBhost/varRDIR/ /mnt/varLocalDIR__smbmount cifs credentials=/root/.smbcredentials,noperm,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab
echo -e "username=varSMBusername\npassword=varSMBpassword" >> /root/.smbcredentials && vi2 /root/.smbcredentials
#
# ssh 블록복사 (-> 함수로 만든것 ncp)
h="varRhost" ; f="varRpath" ; l="varLocalPath" ; d="$(dirname $f)" ; dest=${f/$d\//}; echo -n "원격지 $h 의 폴더 $d 안의 ./$dest 가 $l 안으로 복사 [Enter] "|sed -e 's|//|/|g'  && read x && { [ ! -d $l ] && mkdir -p $l ; ssh $h "cd $d ; tar czfp - ./$dest" | tar xzf - -C $l && explorer $l ; }
# 
# 언마운트 /mnt/MountPoint
df |grep "/mnt" ;; umount $(df |grep /mnt|awk99|pipemenu1) ; df|grep mnt
# install
yyay sshfs fuse3 zstd pv smbclient
yy nfs-utils || ay nfs-common
yyay curlftpfs



%%% {submenu_sys}한글화 / 타임존 / 모듈설정 [han]
%%%e {submenu_sys}Koreanization / Timezone / Module Settings [han]
# LANG 
env ; echo $LANG ; locale
locale -a
# apt
ay locales  
vi2 /etc/locale.gen
locale-gen varLocale__ko_KR.UTF-8
update-locale
# 기본 locale 변경후 재접속시 반영 
localedef -i ko_KR -f UTF-8 ko_KR.UTF-8
export LC_ALL=ko_KR.UTF-8 ; env 
localectl set-locale LANG=ko_KR.UTF-8
# /etc/default/locale edit
vi2 /etc/default/locale 
sed -i '/LANG=.*$/c\LANG=ko_KR.UTF-8' /etc/default/locale ; vi2 /etc/default/locale
echo "LC_MESSAGES=ko_KR.UTF-8" >> /etc/default/locale ; vi2 /etc/default/locale
echo "_JAVA_OPTIONS=\"-Duser.timezone=Asia/Seoul\"" >> /etc/environment ; vi2 /etc/environment
vi2 "$( ls -1 /etc/default/locale /etc/sysconfig/i18n /etc/profile.d/tmout.sh /etc/environment 2>/dev/null | pipemenu )"
# timezone
timedatectl 
timedatectl set-timezone Asia/Seoul ; date
rdate -s $( echo zero.bora.net time.nist.gov | pipemenu ) && hwclock --systohc
ntpdate time.nist.gov || { yyay ntpdate && ntpdate time.nist.gov ; } ; hwclock --systohc
tzselect
date
echo $(date "+%Y%m%d.%H%M%S")
echo $(date "+%Y%m%d.%H%M%S")$(($RANDOM%9000+1000))
# hostname set
hostnamectl ;; hostnamectl set-hostname varNEWHostName
#
vi2 "$( ls -1 /etc/hosts /etc/hostname /etc/sysconfig/hwconf /etc/modules.conf /etc/modprobe.d/modprobe.conf /etc/fstab /etc/rc.d/rc.local /etc/crontab /etc/motd /etc/resolv.conf /root/.vimrc /root/.bashrc 2>/dev/null |pipemenucancel )"
#
lspci
lspci -v | cgrep VGA Ethernet SCSI SATA CPU | less -RX
lshw | cpipe | less -RX
dmidecode | cgrepn "Type:" 1 | cgrepn GB MB -2 | less -RX
lsmod
modprobe varA
insmod varA
kudzu
explorer /etc/




%%% {submenu_sys}환경변수 설정 [en]
%%%e {submenu_sys}Environment Variable Settings [en]
%% echo "TERM: $TERM"
env
# 운용서버에서 환경파일 가져오기
scp varHOST:/root/.bashrc /root/ || scp -v -oKexAlgorithms=diffie-hellman-group-exchange-sha1 -oHostKeyAlgorithms=ssh-rsa,ssh-dss varHOST:/root/.bashrc /root/
vi2 $( ls -1 /root/.bashrc /etc/profile.d/tmout.sh /etc/profile /etc/systemd/system.conf | pipemenu ) 
# 서버 모니터 tty1 로 커널 메세지 출력 -> 레벨 조절 
cat /proc/sys/kernel/printk
# shell timemout set
grep "TMOUT" /etc/profile /etc/profile.d/*
echo "[ -z \"\$TMOUT\" ] && export TMOUT=3600" >> /etc/profile.d/tmout.sh
echo "[ -z \"\$TMOUT\" ] && export TMOUT=0" >> /etc/profile.d/tmout.sh
# 경고 이상만 출력(임시/영구)
echo "3 4 1 7" > /proc/sys/kernel/printk
echo "kernel.printk = \"3 4 1 7\"" >> /etc/sysctl.conf
# systemed 종료시 timeout 단축  
sed -i "s/\#DefaultTimeoutStopSec=90s/DefaultTimeoutStopSec=5s/" /etc/systemd/system.conf
# PS1 터미널 창제목 고정 
echo "PS1='\[\033]0;\u@\h:\w\a\] '\$PS1" >> ~/.bashrc
# 사용자가 직접 로그인한 경우에만 소스 {불러오기,실행,!break} (scp//sftp제외)
sed -i '1i [[ $- != *i* ]] && return' ~/.bashrc
echo "[[ \$- == *i* ]] && source varSourcePATH" >> ~/.bashrc
echo "[[ \$- == *i* ]] && varCommand" >> ~/.bashrc
#
# PS1 프롬프트 설정
export PS1="\[\033[1;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]$ "
export PS1="\n\033[1;33m\t \d \033[0m\033[0;32m[\u@\h \w]\033[0m\n\\$ "
# 프롬프트 적용
echo 'PS1="\[\033[1;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]$ "' >> /root/.bashrc ; vi2 /root/.bashrc
echo 'PS1="\n\033[1;33m\t \d \033[0m\033[0;32m[\u@\h \w]\033[0m\n\\$ "' >> /root/.bashrc ; vi2 /root/.bashrc
# 멀티라인 프롬프트 설정
export PS2=">"
# PS3 셀렉트 프롬프트 설정
export PS3="Select No. : "
# PS4 디버그 모드 프롬프트 설정
export PS4="+ Line \$LINENO: " ; set -x 
#
# ssh sha1 err in alma
update-crypto-policies --set DEFAULT:SHA1



%%% {submenu_sys}리눅스 최초 설치 셋업 [init]
%%%e {submenu_sys}Initial Linux Setup [init]
# 리눅스 최초 설치시 하는 작업들
# su - 과정중 쉘이 일반계정에서 root 로 바뀌면서 go.sh 를 다시 실행해야함
sudo su
sudo passwd root
su -
# ssh server
sudo apt update & sudo apt upgrade
ntpdate time.windows.com || yyay ntpdate && ntpdate time.windows.com
sudo apt install openssh-server
sudo systemctl status ssh
sudo systemctl enable --now ssh
# ssh remote -> root id/pw login
sed -i 's/^#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config
sed -i 's/^#PasswordAuthentication.*/PasswordAuthentication yes/' /etc/ssh/sshd_config
systemctl restart sshd
# port / root allow/ban set
vi2 /etc/ssh/sshd_config Root
sudo systemctl restart ssh
# ufw
sudo ufw status
sudo ufw enable
sudo ufw allow ssh
# go.sh start
wget -O go.sh http://byus.net/go.sh && bash go.sh
ln -s ${PWD}/go.sh varGO__@@bin@@g__@@bin@@go__@@bin@@gosh ;; ls -al varGO
# 
hostnamectl ;; sudo hostnamectl set-hostname varHostname
timedatectl ;; sudo timedatectl set-timezone $( timedatectl list-timezones | pipemenu )
# wheel user (sudo)
adduser varUSER
passwd varUSER
usermod -aG wheel varUSER
usermod -aG sudo varUSER
id varUSER


%%% {submenu_sys}루트 로그인 설정 [root]
%%%e {submenu_sys}root login set [root]
# Ubuntu desktop // gui root login
vi2 /etc/pam.d/gdm-password
# auth required pam_succeed_if.so user != root quiet_success
hash_add /etc/pam.d/gdm-password "pam_succeed_if.so user != root quiet_success" 
hash_remove /etc/pam.d/gdm-password "pam_succeed_if.so user != root quiet_success" 
vi2 /etc/gdm3/custom.conf
echo "AllowRoot=true" | insert /etc/gdm3/custom.conf "[security]" 
systemctl restart gdm3


%%% {submenu_sys}서버 셋업 보안/퍼미션 관리 [se]
%%%e {submenu_sys}Server Setup Security/Permission Management [se]
# file perm
chmod 700 /usr/bin/chage /usr/bin/wall /usr/bin/write /bin/dd /bin/mount /bin/umount /bin/rpm /usr/bin/finger
chmod 700 /usr/bin/top /usr/bin/uptime /usr/bin/whereis /usr/bin/which /usr/bin/lwp-download /usr/bin/nslookup /usr/bin/lsof
chmod 700 /usr/bin/cc /usr/bin/gcc /usr/bin/make /usr/bin/pstree /usr/bin/rlogin /usr/bin/rlog /bin/mount /bin/umount
# wheel perm
chmod 750 /bin/ps /bin/netstat /bin/dmesg /bin/df /usr/bin/who /usr/bin/finger /usr/bin/last /usr/bin/lastlog /usr/bin/top /usr/bin/w /bin/uname
chgrp wheel /bin/ps /bin/netstat /bin/dmesg /bin/df /usr/bin/who /usr/bin/finger /usr/bin/last /usr/bin/lastlog /usr/bin/top /usr/bin/w /bin/uname
#
cat /etc/group|grep  "," ;; usermod -aG varGroup__wheel varSudoUSER
# folder perm
chmod 711 / /dev /etc /home* /initrd /lib /var/log /var/log/httpd /var /usr
chmod 700 /boot /mnt /root
# service folder create
mkdir -p /backup /ban /script /scriptuser /homein/expire /home1/expire /home/expire /clone
chmod 700 /backup /ban /script /home1/expire /homein/expire /home/expire /clone
#
# 주요 실행 명령 변조대비 백업
[ ! -d /root/bin/ ] && mkdir -p /root/bin/ && cp -a /bin/netstat /usr/bin/top /bin/login /usr/bin/dir /usr/bin/find /usr/bin/pstree /usr/bin/md5sum /bin/ls /bin/ps /sbin/ifconfig /root/bin/ && chattr +i /root/bin/
[ ! -d /bin.backup ] && cp -a /bin/ /bin.backup && chmod 700 /bin.backup && chattr +i /bin.backup
[ ! -d /sbin.backup ] && cp -a /sbin/ /sbin.backup && chmod 700 /sbin.backup && chattr +i /usr/bin.backup
[ ! -d /usr/bin.backup ] && cp -a /usr/bin/ /usr/bin.backup && chmod 700 /usr/bin.backup && chattr +i /usr/bin.backup



%%% {submenu_sys}서버 웹관리 솔루션 설치 (webmin/perl)
%%%e {submenu_sys}Server Web Management Solution Installation (webmin/perl)
%% echo "https://$publicip:10000" ; [ "$publicip" == "$(hostname -i)" ] && echo "https://$(hostname):10000"
# webmin_ubuutu repo
curl -s http://www.webmin.com/jcameron-key.asc | apt-key add -
add-apt-repository "deb [arch=amd64] http://download.webmin.com/download/repository sarge contrib" || ay software-properties-common && add-apt-repository "deb [arch=amd64] http://download.webmin.com/download/repository sarge contrib"
# webmin_centos repo
curl -O http://www.webmin.com/jcameron-key.asc
rpm --import jcameron-key.asc
vi2 /etc/yum.repos.d/webmin.repo
printf "[Webmin] \nname=Webmin Distribution Neutral\nbaseurl=http://download.webmin.com/download/yum\nenabled=1\ngpgcheck=1\ngpgkey=http://www.webmin.com/jcameron-key.asc" >> /etc/yum.repos.d/webmin.repo
# webmin install
yyay webmin
# firewall port open
ufw allow 10000 || firewall-cmd --add-port=10000/tcp --permanent && firewall-cmd --reload
# website (guide: http://www.webmin.com)
systemctl status webmin
systemctl start webmin && systemctl enable webmin
systemctl stop webmin && systemctl disable webmin






%%% {submenu_sys}서버 웹관리 솔루션 설치 (cockpit/perl)
%%%e {submenu_sys}Server Web Management Solution Installation (cockpit/perl)
%% echo https://$publicip:9090 ; [ "$publicip" == "$(hostname -i)" ] && echo https://$(hostname):9090
yy epel-release 
yyay cockpit
# firewall port open
ufw allow 9090
firewall-cmd --add-service=cockpit &&  firewall-cmd --add-service=cockpit --permanent
# centos repo add
curl -O /etc/yum.repos.d/cockpit.repo https://copr.fedorainfracloud.org/coprs/g/cockpit/cockpit-preview/repo/epel-7/group_cockpit-cockpit-preview-epel-7.repo
systemctl start cockpit ; systemctl enable cockpit
# website (guide: https://cockpit-project.org)
dpkg-query -l cockpit-system || yyay cockpit-system
# AllowUnencrypted = true
vi2 /etc/cockpit/disallowed-users
systemctl restart cockpit 
#
systemctl status cockpit
systemctl start cockpit && systemctl enable cockpit
systemctl stop cockpit && systemctl disable cockpit
lsof -i:9090



%%% {submenu_sys}응급 복구 / 시동 [r]
%%%e {submenu_sys}Emergency Recovery / Booting [r]
fdisk -l
fdisk -l /dev/varD
fdisk -l ;; fdisk /dev/varD
# mount
vi2 /etc/fstab
mount
mount -a
mount /tmp -o remount,$( echo exec noexec | pipemenu ) 
chmod 1777 /tmp/
# chroot 
mount /dev/varROOTPARTITION /mnt/sysimage
mount /dev/varBOOTPARTITION /mnt/sysimage/boot
!!! chroot /mnt/sysimage
# lilo
vi2 /etc/lilo.conf
!!! lilo
# grub
ls -al /etc/default/ ;readx; explorer /etc/default/
ls -al /boot/ ;readx; explorer /boot/
vi2 $( ls -1 /etc/default/grub /etc/grub.conf /boot/grub/grub.cfg /etc/default/grub.d/proxmox-ve.cfg 2>/dev/null |pipemenu ) 
!!! grub
!!! update-grub
# grub2
grub2-mkconfig -o /boot/grub2/grub.cfg
# kernel 
grubby --default-kernel
# kernel add
grubby --add-kernel=/boot/vmlinuz-varVER --initrd=/boot/initramfs-varVER.img --title "varTITLE"
# kernel chg
grubby --set-default=/boot/vmlinuz-varVER
# kernel del
grubby --remove-kernel=/boot/vmlinuz-varVER
# os probe ( instlled win or etc ) 
os-prober || { yyay os-prober && os-prober ; }
efibootmgr || { yyay efibootmgr && efibootmgr ; }
update-grub
#
vi2 /root/.bashrc
explorer /boot/



%%% {submenu_sys}원격 네트워크 재시작 debian [rnet]
%%%e {submenu_sys}Remote Net restart debian [rnet]
# 원격지에서 네트워크 재시작 할경우, 네트웍 단절 방지
# debian
# /etc/network/interfaces.1.bak 백업본으로 복구 재시작
# /etc/network/interfaces.org 로 최종 재시작 
cp -a /etc/network/interfaces /etc/network/interfaces.org
# vi2 는 file.1.bak 백업후, 수정모드진입
vi2 /etc/network/interfaces
vi /etc/network/interfaces
vi /etc/network/interfaces.1.bak
vi /etc/network/interfaces.org
ping 8.8.8.8 -c 3
# interface 가 여러개 일개 각각 핑 체크 
ping -I vmbr0 varIP_8.8.8.8 -c 3
ping -I vmbr1 varIP_8.8.8.8 -c 3
ping -I vmbr2 varIP_8.8.8.8 -c 3
#
route 
ip -br a | awk '$3 != "" {print $1, $3}' | cip
# 재시작 || 실패시 백업파일로 복구후 재시작 
systemctl restart networking ; ping 8.8.8.8 -c 3 || (cp /etc/network/interfaces.1.bak /etc/network/interfaces && systemctl restart networking) ; ping 8.8.8.8 -c 3 || (cp /etc/network/interfaces.org /etc/network/interfaces && systemctl restart networking)
# proxmox or debina9 ifupdown2 
ifreload -a ; ping 8.8.8.8 -c 3 || (cp /etc/network/interfaces.1.bak /etc/network/interfaces && ifreload -a) ; ping 8.8.8.8 -c 3 || (cp /etc/network/interfaces.org /etc/network/interfaces && ifreload -a )
#
# cron add
echo "#*/5 * * * * root ping -c 1 -W 1 8.8.8.8 > /dev/null 2>&1 || { sleep 30; ping -c 1 -W 1 168.126.63.1 > /dev/null 2>&1 || { cp /etc/network/interfaces.org /etc/network/interfaces && systemctl restart networking.service ; }; }" | tee -a /etc/crontab
vi2 /etc/crontab
vi2 /etc/network/interfaces.org



%%% {submenu_sys}원격 네트워크 재시작 centos [rnetc]
%%%e {submenu_sys}Remote Net restart [rnetc]
# 원격지에서 네트워크 재시작 할경우, 네트웍 단절 방지
# centos
# /etc/sysconfig/network-scripts/ifcfg-eth0.1.bak 백업본으로 복구 재시작
# /etc/sysconfig/network-scripts/ifcfg-eth0.org 로 최종 재시작 
cp -a /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0.org
# vi2 는 file.1.bak 백업후, 수정모드진입
vi2 /etc/sysconfig/network-scripts/ifcfg-eth0
vi /etc/sysconfig/network-scripts/ifcfg-eth0
vi /etc/sysconfig/network-scripts/ifcfg-eth0.1.bak
vi /etc/sysconfig/network-scripts/ifcfg-eth0.org
ping 8.8.8.8 -c 3
# interface 가 여러개 일개 각각 핑 체크 
ping -I eth0 varIP_8.8.8.8 -c 3
ping -I eth1 varIP_8.8.8.8 -c 3
ping -I eth2 varIP_8.8.8.8 -c 3
#
route 
ip -br a | awk '$3 != "" {print $1, $3}' | cip
# 재시작 || 실패시 백업파일로 복구후 재시작 
!!! systemctl restart network ; ping 8.8.8.8 -c 3 || (cp /etc/sysconfig/network-scripts/ifcfg-eth0.1.bak /etc/sysconfig/network-scripts/ifcfg-eth0 && systemctl restart network) ; ping 8.8.8.8 -c 3 || (cp /etc/sysconfig/network-scripts/ifcfg-eth0.org /etc/sysconfig/network-scripts/ifcfg-eth0 && systemctl restart network)
#
# cron add
echo "#*/5 * * * * root ping -c 1 -W 1 8.8.8.8 > /dev/null 2>&1 || { sleep 30; ping -c 1 -W 1 168.126.63.1 > /dev/null 2>&1 || { cp /etc/sysconfig/network-scripts/ifcfg-eth0.org /etc/sysconfig/network-scripts/ifcfg-eth0 && systemctl restart network.service ; }; }" | tee -a /etc/crontab
vi2 /etc/crontab
vi2 /etc/sysconfig/network-scripts/ifcfg-eth0.org



%%% {submenu_sys}원격 네트워크 재시작 ubuntu [rnetu]
%%%e {submenu_sys}Remote Net restart [rnetu]
# 원격지에서 네트워크 재시작 할경우, 네트웍 단절 방지
# ubuntu
# /etc/netplan/01-netcfg.yaml.1.bak 백업본으로 복구 재시작
# /etc/netplan/01-netcfg.yaml.org 로 최종 재시작 
cp -a /etc/netplan/01-netcfg.yaml /etc/netplan/01-netcfg.yaml.org
# vi2 는 file.1.bak 백업후, 수정모드진입
vi2 /etc/netplan/01-netcfg.yaml
vi /etc/netplan/01-netcfg.yaml
vi /etc/netplan/01-netcfg.yaml.1.bak
vi /etc/netplan/01-netcfg.yaml.org
ping 8.8.8.8 -c 3
# interface 가 여러개 일개 각각 핑 체크 
ping -I vmbr0 varIP_8.8.8.8 -c 3
ping -I vmbr1 varIP_8.8.8.8 -c 3
ping -I vmbr2 varIP_8.8.8.8 -c 3
#
route 
ip -br a | awk '$3 != "" {print $1, $3}' | cip
# 재시작 || 실패시 백업파일로 복구후 재시작 
netplan apply ; ping 8.8.8.8 -c 3 || (cp /etc/netplan/01-netcfg.yaml.1.bak /etc/netplan/01-netcfg.yaml && netplan apply) ; ping 8.8.8.8 -c 3 || (cp /etc/netplan/01-netcfg.yaml.org /etc/netplan/01-netcfg.yaml && netplan apply)
#
# cron add
echo "#*/5 * * * * root ping -c 1 -W 1 8.8.8.8 > /dev/null 2>&1 || { sleep 30; ping -c 1 -W 1 168.126.63.1 > /dev/null 2>&1 || { cp /etc/netplan/01-netcfg.yaml.org /etc/netplan/01-netcfg.yaml && netplan apply ; }; }" | tee -a /etc/crontab
vi2 /etc/crontab
vi2 /etc/netplan/01-netcfg.yaml.org









%%% {submenu_com}file explorer [ex]
%%%e {submenu_com}file explorer [ex]
# file explorer install 
ranger || yyay ranger 
lfm || yyay lfm
mc || yyay mc
vifm || yyay vifm
nnn || yyay nnn
fzf || yyay fzf
yazi || snap install yazi --classic
# ranger (python stg install)
pip install ranger-fm
# centos6 git ranger make install (python2 base)
cd ~ ; git clone https://github.com/ranger/ranger.git ; cd ranger ; git checkout v1.8.1 ; make install
########################
# ranger configure
# ######################
mkdir -p $HOME/.config/ranger/ ; [ ! -f $HOME/.config/ranger/rc.conf ] && cp /etc/ranger/config/rc.conf $HOME/.config/ranger/
vi2 $HOME/.config/ranger/rc.conf
# hidden file view (ctrl+h or zh)
sed -i 's/#\?set show_hidden false/set show_hidden true/g' ~/.config/ranger/rc.conf
echo "set show_hidden true" >> $HOME/.config/ranger/rc.conf
# 
# editor vi set .bashrc
export EDITOR=vim ; echo "export EDITOR=vim" >> $HOME/.bashrc
# ranger 종료시점 작업 dir 저장후, 바로 이동
ranger --choosedir=$HOME/.rangerdir; cd $(cat ~/.rangerdir) ; rm -f ~/.rangerdir
ranger --choosedir=$(tmp=$(mktemp); echo $tmp); cd "$(cat $tmp)"; rm -f $tmp
## 
yyay varPKG__git__snapd




%%% {submenu_sys}ethx ip setting centos6 [ipset]
%%%e {submenu_sys}ethx ip setting centos6 [ipset]
# ifcfg-ethx 파일이 없거나, IP (static/dhcp) 갱신이 필요할때 
# centos 기준 작성 
vi2 $( ls -1 /etc/sysconfig/network-scripts/ifcfg-* /etc/sysconfig/network 2>/dev/null |pipemenu ) 
declare -f ifcfgset
ifcfgset
#
explorer /etc/sysconfig/network-scripts/
#
!!! systemctl restart networking
!!! systemctl restart network
!!! service network restart
!!! /etc/init.d/network restart
ip a ; echo ; route
ping 168.126.63.1
# recover
diff /etc/sysconfig/network-scripts/ifcfg-eth0.bak /etc/sysconfig/network-scripts/ifcfg-eth0
cp -a /etc/sysconfig/network-scripts/ifcfg-eth0.bak /etc/sysconfig/network-scripts/ifcfg-eth0


%%% {submenu_sys}ethx bonding setting [bond]
%%%e {submenu_sys}ethx bonding setting [bond]
# ubuntu/debian 기준
yyay ifenslave ethtool
modprobe bonding
echo 'bonding' >> /etc/modules 
vi2 /etc/modules
vi2 /etc/network/interfaces
cp -a /etc/network/interfaces /etc/network/interfaces.$(datetag2).bak ; ls -al /etc/network
export ifaces=$(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | grep -E "^e") ; echo "$ifaces"
export ifaces=$(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | grep -E "^e|^w") ; echo "$ifaces"
{ ip a ;echo;echo localip:$localip pubip:$publicip gateway:$gateway; }|cip ;; export bondip="varIPADDR" ; export bondgateway="varGATEWAY"
# 아래 갈무리후 수정
# 서버 단독 ip 사용시
echo -e "auto lo\niface lo inet loopback\n"; echo "$ifaces" | while IFS= read -r line; do echo -e "auto $line\niface $line inet manual\n  bond-master bond0\n" ; done ; echo -e "auto bond0\niface bond0 inet static\n  address $bondip/24\n  netmask 255.255.255.0\n  gateway $bondgateway\n  bond-slaves $(echo $ifaces)\n  bond-mode balance-rr\n  bond-miimon 100\n  bond-downdelay 200\n  bond-updelay 200"
# 브리지 사용시 
echo -e "auto lo\niface lo inet loopback\n"; echo "$ifaces" | while IFS= read -r line; do echo -e "iface $line inet manual\n  bond-master bond0\n" ; done ; echo -e "auto bond0\niface bond0 inet manual\n  bond-slaves $(echo $ifaces)\n  bond-mode balance-rr\n\nauto vmbr0\niface vmbr0 inet static\n\taddress $bondip/24\n\tnetmask 255.255.255.0\n\tgateway $bondgateway\n\tbridge_ports bond0"
!!! systemctl restart networking
ip a | cip
lsmod | grep bond
# bond0 체크하여 eth0 eth1 합산 대역폭이 나오는지 확인 
for i in $(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'| grep -E "^e|^w" ) ; do ethtool $i |grep -E 'detect|nego|Setting|Duplex|Speed' ; done| cgrep Speed
# ethX speed chg // 랜이 죽을수 있으니 백업라인 확보/콘솔에서 작업 
!!! eth=$(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu) ;; ethtool -s $eth speed $(echo 10 100 1000|pipemenu) duplex full autoneg off ; [ $(pingcheck) == "n" ] && ethtool -s $eth autoneg on && echo "$eth autoneg on" | push
!!! eth=$(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu) ;; ethtool -s $eth autoneg on ; ethtool $eth |cgrep speed 
# old speed chg
mii-tool $(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu)
!!! mii-tool -F $( echo 10 100 1000 |pipemenu)baseTx-FD  $(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu)
# 속도측정
yyay iperf
# 서버 side
ip a |grep bond;echo; ip a|gipa ;; iperf -s
# 클라이언트 side
iperf -c varServerIP





%%% {submenu_sys}ethx wireless setting [wifi]
%%%e {submenu_sys}ethx wireless setting [wifi]
# module up?
lsmod | grep -E '80211|wl|wifi|wlan'
# install
yyay wpasupplicant wireless-tools
# check ESSID
iwconfig 2>/dev/null | grep ESSID
iwlist $( iwconfig 2>/dev/null | grep ESSID | awk1 ) scan
# ssid psk set
echo -e 'network={\n     ssid="varSSID"\n     psk="varPASS"\n}' >> /etc/wpa_supplicant/wpa_supplicant.conf
vi2 /etc/wpa_supplicant/wpa_supplicant.conf
# connect 
wpa_supplicant -i $(iwconfig 2>/dev/null | grep ESSID | awk '{print $1}') -c /etc/wpa_supplicant/wpa_supplicant.conf -B 
# check
iwconfig 2>/dev/null
ifconfig | cip
ip a | cip
# 아래 내역 갈무리 후 수정
echo -e "auto $(iwconfig 2>/dev/null | grep ESSID | awk '{print $1}')\niface $(iwconfig 2>/dev/null | grep ESSID | awk '{print $1}') inet dhcp" 
vi2 /etc/network/interfaces
!!! systemctl restart networking
# 아이피 받아오기
dhclient $(iwconfig 2>/dev/null | grep ESSID | awk '{print $1}') ; ip a| cip



%%% {submenu_sys}ethx nmcli network-manager [nmcli]
%%%e {submenu_sys}ethx nmcli network-manager [nmcli]
# 기존 네트워크 관리자와 별도 작동 주의 
nmcli || { systemctl enable --now NetworkManager ; nmcli ; }
nmcli general $(echo status hostname permissions logging | pipemenu ) 
nmcli device status
nmcli device show
nmcli -g NAME con show ; echo ; nmcli con show ; echo ; nmcli con show --active
# ipset add / modify / up / down
nmcli con add con-name varConName ifname $(ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }'|pipemenu) type ethernet ipv4.method manual ipv4.address "varIP/24" ipv4.gateway "varGateWay" 
nmcli con mod "$(nmcli -g NAME con show|pipemenulist)" ipv4.address "varIP/24" ipv4.gateway "varGateWay"
nmcli con up $(nmcli -g NAME con show|pipemenulist)
nmcli con down $(nmcli -g NAME con show|pipemenulist)
# bridge net add
nmcli con add type bridge autoconnect yes con-name varConName__br0 ifname varConName__br0
nmcli con add type bridge-slave autoconnect yes con-name "$(nmcli -g NAME con show|pipemenulist)" ifname "$(nmcli -g NAME con show|pipemenulist)" master varConName
nmcli con mod varConName ipv4.method auto
nmcli con down varConName ; nmcli con up varConName
nmcli con show
# ifcfg mod -> reload
nmcli con reload
# dhcp
nmcli device modify "$(nmcli -g NAME con show|pipemenulist)" ipv4.method auto
# nmcli - wifi connect on / off / status
nmcli radio wifi varOPT__on__off ;;  nmcli radio wifi
nmcli radio wifi
nmcli device wifi list
export ssid=$( nmcli -f SSID device wifi list |awknr2|head -n5 |pipemenu) ;; nmcli device wifi connect $ssid password varPASS
#
explorer /etc/NetworkManager/
# install
nmcli || { yyay network-manager || yyay NetworkManager ; nmcli ; }
nmtui || { yyay network-manager net-tools NetworkManager-tui wget curl ; nmtui ; }
# resolv.conf 수정 못하게 설정후 재시작
FILE=/etc/NetworkManager/NetworkManager.conf ;grep -q "^dns=" $FILE && sed -i 's/^dns=.*/dns=none/' $FILE || sed -i '/\[main\]/a dns=none' $FILE
# 
systemctl status NetworkManager
systemctl restart NetworkManager
systemctl enable --now NetworkManager
systemctl disable --now NetworkManager
lshw -class network || { yyay lshw ; lshw -class network ; }








%%% {submenu_com}rdiff-backup 롤백지원 백업 [rdiff]
%%%e {submenu_com}rdiff-backup Rollback Support Backup [rdiff]
# backup
rdiff-backup /root /backup/root_rdiff_backup
rdiff-backup /script /backup/script_rdiff_backup
rdiff-backup varLpath varBackupPath
# chg check
rdiff-backup --list-increments /backup/root_rdiff_backup
rdiff-backup --list-increments /backup/root_rdiff_backup|grep "increments."| awk -F. '{print $2}'
rdiff-backup --list-increments varBackupPath
explorer /backup/root_rdiff_backup/rdiff-backup-data/
# restore now(최신) 3D(3일전) 1W(1주전) 2M(2달전)
rdiff-backup --restore-as-of "varAGO" --force /backup/root_rdiff_backup /root
rdiff-backup --restore-as-of "$(rdiff-backup --list-increments /backup/root_rdiff_backup|grep "increments."| awk -F. '{print $2}'|pipemenu)" --force /backup/root_rdiff_backup /root
rdiff-backup --restore-as-of "$(rdiff-backup --list-increments varBackupPath|grep "increments."| awk -F. '{print $2}'|pipemenu)" --force varBackupPath varLpath
# delete 1M (한달지난 백업본 삭제)
rdiff-backup --remove-older-than 1M varBackupPath
# 로컬 디렉터리를 원격 서버에 백업
rdiff-backup varLpath varID__root@varRhost::varBackupPath
# 원격 서버의 디렉터리를 로컬에 복구
rdiff-backup --restore-as-of varAGO__now varID__root@varRhost::varBackupPath varLpath
# cron add example (2am)
echo "#0 2 * * * root rdiff-backup /root /backup/root_rdiff_backup" >> /etc/crontab
#
# install
yyay rdiff-backup






%%% {submenu_lamp}debian lamp set flow - apache [a1]
%%%e {submenu_lamp}debian lamp set flow - apache [a1]
%% echo "http://$publicip"
: php8.3 repo add; apt install -y apt-transport-https ca-certificates lsb-release gnupg ; wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg ; echo "deb https://packages.sury.org/php/ $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/php.list 
apt update ; apt upgrade
apt search varPKG__php8@dot@3 | cgrep varPKG | less -RX
apt show varPKG__php8@dot@3
# apache2 php8 ( nextpage bind9 postfix dovecot vsftpd )
apt install apache2 libapache2-mod-php8.3
apt install php8.3 php8.3-cli php8.3-fpm php8.3-common php8.3-mysql php8.3-gd php8.3-mbstring php8.3-xml php8.3-zip php8.3-curl php8.3-opcache php8.3-readline php8.3-bcmath php8.3-xmlreader php8.3-xmlwriter php8.3-redis php8.3-memcached php8.3-imagick
php -v ; php -m | less -r
# apache2
lsof -i:80 
dpkg -L varPKG__apache2 | cgrep1 sbin etc | less -RX
explorer /etc/apache2
template_edit example.com.conf # go.sh 의 template 부분 수정 필요한 경우 
template_view example.com.conf
!!! template_copy example.com.conf /etc/apache2/sites-available/"varDom".conf ;; cat "$lastarg"
sed -i 's/example.com/varDom/g' /etc/apache2/sites-available/"varDom".conf ;; cat "$lastarg" | cgrep1 varDom
sed -i 's|/var/www/html|varWWWroot|g' /etc/apache2/sites-available/"varDom".conf ;; cat "$lastarg"
vi2 /etc/apache2/sites-available/"varDom".conf
mkdir -p varWWWroot
ps aux | grep apache # apache user 확인
chown -R varWWWuser__www-data:varWWWuser varWWWroot
chmod -R 755 varWWWroot ; ls -al varWWWroot
#
a2query varQuery__-m__-s__-c | cgrep1 enabled # module/site/config
: a2ensite; a2query -s | cgrep1 enabled ;; a2ensite "varDom".conf
: a2enmod; a2query -m | cgrep1 enabled ;; a2enmod varMod__rewrite__ssl__userdir
: a2enconf; a2query -c | cgrep1 enabled ;; a2enconf varConf
systemctl reload apache2 ;; systemctl status apache2
echo "<h1>Success! Your virtual host is working!</h1>" | tee varWWWroot/index.html
explorer varWWWroot
explorer /etc/apache2/mods-available
# en / dis 
a2query -c ;; varSetConf__a2enconf__a2disconf $( a2query -c | awk1 | pipemenucancel ) 
a2query -m ;; varSetMode__a2enmod__a2dismod $( a2query -m | awk1 | pipemenucancel )
a2query -s ;; varSetSite__a2ensite__a2dissite $( a2query -s | awk1 | pipemenucancel )
apachectl $( echo "start|stop|restart|graceful|graceful-stop|configtest|status|fullstatus|help" | pipemenucancel )



%%% {submenu_lamp}debian lamp set flow - mysql,modphp [a2]
%%%e {submenu_lamp}debian lamp set flow - mysql,modphp [a2]
# mysql (mariadb)
apt install mariadb-server mariadb-client
mysql_secure_installation
echo "mysqlrootpw=varPassWD" >> ~/go.private.txt ; source ~/go.private.txt
mysql -u root -p'$mysqlrootpw'
mysql -u root -p'$mysqlrootpw' -e "SHOW DATABASES;"
# user db create
mysql -u root -p'$mysqlrootpw' -e "CREATE DATABASE varWWWuser;"
mysql -u root -p'$mysqlrootpw' -e "CREATE USER 'varWWWuser'@'localhost' IDENTIFIED BY 'varWWWuserPW';"
mysql -u root -p'$mysqlrootpw' -e "GRANT ALL PRIVILEGES ON \`varWWWuser\`.* TO 'varWWWuser'@'localhost';"
mysql -u root -p'$mysqlrootpw' -e "FLUSH PRIVILEGES;"
# create/show tables;
mysql -u varWWWuser -p'varWWWuserPW' varWWWuser -e "CREATE TABLE items (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(100) NOT NULL, description TEXT, price DECIMAL(10, 2) DEFAULT 0.00, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);"
mysql -u varWWWuser -p'varWWWuserPW' varWWWuser -e 'show tables;'
# user db passwd update
mysql -u root -p'$mysqlrootpw' -e "ALTER USER 'varWWWuser'@'localhost' IDENTIFIED BY 'varWWWuserPW';"
#
explorer /etc/mysql/mariadb.conf.d/
systemctl varMode__restart__start__stop__status mariadb ;; systemctl status mariadb
vi2 /etc/mysql/mariadb.conf.d/50-server.cnf
cat /etc/mysql/mariadb.conf.d/50-server.cnf | cgrep1 bind-address max_connections innodb_buffer_pool_size innodb_log_file_size query_cache_size max_ character-set-server |less -RX
# open worldwide bind:127.0.0.1 -> bind:0.0.0.0 // ufw open
ufw allow 3306/tcp ; ufw reload
cat /etc/mysql/mariadb.conf.d/50-server.cnf|cgrep1 bind |less -RX
change /etc/mysql/mariadb.conf.d/50-server.cnf "bind-address            = 127.0.0.1" "bind-address = 0.0.0.0" line
systemctl restart mariadb
# php8 module on/off
a2enmod php8.3
a2dismod php8.3
systemctl restart apache2 
cat /etc/php/8.3/apache2/php.ini | cgrep1 limit max_ time listen user group |less -RX
vi2 /etc/php/8.3/apache2/php.ini # memory_limit = 256M upload_max_filesize = 64M post_max_size = 64M max_execution_time = 300 date.timezone = Asia/Seoul 
# purge old version
update-alternatives --set php /usr/bin/php8.3
dpkg -l | grep php | less -RX
!!! apt purge php8.2*




%%% {submenu_lamp}debian lamp set flow - php-fpm [a3]
%%%e {submenu_lamp}debian lamp set flow - php-fpm [a3]
%% echo "siteconf: $siteconf"
# php8 fpm 
apt install php8.3-fpm
a2enmod proxy proxy_fcgi setenvif
a2enconf php8.3-fpm
systemctl restart apache2 
systemctl enable php8.3-fpm --now
dpkg -L php8.3-fpm | cgrep etc | less -RX
# php8 fpm conf
cat /etc/php/8.3/fpm/php-fpm.conf | cgrep1 listen user group |less -RX
cat /etc/php/8.3/fpm/php.ini | cgrep1 limit max_ time listen user group |less -RX
cat /etc/php/8.3/fpm/pool.d/www.conf | cgrep1 listen owner user group 127.0.0.1 |less -RX
vi2 /etc/php/8.3/fpm/php-fpm.conf
vi2 /etc/php/8.3/fpm/php.ini
vi2 /etc/php/8.3/fpm/pool.d/www.conf
systemctl restart php8.3-fpm
explorer /etc/php/8.3/
# Apache VirtualHost - phpfpm set
cat /etc/apache2/sites-available/"varDom".conf
vi2 /etc/apache2/sites-available/"varDom".conf
# fpm-add in siteconf
export siteconf="/etc/apache2/sites-available/"varDom".conf" ;; ls -l $siteconf
# insert 함수를 이용해 fpm-add 추가 
printf '\n    <FilesMatch \\.php$>\n        SetHandler "proxy:unix:/run/php/php8.3-fpm.sock|fcgi://localhost/"\n    </FilesMatch>\n' | insert "$siteconf" "</Directory>" ;; cat $siteconf | cgrep1 php8.3-fpm.sock
systemctl restart apache2
# http://yoursite.com/info.php
echo "<?php phpinfo(); ?>" | tee varWWWroot/info.php
rm -f varWWWroot/info.php
# php-mysql-connect-check page
template_edit php_db_con_test.php # go.sh 의 template 부분 수정 필요한 경우
template_view php_db_con_test.php
!!! template_copy php_db_con_test.php varWWWroot/php_db_con_test.php ;; cat "$lastarg"
# 디비정보 수정후 http://yoursite.com/php_db_con_test.php
change varWWWroot/php_db_con_test.php your_db_user varWWWuser
change varWWWroot/php_db_con_test.php your_db_password varWWWuserPW
change varWWWroot/php_db_con_test.php your_db_name varWWWuser
vi2 varWWWroot/php_db_con_test.php
# test 후 즉시 삭제
rm -f varWWWroot/php_db_con_test.php* ;; ls -l varWWWroot # 테스트후 즉시삭제
#
explorer $( echo /etc/apache2/sites-available/ /etc/apache2/sites-enabled/ | pipemenu )
explorer varWWWroot



%%% {submenu_lamp}debian lamp set flow - bind - varNameDom [b1]
%%%e {submenu_lamp}debian lamp set flow - bind - varNameDom [b1]
%% echo "namedom:$namedom / serverip:$publicip"
apt install bind9 bind9utils bind9-doc dnsutils whois
# bind9 nameserver domain set - export
export namedom="varNameDom"
template_edit named.conf.options
template_view named.conf.options
!!! template_copy named.conf.options /etc/bind/named.conf.options
cat /etc/bind/named.conf.options | cgrep1 allow-query _SERVER_IP listen-on allow-transfer | less -RX
# 1차/2차 네임서버 아이피 설정
change /etc/bind/named.conf.options YOUR_1ST_NAME_SERVER_IP varNAME1IP 
change /etc/bind/named.conf.options "// YOUR_2ND_NAME_SERVER_IP" varNAME2IP 
vi2 /etc/bind/named.conf.options
named-checkconf /etc/bind/named.conf.options
#
# zone add 
printf "%s\n" 'zone "varNameDom" { type master; file "/etc/bind/db.varNameDom"; };' >> /etc/bind/named.conf.local
tail /etc/bind/named.conf.local | cgrep1 zone /etc/bind/db. | less -RX
vi2 /etc/bind/named.conf.local # zone add
# zone file edit - varNameDom
template_edit db.example.com
template_view db.example.com
!!! template_copy db.example.com /etc/bind/db.varNameDom # ns1 A 레코드 활성화 할것
cat /etc/bind/db.varNameDom | cgrep1 CNAME MX NS
change /etc/bind/db.varNameDom namedomain.com varNameDom
change /etc/bind/db.varNameDom YOUR_1ST_NAME_SERVER_IP varNAME1IP 
change /etc/bind/db.varNameDom YOUR_2ND_NAME_SERVER_IP varNAME2IP 
change /etc/bind/db.varNameDom YOUR_SERVER_IP varNAME1IP 
vi2 /etc/bind/db.varNameDom
# zone serial update
serialup /etc/bind/db.varNameDom
systemctl restart named ;;  systemctl status named
systemctl enable --now named ;;  systemctl status named
systemctl status named
#
named-checkconf /etc/bind/named.conf.local
named-checkzone varNameDom /etc/bind/db.varNameDom
named-checkconf
ufw allow 53
nmap -sU -p 53 $publicip
netstat -tulnp | grep named
journalctl -xeu named.service



%%% {submenu_lamp}debian lamp set flow - bind - varNameDom - reverse [b2]
%%%e {submenu_lamp}debian lamp set flow - bind - varNameDom - reverse [b2]
%% echo "namedom:$namedom / serverip:$publicip nameserverip:$nameserverip revip3o:$revip3o nameip3o:$nameip3o nameip4o:$nameip4o"
%% echo "namedom:$namedom / serverip:$publicip nameserver2ip:$nameserver2ip rev2ip3o:$rev2ip3o name2ip3o:$name2ip3o name2ip4o:$name2ip4o"
# Reverse Zone -> ISP 업체에 등록 요청해야 활성화
# IP 의 네트워크 부분을 뒤집어 이름을 만든다. 192.168.0 -> 0.168.192.in-addr.arpa
# varRevIP ex) 111.222.333.444 -> 444.333.222
# nameserverip
export namedom="varNameDom"
export nameserverip="varNAME1IP" ; export nameip3o=$(echo "$nameserverip" | awk -F. '{print $1"."$2"."$3}') ; export revip3o=$(echo "$nameserverip" | awk -F. '{print $3"."$2"."$1}') ; export nameip4o=$(echo "$nameserverip" | awk -F. '{print $4}')
# nameserver2ip (optional)
export nameserver2ip="varNAME2IP" ; export name2ip3o=$(echo "$nameserver2ip" | awk -F. '{print $1"."$2"."$3}') ; export rev2ip3o=$(echo "$nameserver2ip" | awk -F. '{print $3"."$2"."$1}') ; export name2ip4o=$(echo "$nameserver2ip" | awk -F. '{print $4}')
# named.conf.local add
printf '%s\n' 'zone "'"$revip3o"'.in-addr.arpa" { type master; file "/etc/bind/db.'"$nameip3o"'"; };' >> /etc/bind/named.conf.local ;; tail /etc/bind/named.conf.local | cgrep arpa
vi2 /etc/bind/named.conf.local
# db.nameserverip3octet create
template_edit db.example.com.rev
template_view db.example.com.rev
!!! template_copy db.example.com.rev /etc/bind/db.$nameip3o ;; ls -l /etc/bind/db.$nameip3o # ns1 A 레코드 활성화 할것
# ns1 revip
change /etc/bind/db.$nameip3o NS1IP4OCTET $nameip4o
change /etc/bind/db.$nameip3o example.com $namedom
# ns2 revip (optional)
change /etc/bind/db.$nameip3o NS2IP4OCTET $name2ip4o
#
cat /etc/bind/db.$nameip3o| cgrep1 CNAME MX NS
vi2 /etc/bind/db.$nameip3o
# zone serial update
serialup /etc/bind/db.$nameip3o
#
named-checkzone $revip3o.in-addr.arpa /etc/bind/db.$nameip3o
systemctl restart named ;;  systemctl status named
systemctl enable --now named ;;  systemctl status named
systemctl status named
# log 
mkdir /var/log/bind ; chown bind:bind /var/log/bind ; chmod 775 /var/log/bind
explorer /etc/bind



%%% {submenu_lamp}debian lamp set flow - bind - varDom [b3]
%%%e {submenu_lamp}debian lamp set flow - bind - varDom [b3]
%% echo "namedom:$namedom / serverip:$publicip"
printf "%s\n" 'zone "varDom" { type master; file "/etc/bind/db.varDom"; };' >> /etc/bind/named.conf.local
tail /etc/bind/named.conf.local | cgrep1 zone /etc/bind/db. | less -RX
vi2 /etc/bind/named.conf.local # zone add
# zone file edit - varDom
template_edit named.conf.options
template_view named.conf.options
!!! template_copy db.example.com /etc/bind/db.varDom # ns1 A 레코드 주석 
cat /etc/bind/db.varDom | cgrep1 CNAME MX NS
change /etc/bind/db.varDom namedomain.com varNameDom
change /etc/bind/db.varDom YOUR_1ST_NAME_SERVER_IP varNAME1IP 
change /etc/bind/db.varDom YOUR_2ND_NAME_SERVER_IP varNAME2IP 
change /etc/bind/db.varDom YOUR_SERVER_IP varDomIP 
vi2 /etc/bind/db.varDom
#
named-checkzone varDom /etc/bind/db.varDom
#
systemctl restart bind9
#
nslookup varDom
dig varDom
dig -x varDomIP # (역방향 DNS 조회)
#
nslookup varNameDom
nslookup varNameDom 127.0.0.1
nslookup varNameDom ns1.varNameDom
nslookup -type=NS varNameDom
dig varNameDom
dig -x varNameDomIP # (역방향 DNS 조회)
resolvectl status
# zone serial update
serialup /etc/bind/db.varDom
#
systemctl restart named ;;  systemctl status named
systemctl enable --now named ;;  systemctl status named
systemctl status named
#
explorer /etc/bind





%%% {submenu_lamp}debian lamp set flow - postfix [m1]
%%%e {submenu_lamp}debian lamp set flow - postfix [m1]
apt install postfix dovecot-core dovecot-imapd dovecot-pop3d mailutils
# postfix (smtp)
vi2 /etc/postfix/main.cf 
cat /etc/postfix/main.cf |cgrep1 myhostname mydomain myorigin my private mailbox
rbackup /etc/postfix/main.cf ;; ls -ltr ${lastarg}*|tail -n5
echo "home_mailbox = Maildir/" >> /etc/postfix/main.cf
vi2 /etc/postfix/master.cf
change /etc/postfix/master.cf  "#submission inet n"  "submission inet n"
change /etc/postfix/master.cf  "#  -o syslog_name=" "  -o syslog_name="
change /etc/postfix/master.cf  "#  -o smtpd_tls_security_level=encrypt" "  -o smtpd_tls_security_level=encrypt"
change /etc/postfix/master.cf  "#  -o smtpd_sasl_auth_enable=yes" "  -o smtpd_sasl_auth_enable=yes"
change /etc/postfix/master.cf  "relay_restrictions" "  -o smtpd_relay_restrictions=permit_sasl_authenticated,reject" line
# postfix sasl auth set 
change /etc/postfix/main.cf smtpd_relay_restrictions "smtpd_relay_restrictions = permit_mynetworks, permit_sasl_authenticated, reject_unauth_destination" line
printf $'smtpd_sasl_type = dovecot\nsmtpd_sasl_path = private/auth  \nsmtpd_sasl_auth_enable = yes\n' >> /etc/postfix/main.cf
cdiff /etc/postfix/main.cf.1.bak /etc/postfix/main.cf 
# 
postconf -n | cgrep1 sasl home_mailbox myhostname
postfix check
systemctl restart postfix ;; systemctl status postfix
systemctl enable --now postfix ;; systemctl status postfix
journalctl -u postfix -n 200
nmap localhost
echo "Test Mail" | mail -s "Test Subject" root@varDom
ls -al /var/mail ;; ls -al ~/Maildir/new/


%%% {submenu_lamp}debian lamp set flow - dovecot [m2]
%%%e {submenu_lamp}debian lamp set flow - dovecot [m2]
# Dovecot (imap/pop)
vi2 /etc/dovecot/dovecot.conf # protocols = imap pop3 , mail_location = maildir:~/Maildir
# mail_location chg ~/Maildir/
change /etc/dovecot/conf.d/10-mail.conf "mail_location" "mail_location = maildir:~/Maildir" line
cat /etc/dovecot/conf.d/10-mail.conf | cgrep1 mail_location | less -RX
vi2 /etc/dovecot/conf.d/10-mail.conf
# 10-auth.conf
cat /etc/dovecot/conf.d/10-auth.conf | cgrep1 auth-system.conf.ext  | less -RX
vi2 /etc/dovecot/conf.d/10-auth.conf
change /etc/dovecot/conf.d/10-auth.conf "#disable_plaintext_auth" "disable_plaintext_auth = no" line
change /etc/dovecot/conf.d/10-auth.conf "auth_mechanisms" "auth_mechanisms = plain login" line
change /etc/dovecot/conf.d/10-auth.conf "#!include auth-system.conf.ext" "!include auth-system.conf.ext" line
: insert; echo 'auth_username_format = %n' | insert /etc/dovecot/conf.d/10-auth.conf "#auth_username_format"
# 10-master.conf -> sasl auth set (smtp auth)
rbackup /etc/dovecot/conf.d/10-master.conf ;; ls -ltr ${lastarg}*|tail -n5
: insert; printf $'  unix_listener /var/spool/postfix/private/auth {\n    mode = 0666\n    user = postfix\n    group = postfix\n  }\n' | insert /etc/dovecot/conf.d/10-master.conf "postfix/private" ;; cdiff /etc/dovecot/conf.d/10-master.conf.1.bak /etc/dovecot/conf.d/10-master.conf
vi2 /etc/dovecot/conf.d/10-master.conf
vi2 /etc/dovecot/conf.d/10-ssl.conf
vi2 /etc/postfix/main.cf
#
systemctl restart postfix ;; systemctl status postfix
systemctl enable --now postfix ;; systemctl status postfix
systemctl restart dovecot ;; systemctl status dovecot
systemctl enable --now dovecot ;; systemctl status dovecot
dovecot -n
# useradd
adduser -m -s /bin/bash varMailuser
paswd varMailuser
# ufw
ufw allow 25/tcp ; ufw allow 587/tcp ; ufw allow 993/tcp ;ufw allow 995/tcp
ufw reload
# todo
# Certbot 
# SPF, DKIM, DMARC, 스팸 필터
# 웹메일 설치: Roundcube, SquirrelMail

# vsftpd


%%% {submenu_lamp}debian lamp set flow - roundcube webmail [m3]
%%%e {submenu_lamp}debian lamp set flow - roundcube webmail [m3]
%% echo "roundcubepath:$roundcubepath // SERVERNAME:$SERVERNAME // http://$SERVERNAME/installer/"
# mailserver / mariadb / apache / php / dns (webmail.mailserver.com)
# Roundcube용 데이터베이스 및 사용자 생성
[ -z "$mysqlrootpw" ] && echo "mysqlrootpw=varPassWD" >> ~/go.private.txt ; source ~/go.private.txt
echo $mysqlrootpw ;; mysqlrootpw=varPassWD
mysql -u root -p"$mysqlrootpw"
# roundcube db create
mysql -u root -p"$mysqlrootpw" -e "CREATE DATABASE roundcube CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;CREATE USER 'roundcube'@'localhost' IDENTIFIED BY 'varRCpw';GRANT ALL PRIVILEGES ON roundcube.* TO 'roundcube'@'localhost';FLUSH PRIVILEGES;"
mysql -u root -p"$mysqlrootpw" -e "show databases;"
# install 
export roundcubepath=varRCPath__@@var@@www
cd $roundcubepath ; ls -al 
: download ; API_URL="https://api.github.com/repos/roundcube/roundcubemail/releases/latest" ;; DOWNLOAD_URL=$(curl -sL "$API_URL" | jq -r '.assets[] | select(.name | test("-complete.tar.gz$")) | .browser_download_url') ;; FILENAME="roundcube-latest-complete.tar.gz" ;; curl -L "$DOWNLOAD_URL" -o "$FILENAME"
: extract ; tar -xzf "$FILENAME" ;; EXTRACTED_DIR=$(find . -maxdepth 1 -type d -name 'roundcubemail-*' -print -quit) ;; mv "$EXTRACTED_DIR" roundcube
ls -al $roundcubepath/roundcube
cd roundcube && chown -R www-data:www-data . && chmod -R 775 temp/ logs
# /etc/apache2/sites-available/roundcube.conf
# ex) SERVERNAME=webmail.yourdoamin.com
export SERVERNAME="varWebmailDom"
template_edit roundcube.conf
template_view roundcube.conf
!!! template_copy roundcube.conf /etc/apache2/sites-available/roundcube.conf
vi2 /etc/apache2/sites-available/roundcube.conf
a2ensite roundcube.conf
systemctl reload apache2
tail -f $( ls -1 /var/log/apache2/*.log |pipemenu ) 
# web install
# http://$SERVERNAME/installer/
vi $roundcubepath/roundcube/config/config.inc.php
chown www-data:www-data $roundcubepath/roundcube/config/config.inc.php ; chmod 600 $roundcubepath/roundcube/config/config.inc.php
# install page del or mv 
mv $roundcubepath/roundcube/installer/ $roundcubepath/roundcube/installer.$(datetag) ; ls -al 
# log
tail -f $roundcubepath/roundcube/logs/errors.log
cat $roundcubepath/roundcube/logs/errors.log | less -RX



%%% {submenu_lamp}debian lamp set flow - certbot [m4]
%%%e {submenu_lamp}debian lamp set flow - certbot [m4]
%% echo "roundcubepath:$roundcubepath // SERVERNAME:$SERVERNAME // http://$SERVERNAME/installer/"
# Let's Encrypt 인증서 발행후
# /etc/postfix/main.cf /etc/dovecot/conf.d/10-ssl.conf 
# 인증서/개인키 갱신 필요
# ex) SERVERNAME=webmail.yourdoamin.com
export SERVERNAME="varWebmailDom"
# certbot
apt install python3-certbot-apache
certbot --apache -d $SERVERNAME
# dovecot-ssl.conf - ssl change
cat /etc/dovecot/conf.d/10-ssl.conf | cgrep1 ssl_cert ssl_key | less -RX
change /etc/dovecot/conf.d/10-ssl.conf "ssl_cert =" "ssl_cert = </etc/letsencrypt/live/$SERVERNAME/fullchain.pem" line
change /etc/dovecot/conf.d/10-ssl.conf "ssl_key =" "ssl_key = </etc/letsencrypt/live/$SERVERNAME/privkey.pem" line
# postfix-main.cf - ssl change
cat /etc/postfix/main.cf | cgrep1 smtpd_tls_cert_file smtpd_tls_key_file | less -RX
change /etc/postfix/main.cf "smtpd_tls_cert_file=" "smtpd_tls_cert_file=/etc/letsencrypt/live/$SERVERNAME/fullchain.pem" line
change /etc/postfix/main.cf "smtpd_tls_key_file=" "smtpd_tls_key_file=/etc/letsencrypt/live/$SERVERNAME/privkey.pem" line
# privkey read perm 
# 예: ssl-cert 그룹이 있고 dovecot 사용자를 추가해야 한다면
groupadd ssl-cert # 그룹이 없다면 생성
chown root:ssl-cert /etc/letsencrypt/live/$SERVERNAME/privkey.pem
chmod 640 /etc/letsencrypt/live/$SERVERNAME/privkey.pem
ls -al /etc/letsencrypt/live/$SERVERNAME/privkey.pem
ls -ald /etc/letsencrypt/archive/
chmod 711 /etc/letsencrypt/archive/
ls -al /etc/letsencrypt/archive/$SERVERNAME
usermod -a -G ssl-cert dovecot
#
systemctl restart dovecot ;; systemctl status dovecot
journalctl -u dovecot -n 50 --no-pager
journalctl -f -u dovecot
tail -n1000 /var/log/mail.log|less -RX


%%% {submenu_lamp}debian lamp set flow - vsftpd [f1]
%%%e {submenu_lamp}debian lamp set flow - vsftpd [f1]
# vsftpd
# anonymous_enable=NO local_enable=YES write_enable=YES chroot_local_user=YES
apt install vsftpd
vi2 /etc/vsftpd.conf 
cat /etc/vsftpd.conf | cgrep1 listen _enable local_umask use_localtime | less -RX
change /etc/vsftpd.conf "listen=NO" "listen=YES"
change /etc/vsftpd.conf "listen_ipv6=YES" "listen_ipv6=NO"
change /etc/vsftpd.conf "#write_enable=YES" "write_enable=YES"
change /etc/vsftpd.conf "#local_umask=022" "local_umask=022"
change /etc/vsftpd.conf "#xferlog_file=/var/log/vsftpd.log" "xferlog_file=/var/log/vsftpd.log"
change /etc/vsftpd.conf "#chroot_local_user=YES" "chroot_local_user=YES"
echo "allow_writeable_chroot=YES" | insert /etc/vsftpd.conf "chroot_local_user=YES"
printf $'pasv_enable=YES\npasv_min_port=40000\npasv_max_port=40100\n' >> /etc/vsftpd.conf
# 
systemctl restart vsftpd ;;  systemctl status vsftpd
systemctl enable --now vsftpd ;;  systemctl status vsftpd
systemctl status vsftpd
# ufw firewall
apt install ufw
ufw enable
ufw status
# all allow
for port in ssh http https ftp 20/tcp 1024:1048/tcp domain pop3 pop3s imap imaps smtp smtps submission; do ufw allow $port; done
# select allow
ufw varMode__allow__disallow varPort__ssh__http__https__ftp__20@@tcp__domain__pop3__pop3s__imap__imaps__smtp__smtps__submission__mysql__3306@@tcp__postgresql__5432@@tcp__redis__6379@@tcp__mongodb__27017@@tcp__memcached__11211@@tcp__25565@@tcp__21@@tcp__990@@tcp__25@@tcp__587@@tcp__465@@tcp__1194@@udp__500@@udp__4500@@udp
# ftp passive mode
ufw allow 40000:40100/tcp 
# backup rsync
apt install rsync -y
rsync -avz /var/www/ /backup/www/
rsync -avz /etc/apache2/ /backup/apache2/
rsync -avz /etc/bind/ /backup/bind/
rsync -avz /etc/postfix/ /backup/postfix/
rsync -avz /etc/dovecot/ /backup/dovecot/
rsync -avz /etc/vsftpd.conf /backup/



%%% {submenu_lamp}debian lamp set flow - phpmyadmin [f2]
%%%e {submenu_lamp}debian lamp set flow - phpmyadmin [f2]
# install
apt install phpmyadmin
dpkg-reconfigure phpmyadmin
# apache module add
vi2 /etc/apache2/conf-available/phpmyadmin.conf
a2enconf phpmyadmin.conf
systemctl reload apache2 ;; systemctl status apache2 
# web
# http://yourdomain.com/phpmyadmin/
explorer /var/www/
explorer /etc/apache2/
# fail2ban
#
# ( optional )  
# apache auth add // phpmyadmin ddos ban
mkdir /etc/apache2/.htpasswd
# pre auth to enter phpmyadmin
touch /etc/apache2/.htpasswd/pma_pass ; chown root:www-data /etc/apache2/.htpasswd/pma_pass ; chmod 640 /etc/apache2/.htpasswd/pma_pass
htpasswd /etc/apache2/.htpasswd/pma_pass varUSER
vi2 /etc/apache2/.htpasswd/pma_pass
# perm
chown root:www-data /etc/apache2/.htpasswd/pma_pass ; chmod 640 /etc/apache2/.htpasswd/pma_pass
# auth set 
printf $'AuthType Basic\nAuthName "Restricted Access - phpMyAdmin"\nAuthUserFile /etc/apache2/.htpasswd/pma_pass\nRequire valid-user\n' | insert /etc/apache2/conf-available/phpmyadmin.conf "DirectoryIndex index.php"



%%% {submenu_lamp}Web Hosting Control Panel - aaPanel [aap]
%%%e {submenu_lamp}Web Hosting Control Panel - aaPanel [aap]
# clean os -> aapenel install   6 sudo apt update && sudo apt upgrade -y
URL=https://www.aapanel.com/script/install_7.0_en.sh && if [ -f /usr/bin/curl ];then curl -ksSO "$URL" ;else wget --no-check-certificate -O install_7.0_en.sh "$URL";fi;bash install_7.0_en.sh aapanel
# ufw allow
sudo ufw allow 7800/tcp  ; sudo ufw allow 443/tcp ; sudo ufw allow 20/tcp  
sudo ufw reload        # 방화벽 규칙 다시 로드
# https://<YOUR_SERVER_IP>:7800/
bt
service bt varMode__start__stop__restart
# uninstall
service bt stop && chkconfig --del bt && rm -f /etc/init.d/bt && rm -rf /www/server/panel
systemctl stop bt.service ; systemctl disable bt.service ; rm -f /etc/init.d/bt ; rm -f /lib/systemd/system/bt.service /etc/systemd/system/bt.service ; systemctl daemon-reload ; rm -rf /www/server/panel
# etc
# 상용: cPanel, Plesk, DirectAdmin
# 오픈소스: aaPanel, HestiaCP, CyberPanel, Webmin/Virtualmin, CloudPanel







%%% {submenu_lamp}debian/ubuntu lamp set [lampu]
%%%e {submenu_lamp}debian/ubuntu lamp set [lampu]
# db
apt install -y mariadb-server mariadb-client
mysql_secure_installation
systemctl status mariadb
# apache2
apt install -y apache2 apache2-doc
a2enmod userdir
systemctl restart apache2
# firewalld
apt install ufw
ufw app list
ufw app info "WWW Full"
ufw allow in "WWW Full"
# php / perl / python
apt install -y php libapache2-mod-php php-mysql
apt install -y php-cli php-fpm php-json php-pdo php-mbstring php-zip php-gd php-curl
vi2 /var/www/html/info.php
#
apt install -y perl libapache2-mod-perl2
apt install -y python3 libapache2-mod-python
#
apt install -y phpmyadmin
vi2 /etc/apache2/conf-available/phpmyadmin.conf
ln -s /etc/phpmyadmin/apache.conf /etc/apache2/conf-available/phpmyadmin.conf
a2enconf phpmyadmin
systemctl reload apache2
#
ls -al /etc/apache2/sites-enabled/
ls -al /etc/apache2/sites-available/ ;; a2ensite varSITE
a2dissite varSITE
a2ensite varSITE
explorer /etc/apache2/





%%% {submenu_lamp}Rocky,Alma (8/9) lamp set [lampc]
%%%e {submenu_lamp}Rocky,Alma (8/9) lamp set [lampc]
# apache install
dnf install -y httpd httpd-tools
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
firewall-cmd --permanent --zone=public --add-service=http 
firewall-cmd --permanent --zone=public --add-service=https 
firewall-cmd --reload
systemctl restart httpd
# http://IP_address
#
# php install epel repo add
rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
# alma8 php7.x
dnf module list php
dnf module reset php
dnf module enable php:varVersion
dnf install -y php php-cli php-gd php-curl php-zip php-mbstring php-mysqlnd
# alma9 php8.1
dnf install -y php php-mysqlnd php-dom php-simplexml php-xml php-xmlreader php-curl php-exif php-ftp php-gd php-iconv php-json php-mbstring php-posix php-sockets php-tokenizer
systemctl restart httpd 
php -v 
dnf install -y phpMyAdmin.noarch
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
dnf search php
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
# db install
dnf install -y mariadb-server mariadb
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql_secure_installation
mysql -e "SHOW DATABASES;" -p
# 
ntsysv || yy ntsysv



%%% {submenu_lamp}Centos7 lamp set [lampcc]
%%%e {submenu_lamp}Centos7 lamp set [lampcc]
# apache install
yum install -y httpd
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
firewall-cmd --permanent --zone=public --add-service=http
firewall-cmd --permanent --zone=public --add-service=https
firewall-cmd --reload
systemctl restart httpd
# http://IP_address
#
# php
yum install -y php php-mysql
systemctl restart httpd
php -v
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
yum install -y phpmyadmin
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
# db install
yum install -y mariadb-server mariadb
mysql_secure_installation
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql -e "SHOW DATABASES;" -p
#
ntsysv || yy ntsysv


%%% {submenu_lamp}Annyung3 lamp set [lampan3]
%%%e {submenu_lamp}Annyung3 lamp set [lampan3]
# apache install
yum install -y varPkg__httpd
yy httpd mod_ssl httpd-devel
yum search varPkg__httpd --disablerepo='*' --enablerepo="AN:addon" --enablerepo="AN:core" --enablerepo="AN:base" --enablerepo="AN:xless"
yum list varPkg__httpd* |cgrep Installed|cgrep1 Available
yum list installed |grep varPkg__http
systemctl enable httpd ; systemctl start httpd ; systemctl status httpd
chattr +i /etc/httpd/conf/httpd.conf ; vi2 /etc/httpd/conf/httpd.conf
vi2 $( find /etc/httpd/conf.d/ -type f | pipemenu )
vi2 $( find /etc/httpd/user.d/ -type f | pipemenu )
explorer /etc/httpd/
httpd -V | cgrep MPM | cdir
# http://IP_address
#
# php install
yy php80* --skip-broken
yy php74* --skip-broken
yum list installed|grep php
explorer /etc/$( ls -1 /etc/ |grep php | pipemenu )
systemctl restart httpd
php -v
# http://IP_address/info.php
echo "<?php phpinfo() ?>" > /var/www/html/info.php
# phpmyadmin
yy phpmyadmin
rpm -ql varPKG__phpMyAdmin | less -RX
vi2 /etc/httpd/conf.d/phpMyAdmin.conf
yumdownloader phpMyAdmin.noarch
rpms=$(ls -1tr|grep phpMyAdmin|tail -n1) ; rpm -ivh --nodeps $rpms ; readx ; rpm -ql ${rpms%.rpm}
# db install
yum install -y mariadb-server mariadb
mysql_secure_installation
systemctl enable mariadb ; systemctl start mariadb ; systemctl status mariadb
mysql -e "SHOW DATABASES;" -p
# httpd watch
rpm -ql check-utils
/usr/bin/chkbandwidth
/usr/bin/httpwatch http://localhost
vi2 $( echo /etc/cron.d/httpd-monitor /etc/sysconfig/httpd-monitor|pipemenu )
# proftpd 
yy proftpd
systemctl start proftpd.socket
netstat -tulpn | grep -v :::|grep LISTEN|sort -k4
#
ntsysv || yy ntsysv



%%% {submenu_lamp}Annyung3 Java set [an3j]
%%%e {submenu_lamp}Annyung3 Java set [an3j]
yy java
yy java-devel
yum list java*
yum list installed java* 
# /etc/ config list
for i in $( yum list installed java* |grep "^java" |awk1) ;do echo $i ;echo ; rpm -ql $i |grep /etc/; done



%%% {submenu_lamp}Annyung3 Dns set [an3d]
%%%e {submenu_lamp}Annyung3 Dns set [an3d]
vi2 $( find /var/named -maxdetph 1 | pipemenulist ) 
vi2 $( find /var/named/etc -maxdetph 1 | pipemenulist ) 
vi2 $( find /var/named/zone -maxdetph 1 | pipemenulist ) 
# chroot /var/named 
cd /var/named/ ; ls 
explorer /var/named/


%%% {submenu_lamp}Apache Modules - mod_cband [cband]
%%%e {submenu_lamp}Apache Modules - mod_cband [cband]
wget https://fossies.org/linux/www/apache_httpd_modules/old/mod-cband-0.9.7.5.tgz
tar zxvf mod-cband-0.9.7.5.tgz 
cd mod-cband-0.9.7.5
which apxs || yyay httpd-devel
./configure --with-apxs=$(which apxs)
make
# apache 2.4 error -> patch
sed s/remote_ip/client_ip/g -i src/mod_cband.c
sed s/c-\>remote_addr/c-\>client_addr/g -i src/mod_cband.c
make
make install
# load module set add -> httpd.conf
echo "LoadModule cband_module       modules/mod_cband.so" >> /etc/httpd/conf/httpd.conf
echo "LoadModule cband_module       modules/mod_cband.so" >> /usr/local/apache/conf/httpd.conf
echo "LoadModule cband_module       modules/mod_cband.so" >> /etc/httpd/conf.d/LoadModules.conf
# cband-status permit set
!!! template_copy cband.conf /etc/httpd/conf.d/cband.conf ; vi2 /etc/httpd/conf.d/cband.conf
vi2 /etc/httpd/conf.d/cband.conf
# apache 2.4 error -> 'Order command' error -> access_compat_module -> on
# 
explorer /etc/httpd/
#
systemctl status httpd
systemctl restart httpd



%%% {submenu_lamp}Lamp - auto install sh GIT [lampa]
%%%e {submenu_lamp}Lamp - auto install sh GIT [lampa]
# https://github.com/teddysun/lamp
# source down & compile install /usr/local/src
yyay wget git
cd $HOME ; git clone https://github.com/teddysun/lamp.git
cd $HOME/lamp
chmod 755 *.sh
vi2 ./lamp.sh
./lamp.sh
# auto
./lamp.sh -h
# auto example
./lamp.sh --apache_option 1 --apache_modules mod_wsgi,mod_security --db_option 1 --db_root_pwd teddysun.com --php_option 1 --php_extensions apcu,ioncube,imagick,redis,mongodb,libsodium,swoole --db_manage_modules phpmyadmin,adminer --kodexplorer_option 1
# 
# upgrade
cd $HOME/lamp
# Resets the index and working tree
git reset --hard         
# Get latest version first
git pull                 
chmod 755 *.sh
vi2 ./upgrade.sh
./upgrade.sh             
./upgrade.sh apache     
./upgrade.sh db        
./upgrade.sh php      
./upgrade.sh phpmyadmin 
./upgrade.sh adminer   
# backup
vi2 ./backup.sh
./backup.sh
# uninstall
vi2 ./uninstall.sh
!!! ./uninstall.sh





%%% {submenu_sys}webd ftpd smtpd popd [dmi]
%%%e {submenu_sys}webd ftpd smtpd popd [dmi]
# apache2
yyay apache2
vi2 /etc/apache2/apache2.conf
explorer /etc/apache2
a2enmod varModule__rewrite
systemctl $( echo restart start stop status | pipemenu ) apache2
# nginx
yyay nginx
vi2 /etc/nginx/nginx.conf
explorer /etc/nginx
systemctl $( echo restart start stop status | pipemenu ) nginx
# ftpd proftpd
yyay proftpd
explorer /etc/proftpd
systemctl $( echo restart start stop status | pipemenu ) proftpd.socket
# ftpd vsftpd
yyay vsftpd
vi2 /etc/vsftpd.conf
systemctl $( echo restart start stop status | pipemenu ) vsftpd
# maild smtp sendmail (sendmail.mc Addr 127.0.0.1 -> 0.0.0.0)
yyay sendmail sendmail-cf
vi2 /etc/mail/sendmail.mc /Addr 
m4 /etc/mail/sendmail.mc > /etc/mail/sendmail.cf
explorer /etc/mail/
systemctl $( echo restart start stop status | pipemenu ) sendmail
# maild smtp postfix
yyay postfix mailutils libsasl2-2 ca-certificates libsasl2-modules
vi2 /etc/postfix/main.cf 
postconf compatibility_level=3.6
explorer /etc/postfix/
systemctl $( echo restart start stop status | pipemenu ) postfix 
# mail login auth sasl add
# https://93it-serverengineer.co.kr/57
vi2 /etc/sasl2/Sendmail.conf
echo "pwcheck_method: saslauthd" > /etc/sasl2/Sendmail.conf
systemctl enable --now saslauthd
# maild pop imap & clients & tools
yyay dovecot-imapd dovecot-pop3d || yyay dovecot
yyay sendemail mailx ed
vi2 /etc/dovecot/dovecot.conf
explorer /etc/dovecot/
systemctl $( echo restart start stop status | pipemenu ) dovecot
# 서버의 mail command -> gmail smtp 사용 메일발송 (postfix)
# Google 계정관리 - 보안 - 2단게 인증 - 앱 비밀번호 생성
rbackup /etc/postfix/sasl_passwd ; echo "smtp.gmail.com varGmailadd:varGmailAppPW" > /etc/postfix/sasl_passwd
postmap hash:/etc/postfix/sasl_passwd ; chmod 600 /etc/postfix/sasl_passwd
!!! template_copy postfix.yml /etc/postfix/main.cf ; cat /etc/postfix/main.cf
echo "/From:.*/ REPLACE From: varName <varGmailadd>" >> /etc/postfix/header_check
vi2 /etc/postfix/header_check
echo "smtp_header_checks = regexp:/etc/postfix/header_check" >> /etc/postfix/main.cf
postfix reload
# test
pstree | mail -s "pstree $(hostname)" varGmailadd




%%% {submenu_com}nfs server [nfs]
%%%e {submenu_com}nfs server [nfs]
%% echo "nfsdir: $nfsdir"
# install
yy nfs-utils rpcbind
ay nfs-kernel-server nfs-common
# share dir create 
export nfsdir="varShareDir__@@nfs.share"
mkdir -p $nfsdir && chmod 777 $nfsdir && touch $nfsdir/.nfs.share.$localip1 ; ls -al $nfsdir
explorer $nfsdir
# nfs 서버에 접근을 허용할 IP 대역 지정 
# remoteip ex) 192.168.0.1 or 192.168.0.1/24 or 192.168.0.1/16 or *
# 접근권한 ex) no_root_squash / root_squash / no_all_squash / all_squash
echo "localip: $localip" ;; echo "$nfsdir varRemoteIP(rw,sync,no_root_squash)" >> /etc/exports && vi2 /etc/exports
echo "localip: $localip" ;; echo "$nfsdir varRemoteIP(rw,sync,no_root_squash) varRemoteIP2(rw,sync,no_root_squash)" >> /etc/exports && vi2 /etc/exports
vi2 /etc/exports
# firewall port open 111,2049,20048,32769(tcp/udp) nfs/mountd/rpc-bind
# 
systemctl enable --now nfs-server ; systemctl status nfs-server
!!! systemctl disable --now nfs-server ; systemctl status nfs-server
systemctl status nfs-server
# apply
exportfs -ra
exportfs -v
showmount -e 
#
vi2 $( ls -1 /etc/fstab /etc/idmapd.conf /etc/sysconfig/nfs /etc/nfs.conf 2>/dev/null | pipemenu1 ) 
#
# client
#
# nfs mount 
mkdir -p varLocalDIR__@@mnt@@nfs.mount ; mount -t nfs -o nolock varRHOST:varShareDir__@@nfs.share varLocalDIR__@@mnt@@nfs.mount ; df -h
cd varLocalDIR ; ls -al ;
explorer varLocalDIR
# nfs fstab add
echo "varRHOST:varShareDir varLocalDIR nfs nolock,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab



%%% {submenu_com}autofs 자동마운트 [afs]
%%%e {submenu_com}autofs auto mount [afs]
# nfs clinet - auto nfs mount
yyay autofs
echo "/-    /etc/auto.mount" >> /etc/auto.master
vi2 /etc/auto.master
echo -e "# create new : [mount point] [option] [location]\nvarLocalDIR__@@mnt@@nfs.mount -fstype=nfs,rw  varRHOST:varShareDir__@@nfs.share" >> /etc/auto.mount
vi2 /etc/auto.mount
systemctl enable --now autofs
systemctl status autofs
df ; echo ; cd varLocalDIR__@@mnt@@nfs.mount ; ls -al ; echo ; df




: ubu/debian ; systemctl enable --now iscsid ; systemctl status iscsid



%%% {submenu_com}iscsi server [iss]
%%%e {submenu_com}iscsi server [iss]
%% echo "iqn:$iqn  ciqn:$ciqn"
# nfs (파일수준공유,로컬파일) vs iscsi (블록수준공유,로컬디스크)
# server (iscsi target)
yy targetcli || ay targetcli-fb 
: centos ; systemctl enable --now target ; systemctl status target
: ubu/debian ; systemctl enable --now targetclid ; systemctl status targetclid
export sharedir="varSHARE__@@iscsi_share" ; mkdir -p $sharedir
export diskname="varDiskName__idisk1"
targetcli
# Create a file to be used as a backstore
targetcli /backstores/fileio create $diskname $sharedir/$diskname varSIZE__10G ;ls -alh $sharedir
# Create an iSCSI target
targetcli /iscsi create 
#
# iscsi 경로를 마음속에 저장 
targetcli ls /iscsi
#
export iqn=$(targetcli ls /iscsi | grep "iqn." | awk '{print $2}' | head -n1 ) ; echo $iqn
export iqn=$(targetcli ls /iscsi | grep "iqn." | awk '{print $2}' | tail -n1 ) ; echo $iqn
targetcli ls /iscsi ;; export iqn=varIQN
# unused iqn delete 
!!! targetcli /iscsi delete $iqn
# set LUN - Link the backstore to the target as LUN 0 and add network portal
targetcli /iscsi/$iqn/tpg1/luns create /backstores/fileio/$diskname
# set ACL - Add ACL for a specific initiator
# iscsi initiator iqn ( client side /etc/iscsi/initiatorname.iscsi copy & paste )
export ciqn=varClientIQN
targetcli /iscsi/$iqn/tpg1/acls create $ciqn
!!! targetcli /iscsi/$iqn/tpg1/acls delete $ciqn
# acl 
targetcli /iscsi/$iqn/tpg1/acls/$ciqn set attribute authentication=1
targetcli /iscsi/$iqn/tpg1/acls/$ciqn set auth userid=varUsername
targetcli /iscsi/$iqn/tpg1/acls/$ciqn set auth password=varPassword
!!! targetcli /iscsi/$iqn/tpg1/acls/$ciqn delete auth userid
!!! targetcli /iscsi/$iqn/tpg1/acls/$ciqn delete auth password
targetcli saveconfig
systemctl restart targetclid || systemctl restart target
systemctl disable --now targetclid || systemctl disable --now target
echo "$publicip $localip" | cip




%%% {submenu_com}iscsi client [isc]
%%%e {submenu_com}iscsi client [isc]
%% echo "iqn:$iqn  ciqn:$ciqn"
# iscsi server -> wan 접속 불가 // vpn,lan 접속 가능 
# client (isci initiator)
yyay open-iscsi
systemctl enable --now iscsid ; systemctl status iscsid
# clinetIQN 복사후 serverside acl 인증에 적용 
vi2 /etc/iscsi/initiatorname.iscsi
export ciqn=$( cat /etc/iscsi/initiatorname.iscsi | awk -F'=' '/InitiatorName/ && $2 != "" {print $2}')
# id/pw 설정후 재시작
echo -e "node.session.auth.authmethod = CHAP\nnode.session.auth.username = varUsername\nnode.session.auth.password = varPassword" >> /etc/iscsi/iscsid.conf
vi2 /etc/iscsi/iscsid.conf ; chmod 600 /etc/iscsi/iscsid.conf
systemctl restart iscsid ; systemctl status iscsid
# connect
iscsiadm -m discovery -t sendtargets -p varServerIP 
iscsiadm -m node -l ; echo ; iscsiadm -m session
iscsiadm -m session 
# status
lsblk ;echo; lsscsi || { yyay lsscsi ; lsscsi ; }
fdisk -l ;; fdisk varDEVICE 
#
# session logout
iscsiadm -m node -T $(iscsiadm -m session | awk '{print $4}')  -u
# node del
iscsiadm -m node --logout ; iscsiadm -m node --op delete ; systemctl restart iscsid 
# reset
systemctl disable --now iscsid || systemctl disable --now target
explorer $( echo /etc/iscsi /var/lib/iscsi|pipemenu )





%%% {submenu_com}find query [find]
%%%e {submenu_com}find query [find]
# 폴더에서 검색문자열 탐색
for i in $( grep "varFIND" varPATH__@@etc/* -rlF 2>/dev/null ) ; do echo -n "$i " ;dline 40 ; grep "varFIND" $i ; echo ; done | cgrep varFIND |less -RX
# 이진 파일을 제외하고 탐색 
find varPATH__@@etc -type f ! -iregex '.*\.\(jpg\|png\|gif\|pdf\|bin\|zip\|gz\|bz2\|tgz\|zst\|exe\|mp3\|mp4|sql\)$' | while read -r i; do if file -b "$i" | grep -q 'text' && grep -q "varFIND" "$i"; then echo -n "$i "; dline 40; grep "varFIND" "$i"; echo; fi; done | cgrep varFIND | less -RX
#
vi2 varFILEPATH
# perm 000 폴더 find 
find varPATH/ -maxdepth 1 -type d -perm 000
# 하루내 수정된 파일을 찾기 /home 폴더안에 계정별 작업이 필요할때 
for i in $( cd varPATH__@@home1; ls -al |grep ^d |awk '{print $NF}' ); do find varPATH/$i -mtime -1 -type f; done 
# 하루내 수정된 파일이 있는 계정 찾기
for i in $( find varPATH__@@home1 -maxdepth 1 -mindepth 1 -type d ); do if find $i -mtime -1 -type f -print -quit | grep -q .; then echo $i; fi; done
# 특정단어포함 파일 삭제 *thumb*
!!! find varPATH -type f -name "*varFIND__thumb*" -maxdepth 1 -size 0 -exec rm -f {} \;
# expired account Lock // 특정폴더로 이동된 계정폴더를 기준 
!!! for i in $(/bin/ls -l varPATH__@@home1@@expire |awk '{print $NF}'); do passwd -l ${i%/} ; done
# 삭제된 계정 정리 // deleted account homedir cleaning
!!! cd varPATH && rm -rf `ls -al|awk '$3 ~ /^[0-9]/ {print $NF} '`
# 빈파일 빈폴더 탐색
find varPATH__@@home -type f -empty 
# 빈파일 삭제 
find varPATH__@@home -type f -empty -delete
find varPATH__@@home -type d -empty



%%% {submenu_com}mysql query [mysql]
%%%e {submenu_com}mysql query [mysql]
mysqlshow
vi2 $( find /etc/mysql/ -type f |pipemenu ) 
explorer /var/lib/mysql/
# mysql connect 
mysql varDBNAME
mysql $( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1)
# mysql process monitoring
while true;do echo;date;cat /proc/loadavg;mysqladmin processlist|egrep -v "Sleep|DELAYED";read -s -n1 -t1 key;[ "$key" ] && break;sleep 1 ;done
mysqladmin processlist|grep -v "Sleep"
# table query
mysql varDBNAME -e 'show tables;'
mysql varDBNAME -e 'varCMD ;'
mysql $( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1) -e 'varCMD ;'
# table check - myisamchk & flush tables
export db=$( mysql -Be "show databases;"|awk 'NR>1' |pipemenu1) ; export table="$( mysql $db -Be 'show tables;' |pipemenu1 )" ;; myisamchk -r /var/lib/mysql/$db/$table ; mysql $db -e 'flush tables;' ; unset db table
# db size monitor
cd /var/lib/mysql/ && ls -al
cd /var/lib/mysql/ && find ./ -size +100000k -exec ls -alh {} \; 
cd /var/lib/mysql/ && find ./ -size +20000k -exec ls -alh {} \; 
cd /var/lib/mysql/ && find ./ -size +20000k -mtime -1 -exec ls -alh {} \; 
# dump
mysqldump -Q varDBNAME > /root/varDBNAME.$(datetag1).sql ; ls -alh /root/varDBNAME.$(datetag1).sql
dbname=$( mysql -Be "show databases;"  | awk 'NR>1' | pipemenu1 ) ; mysqldump -Q $dbname > /root/$dbname.$(datetag1).sql ; ls -alh /root/$dbname.$(datetag1).sql
# dbs all dump
mkdir -p /varBackupDIR/ ; chmod 700 /varBackupDIR/ ; for i in $(mysql -Be "show databases;" | awk 'NR>1'); do echo "$i DB dumping..." ; mysqldump -Q $i | gzip > /varBackupDIR/${i}.$(datetag1).sql.gz; done ;  chmod 600 /varBackupDIR/*.sql.gz
# root
mysql -uroot -p mysql
mysql mysql
!!! mysql -e "grant all privileges on *.* to root@localhost identified by 'varPASSWORD';"
!!! mysql -e "drop database varDBNAME;"
# perm
chmod 660 /var/lib/mysql/mysql/*
chown mysql.mysql /var/lib/mysql/
chown mysql.root /var/lib/mysql/mysql
chmod 755 /var/lib/mysql
chmod 711 /var/lib/mysql/mysql
yyay mysql || yyay mariadb-server




%%% {submenu_com}fail2ban [ban]
%%%e {submenu_com}fail2ban [ban]
%% systemctl status fail2ban 2>/dev/null
# fail2ban install
yyay fail2ban
explorer /etc/fail2ban
# conf cp
cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
vi2 /etc/fail2ban/jail.local
systemctl reload fail2ban
# 
systemctl start fail2ban ; sleep 1 ; systemctl status fail2ban
systemctl enable fail2ban
systemctl stop fail2ban ; sleep 1 ; systemctl status fail2ban
systemctl disable fail2ban
#
systemctl status fail2ban
fail2ban-client status
fail2ban-client status sshd | cip
# 
iptables-save | grep f2b | cip
# ipban (manual)
fail2ban-client set sshd banip varIP
fail2ban-client set sshd unbanip varIP
# unban
fail2ban-client unban --all
# log
tail -f /var/log/fail2ban.log 
tail -f /var/log/auth.log 
tail -f /var/log/syslog 
vi /var/log/fail2ban.log
# not syslog or auth.log ( ex. proxmox )
ls -al /var/log | egrep "syslog|auth.log" 
yyay rsyslog




%%% {submenu_com}wondershaper limit net-bandwidth [band]
%%%e {submenu_com}wondershaper limit net-bandwidth [band]
%% echo "eth: $eth // ethpath: $ethpath"
# 네트워크 대역폭 제한 
# 업/다운로드로 대역폭을 풀로 다 쓰는걸 방지
git clone https://github.com/magnific0/wondershaper.git
cd wondershaper ; make ; make install
ethtool $( ip l | awk -F ': ' '/^[0-9]+:/ { print $2 }' | pipemenu ) | cgrepl "Speed:"
route
wondershaper 
###### eth select ex) eth0 ens01 // psysical device
export eth=$( ip -br a | awk '$2 ~ /UP/ {print $1}' | pipemenu ) ;; echo "eth: $eth"
# limit status
ethtool $eth | cgrepl Speed ;; wondershaper -s -a $eth | cgrep1 pfifo_fast | cgrep htb
: tc show  ; tc -s qdisc show dev $eth
: tc reset ; tc qdisc del dev $eth root
# reset && limit set down speed ( kbps )
: reset ;  wondershaper -c -a $eth
: 100mbps; wondershaper -c -a $eth ; wondershaper -a $eth -d 102400
: 70mbps ; wondershaper -c -a $eth ; wondershaper -a $eth -d 70000
: 50mbps ; wondershaper -c -a $eth ; wondershaper -a $eth -d 50000
: 30bmps ; wondershaper -c -a $eth ; wondershaper -a $eth -d 30000
# kbps -> mbps // down && up speed set 
wondershaper -c -a $eth ; wondershaper -a $eth -d $(( varDownMbps__10__50__70__100__500__1000 * 1024 )) -u $(( varUpMbps__10__50__70__100__500__1000 * 1024 ))
# speedtest
yyay speedtest-cli
speedtest-cli
( trap 'rm -f testfile.iso ; return' INT ; wget -O testfile.iso https://ftp.kaist.ac.kr/ubuntu-cd/noble/ubuntu-24.04.2-desktop-amd64.iso ; trap - INT ; ) ;; rm -f testfile.iso 
iftop 
# 50% 80% 100% down speed set 
ethpath="/sys/class/net/$( ls -1 /sys/class/net/ |grep -E 'eth|en' | pipemenu )/speed" ;; cat $ethpath
: speed 50% ; wondershaper -c -a $eth ; wondershaper -a $eth -d $(( $(cat $ethpath) * 1000 * 50 / 100 ))
: speed 80% ; wondershaper -c -a $eth ; wondershaper -a $eth -d $(( $(cat $ethpath) * 1000 * 80 / 100 ))
: speed 100%; wondershaper -c -a $eth ; wondershaper -a $eth -d $(( $(cat $ethpath) * 1000 * 100 / 100 ))




%%% {submenu_com}arp ip scan [nn]
%%%e {submenu_com}arp ip scan [nn]
%% route -n
# 네트워크 (ex. vmbr0 에 할당된 네트워크 대역) 전체를 스캔
# 대역중 사용중인 아이피 체크 
route -n | cip
route -n ;; arp-scan -I varInterFace__vmbr0 -l | hostinfo | cip
route -n ;; arp-scan -I $( route -n|awk99 |awknr3|sort|pipemenucancel ) -l | hostinfo | cip | cgrep Cisco | cgrep1 Unknown
arp
arp -n
arp-scan -I vmbr0 -l | awk '$1 ~ /^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/ {print $1}'
# nmap 
nmap $( arp-scan -I vmbr0 -l | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | pipemenu ) 
# fping -asg 192.168.0.128/25
route -n ;; fping -asg varIPrange
# reverse dokmain 
# 메일서버 운영을 위해서는 상위아이피 관리 기관에 ptr 레코드 등록 요청
# 메일서버의 ip에 ptr 도메인이 없다 -> 스팸 처리
dig -x varIP__publicip
dig -x varIP__publicip @127.0.0.1
dig -x varIP__publicip @8.8.8.8
dig -x varIP__publicip @168.126.63.1
#
nslookup varIP
host varIP
getent hosts varIP
#
yyay arp-scan
yyay nmap
yyay fping


%%% {submenu_com}sgdisk / fdisk [sgdisk]
%%%e {submenu_com}sgdisk / fdisk [sgdisk]
%% echo -n "HDD: " ; lsblk -d -n -o name | oneline
# fdisk: MBR (Master Boot Record) 
# sgdisk: GPT (GUID Partition Table)
sgdisk -p /dev/$( lsblk -d -n -o name | pipemenu )
fdisk -l /dev/$( lsblk -d -n -o name | pipemenu )
# net gpt
# !!! sgdisk -o /dev/sdb 
# new part ex) sgdisk -n=파티션번호:시작섹터:종료섹터 /dev/sdb
# !!! sgdisk -n=1:0:+10G /dev/sdb
# del part 
# !!! sgdisk -d=1 /dev/sdb
# chg type code / type list
# !!! sgdisk -t=1:EF00 /dev/sdb
sgdisk -L
# backup part table
# !!! sgdisk -b=backup.gpt /dev/sdb
# zap reset disk
# !!! sgdisk -z /dev/sdb
# load backup 
# !!! sgdisk -l=backup.gpt /dev/sdb
# sample 
!!! sgdisk -o /dev/sdx  # /dev/sdb 디스크를 GPT로 초기화
!!! sgdisk -n=1:0:+500M -t=1:EF00 -c=1:"EFI System Partition" /dev/sdx # 1번 파티션 (EFI) 생성
!!! sgdisk -n=2:0:+16G -t=2:8200 -c=2:"Swap" /dev/sdx # 2번 파티션 (Swap) 생성
!!! sgdisk -n=3:0:0 -t=3:8300 -c=3:"Root Filesystem" /dev/sdx # 3번 파티션 (Root) 생성 (남은 공간 모두 사용)
!!! sgdisk /dev/sdx # 명령줄 내용 반영 
# kernel probe part load
!!! partprobe /dev/sdx




%%% {submenu_com}swap [swap]
%%%e {submenu_com}swap [swap]
%% swapon --show 2>/dev/null || swapon -s
# 
free -h
cat /proc/swaps
swapon --show 2>/dev/null || swapon -s
vmstat 1
# on
df -h ;; dd if=/dev/zero of=varSwapPath__@@backup@@extra_swap bs=1M count=varSIZe__2048 ; chmod 600 varSwapPath
mkswap varSwapPath 
swapon varSwapPath ; swapon -s
# off
swapoff varSwapPath ; swapon -s
rm -f varSwapPath
# write
echo "varSwapPath none swap sw 0 0" >> /etc/fstab
vi2 /etc/fstab
vi2 /etc/sysctl.conf
sysctl -p
# 스왑 사용 빈도수 - 숫자 작을수록 적게 사용 (기본 60)
cat /proc/sys/vm/swappiness
sysctl vm.swappiness=varHIT__10
#
# swap {1,2,4,8}G on / off
df ; free ; echo ; cat /proc/swaps ;; size=$( echo 1024000 2048000 4096000 8192000 | pipemenu ) ;; dd if=/dev/zero bs=1024 count=$size | { pv -s ${size}k || cat ; } > varSwapPath__@@backup@@extra_swap ; mkswap varSwapPath $size ; swapon varSwapPath ; chmod 600 varSwapPath ; free ; echo ; cat /proc/swaps
# swap on -> rc.local service add
cat /proc/swaps ;; [ -f /etc/rc.local ] && echo "[ -f varSwapPath__@@backup@@extra_swap ] && swapon varSwapPath" >> /etc/rc.local && vi2 /etc/rc.local
# swap off 
free ; echo ; cat /proc/swaps ;; swapoff varSwapPath__@@backup@@extra_swap && rm -rf varSwapPath ; free ; echo ; cat /proc/swaps







%%% {submenu_com}at / cron [at]
%%%e {submenu_com}at / cron [at]
# at 확인 -> atqq func 
declare -f atqq
atqq | stripe
# at 삭제
atqq|stripe ;; atrm $( atq |while read -r l;do echo $l|awk1; done | pipemenu )
# at 모두 삭제
atqq|stripe ;; atrm $( atq |while read -r l;do echo -n $l|awk1; done )
# at 설정 
# echo "varCMD" | at 15:30
echo "varCMD" | at varTIME
# echo "varCMD" | at 15:00 this Sat
# echo "varCMD" | at 10:00 next week + Fri
# echo "varCMD" | at 16:15 2025-08-03
echo "varCMD" | at varTIME varDATE
# echo "varCMD" | at now + 2h 30m
# echo "varCMD" | at now + 3d 14:05
# echo "varCMD" | at now + 2w 16:00
echo "varCMD" | at now + varDATETIME 
# 이달말 
echo "varCMD" | at varTIME $(date -d "$(date '+%Y-%m-01') 1 month -1 day" '+%Y-%m-%d')
#
# cron -> [0-9] * / - , 를 이용하여 표현, %는 줄바꿈 특수키
# min(0-59) hour(0-23) day(1-31) month(1-12) weekand(0-7) user command
# */5 * * * * root /script/per5min.sh 5분마다 실행
# 0 0 * * 0 root /script/sunday0hour.sh 일요일 자정에 실행
#
# 30 20-22/2 * * * root /script/am10pm10.sh 10~22시까지 2시간 마다 실행
echo $(date -d "$(date +'%Y-%m-01') 1 month -1 day" '+%m-%d')
echo $(date -d "$(date +'%Y-%m-01') 1 month -2 day" '+%m-%d')
echo $(date -d "$(date +'%Y-%m-01') 2 month -1 day" '+%m-%d')
# 이달의 마지막날 10시 실행되는 스크립트 
# 0 10 27-31 * * root [ "$(date '+\%d' -d tomorrow)" == 01 ] && /script/specialday.sh 말일에 실행
echo "varMin varHour varDay varMonth varWeekand varUser__root varComPath" >> /etc/crontab ; vi2 /etc/crontab
# /root /etc 폴더 증분백업 (최저부하) / 백업본 (7*24)
echo "varMin varHour varDay varMonth varWeekand varUser__root MY_DATE=\$(date +\%w\%H) && nice -n 19 ionice -c2 -n7 rsync -ar --backup --suffix=\".bak_\$MY_DATE\" varSource__@@root varSource2__@@etc varBackupDIR__@@backup@@" >> /etc/crontab ; vi2 /etc/crontab
vi2 /etc/crontab
cal || yyay ncal




%%% {submenu_com}vim 설정 / vi alias [vi]
%%%e {submenu_com}vim setting / vi alias [vi]
# default editor set
echo $EDITOR ; echo $VISUAL
echo -e "export EDITOR=vim\nexport VISUAL=vim" >> ~/.bashrc && source ~/.bashrc # vim
echo -e "export EDITOR=nano\nexport VISUAL=nano" >> ~/.bashrc && source ~/.bashrc # nano
# .vimrc scp
scp varHOST:~/.vimrc ~/.vimrc
# vimrc template copy
vi2 $( echo ~/.vimrc /root/.bashrc |pipemenu) 
template_edit vimrc1.yml
template_view vimrc1.yml
!!! template_copy vimrc1.yml ~/.vimrc ; vi2 ~/.vimrc
template_edit vimrc2.yml
template_view vimrc2.yml
!!! template_copy vimrc2.yml ~/.vimrc ; vi2 ~/.vimrc
# vim 에서 folding 제거 zo zf 
rbackup ~/.vimrc ; perl -pi -e 's|^set foldmethod=marker|" set foldmethod=marker|g' ~/.vimrc
rbackup ~/.vimrc ; echo "set nofoldenable" >> ~/.vimrc
# 비주얼 모드 off (mouse off)
rbackup ~/.vimrc ; echo "set mouse-=a" >> ~/.vimrc ; 
# 알록달록이
[ ! "$(grep "syntax" ~/.vimrc)" ] && echo -e "syntax on\ncolorscheme default\n" >> ~/.vimrc ; 
# backup file ~/.vim/backup/file.bak
echo -e "set backup\nset backupdir=~/.vim/backup\n" >> ~/.vimrc ; mkdir -p $HOME/.vim/backup
# backup infinite ~/.vim/backup/filename/file_timestamp.bak
printf $'" 단순 백업 설정 - 파일명_날짜시간.bak 형식\nfunction! MakeBackup()\n  " 기본 백업 디렉토리 확인 및 생성\n  let l:backupdir = $HOME."/.vim/backup"\n  if !isdirectory(l:backupdir)\n    call mkdir(l:backupdir, "p")\n endif\n  \n  " 파일명과 타임스탬프를 결합한 백업 파일명 생성\n  let l:filename = expand("%%:t")\n  let l:timestamp = strftime("%%Y%%m%%d_%%H%%M%%S")\n  let l:backupfile = l:backupdir."/".l:filename."_".l:timestamp.".bak"\n \n  " 백업 파일 생성\n  execute "silent !cp " . shellescape(expand("%%:p")) . " " . shellescape(l:backupfile)\nendfunction\n\nautocmd BufWritePre * call MakeBackup()\n' >> ~/.vimrc
# 한글 encoding
echo "set fileencodings=utf8,euc-kr" >> ~/.vimrc
# 마우스 붙여 넣기 들여쓰기 방지 && f2 토글 
echo "set paste" >> ~/.vimrc
echo "set pastetoggle=<F2>" >> ~/.vimrc
# vim 종료시 vi 편집 내용 화면 그대로 남게 하기 
echo "set t_ti= t_te=" >> ~/.vimrc
# vi vim alias 
[ ! "$(grep " vi=" /root/.bashrc)" ] && echo "alias vi='vim'" >> /root/.bashrc
#
vi2 ~/.vimrc
vim -c "source ~/.vimrc" -c "q"
ls -ltr ~/.vim/backup |tail -n10
explorer ~/.vim/backup




%%% {submenu_hidden}rc.local service add [rc]
%%%e {submenu_hidden}rc.local service add [rc]
# 등록 서비스 체크
find /etc/systemd/system/ -name rc-local.service -exec echo {} \; -exec sh -c 'read x' \; -exec vi {} \;
systemctl list-unit-files --type=service | grep rc-local
systemctl cat rc-local.service
# 서비스 등록 #!/bin/bash 로 시작
echo "#!/bin/bash" >> /etc/rc.local
vi2 /etc/rc.local ; chmod +x /etc/rc.local ; 
# 
[ ! -f /etc/systemd/system/rc-local.service ] && touch /etc/systemd/system/rc-local.service
echo -e "[Unit]\nDescription=/etc/rc.local Compatibility\nDocumentation=man:systemd-rc-local-generator(8)\nConditionFileIsExecutable=/etc/rc.local\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=5min\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target" | tee /etc/systemd/system/rc-local.service ; vi2 /etc/systemd/system/rc-local.service
#
vi2 /etc/systemd/system/rc-local.service
#
systemctl enable --now rc-local.service ;;  systemctl status rc-local.service
systemctl restart rc-local.service ;; systemctl status rc-local.service
systemctl status rc-local.service
bash /etc/rc.local ; df -h
explorer /etc/systemd/system
#




%%% ssh connect / id_rsa [s]
%%%e ssh connect / id_rsa [s]
ssh varHOST -p varPORT__22
ssh varHOST -p varPORT__22 "varCMD" 
assh varHOST varID__root "varPW" 
sshpass -p 'varPW' ssh -o StrictHostKeyChecking=no 'varID__root'@varHOST 
# ssh // sshd 환경파일 수정 
vi2 $(ls -1 /root/.ssh/config /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /etc/openssh/sshd_config /etc/ssh/sshd_config 2>/dev/null |pipemenu1)
# 원격지 파일/폴더 select no. scp download
scp -r -P varPORT__22 varHOST:varRPATH__@@root/$(ssh varHOST -p varPORT__22 "ls -1 varRPATH__@@root"|pipemenu) varLocalPATH__.
# 개인키 / 공개키 
rbackup /root/.ssh/id_rsa /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys 
!!! scp varHOST:/root/.ssh/id_rsa.pub /root/.ssh/ 
!!! scp varHOST:/root/.ssh/id_rsa /root/.ssh/ 
!!! ssh-keygen -t rsa -b 2048 -f /root/.ssh/id_rsa
# 로컬 공개키 대상 서버에 복사 // 로컬에서 원격지로 키로그인
!!! ssh-copy-id varHOST
!!! ssh-copy-id -p varPORT__22 -i $( find /root/.ssh -name "*.pub"|pipemenu1) varHOST
!!! cat /root/.ssh/id_rsa.pub | ssh varHOST "cat >> /root/.ssh/authorized_keys"
# 원격지 공개키 현재 서버에 복사 // 원격지에서 로컬로 키로그인
!!! ssh varHOST "cat .ssh/id_rsa.pub" | tee -a /root/.ssh/authorized_keys
# 원격지 공개키 저장소 로컬 동기화 // 원격지 키로그인 가능한 게스트는 이서버도 가능
!!! scp varHOST:/root/.ssh/authorized_keys /root/.ssh/ 
#
# old server
ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -oHostKeyAlgorithms=ssh-rsa,ssh-dss varHOST
# kex server side
echo -e "KexAlgorithms +diffie-hellman-group1-sha1 \nHostKeyAlgorithms +ssh-rsa,ssh-dss \nPubkeyAcceptedKeyTypes=+ssh-rsa \nPubkeyAcceptedAlgorithms=+ssh-rsa" >> /etc/ssh/sshd_config ; vi2 /etc/ssh/sshd_config
# ssh from utf8-client to euc-kr-server ( encoding chg )
luit -encoding euc-kr ssh varHOST || yyay luit
#
ssh -v varHOST -p varPORT__22
sshd -T |grep rsa 
systemctl restart sshd || systemctl restart ssh 
# client ssh - auto handshake 
sshre varHOST
vi2 ~/.ssh/config
#
declare -f sshre 
yyay sshpass expect 




%%% screen [x] / tmux (xx)
%%%e screen [x] / tmux (xx)
%% screen -ls|grep tach
screen -ls
screen -ls ;; screen -S varA
# multi mode / all -x / -rd (detach & retach)
screen -ls ;; screen -x $( screen -ls |grep tach |pipemenu1 )
screen -ls ;;  for i in $( screen -ls |grep tach |awk1 ) ;do echo $i ; sleep 1 ; screen -x $i ; done
screen -ls ;; screen -rd varA
# 프로그램이나 스크립트 screen 으로 실행 
screen -dmS $(basename varCommandPATH) sh -c 'varCommandPATH' 
screen -S $(basename varCommandPATH) sh -c 'varCommandPATH;/bin/bash' 
# screen dump
screen -ls ;; screen -S $( screen -ls |grep tach |pipemenu1 ) -X hardcopy -h /root/_screendump && cat /root/_screendump |cpipe|less -RX +G && rm -f /root/_screendump
# screen dump all
for i in $( screen -ls|grep tach|awk '{print $1}' ) ;do echo "$i ===========================" && screen -S $i -X hardcopy -h /root/_screendump && tail -n100 /root/_screendump | cpipe && echo -n "=== end of $i [Enter] " && read x ; done ; rm -rf /root/_screendump 
# screen quit
!!! screen -ls ;; screen -S $( screen -ls |grep tach |pipemenu1cancel ) -X quit ; screen -ls 
# monitor 
c=('top' 'iftop' 'sh -c "pstree; exec bash"'); s(){ screen "$@"; }; s -dmS m ${c[0]}; for x in "${c[@]:1}"; do s -S m -X screen; s -S m -X stuff "${x}\n"; done; s -r m
# command to screen // & dump 
screen -ls ;; screen -S varA -X stuff "varCommand$(printf \\\\r)"
screen -ls ;; sno=$( screen -ls |grep tach |pipemenu1 ) ;; screen -S $sno -X stuff "varCommand$(printf \\\\r)" ;; screen -S $sno -X hardcopy -h /root/_screendump && cat /root/_screendump |cpipe && rm -f /root/_screendump
# detach 제거
!!! for i in $( screen -ls|grep detach|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ; screen -ls
# attach / detach 모두 제거
!!! for i in $( screen -ls|grep tach|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ; screen -ls
# 검색 문자열 screen 제거
!!! screen -ls ;; for i in $( screen -ls|grep tach|grep varA|awk '{print $1}' ) ;do screen -S $i -p 0 -X quit; done ;screen -ls






yyay fuse ; [ ! $( which fusermount3) ] && ln -s /usr/bin/fusermount /usr/bin/fusermount3





%%% {submenu_com}teldrive daemon [tel]
%%%e {submenu_com}teldrive daemon [tel]
%% echo "tg-uploads-encryption-key: ${tguploadsencryptionkey}"
%% echo "tg-jwtsecret: ${jwtsecret}"
%% echo "tg-app-id: ${telegramappid}"
%% echo "tg-app-hash: ${telegramapphash}"
%% echo "webport: $webport dbinfo: teldbuser=$teldrive teldbpw=$teldbpw teldbhost=$teldbhost teldbname=$teldbhost"
# telegrem drive docker -> dkt [Enter]
# telegram api app_id, app_hash
# https://my.telegram.org/auth?to=myapp
echo "tguploadsencryptionkey=$(openssl rand -hex 32)" >> ~/go.private.env
echo "jwtsecret=$(openssl rand -hex 32)" >> ~/go.private.env
echo "telegramappid=varAppID" >> ~/go.private.env
echo "telegramapphash=varAppHash" >> ~/go.private.env
source ~/go.private.env
# DB 필요 -> pgsql 직접 설치 psql [Enter]
# or Free BaaS 500M https://supabase.com/database
# /usr/local/bin/teldrive
ay fuse3 ; curl -sSL instl.vercel.app/teldrive | bash ; teldrive version
# user create
groupadd --system teldrive ; useradd --system -g teldrive -s /bin/false -d /var/lib/teldrive teldrive
mkdir -p /var/cache/teldrive && chown -R teldrive:teldrive /var/cache/teldrive 
mkdir /mnt/teldrive && chown teldrive:teldrive /mnt/teldrive
# auth
export webport="varPort__8080" ; teldbuser="varDBUser__teldrive" ; export teldbpw="varDBpw" ; export teldbhost="varDBHost__localhost" ; export teldbname="varDBName__teldrive"
# exec && trouble check
sudo -u teldrive teldrive run --tg-app-id "$telegramappid" --tg-app-hash "$telegramapphash" --jwt-secret "$jwtsecret" --tg-uploads-encryption-key "$tguploadsencryptionkey" --db-data-source "postgresql://$teldbuser:"$teldbpw"@$teldbhost:5432/$teldbname?sslmode=disable"
# systemd add
template_edit teldrive.service
template_view teldrive.service
!!! template_copy teldrive.service /etc/systemd/system/teldrive.service ;; chmod 640 $lastarg 
vi2 /etc/systemd/system/teldrive.service ; ls -al /etc/systemd/system/teldrive.service
systemctl daemon-reload
systemctl restart teldrive.service ;; systemctl status teldrive.service ;;
systemctl enable --now teldrive.service ;; systemctl status teldrive.service ;;
# http://$publicip:$webport
nmap localhost
# 봇 토큰 추가 (Teldrive 웹) 업로드/다운로드 속도를 위해 7-8개의 봇 토큰
ufw allow varPort__8080__80

#trash
#vi2 /var/lib/teldrive/.config/teldrive/config.json
#mkdir -p /var/lib/teldrive/.config/teldrive && chown -R teldrive:teldrive /var/lib/teldrive
#export config="/var/lib/teldrive/.config/teldrive/config.json" ; touch $config && chown -R teldrive:teldrive $config && chmod 640 $config



%%% {submenu_com}teldrive-rclone fork [telr]
%%%e {submenu_com}teldrive-rclone fork [telr]
%% echo "rcloud:$rcloud // rcloudroot:$rcloudroot"
# rclone fork - teldrive 가 정식 cloud drive 가 아니라 rclone 포함 힘들듯
# https://github.com/tgdrive/rclone/releases
wget -O rclone.deb https://github.com/tgdrive/rclone/releases/download/v1.69.1/rclone-v1.69.1-linux-amd64.deb 
apt install ./rclone.deb
dpkg -L rclone | cgrep1 /bin
rclone version
ay fuse3
# config Teldrive WebUI ->‘DevTools(f12) -> Application -> cookie -> access-token (copy)
# api host -> http://localhost:8080
rclone config
mkdir -p /mnt/teldrive ;; ls -al /mnt/teldrive
cat /root/.config/rclone/rclone.conf | cgrep1 teldrive
vi2 /root/.config/rclone/rclone.conf
export rcloud=$(cat /root/.config/rclone/rclone.conf |grep '^\['| awk -F'\\]|\\[' '{print $2}' | pipemenu) ;; export rcloudroot="$(rclone lsd $rcloud:/ | awk '{$1=$2=$3=$4=""; print $0}')" ; echo "$rcloudroot"
# mount
# mount point /mnt/teldrive 에는 아무런 파일이나 폴더가 들어가 있으면 안된다.
nohup rclone mount varRemote__teldrive:/ /mnt/teldrive --daemon --vfs-cache-mode writes & ;; sleep 1 ;  df -h | cgrep1 teldrive &
df -h | cgrep1 teldrive | cgrep /mnt/
# umount
fusermount -u /mnt/teldrive
for i in $( df|awk99|grep mnt ) ; do fusermount -u $i ; done ;; df | cgrep /mnt




%%% {submenu_com}postgresql [psql]
%%%e {submenu_com}postgresql [psql]
%% echo "postgresqlconf:$postgresqlconf pg_hbaconf:$pg_hbaconf"
# install
yyay postgresql postgresql-contrib lsb_release 
systemctl status postgresql
sudo -i -u postgres
psql --version
# pgroonga (need for teldrive)
ay software-properties-common ; add-apt-repository -y universe ; add-apt-repository -y ppa:groonga/ppa ; apt update
# Ubuntu 22.04->14 // 24.04 ->16
ay -V varOS__postgresql-14-pgroonga__postgresql-16-pgroonga
# root pw chg
sudo -u postgres psql -c "ALTER USER postgres WITH PASSWORD 'varDBPW';"
sudo -u postgres psql
# db create
sudo -u postgres psql -c "CREATE USER varDBUser WITH PASSWORD 'varDBPw';"
sudo -u postgres psql -c "CREATE DATABASE varDBName OWNER varDBUser;"
sudo -u postgres psql -c "ALTER DATABASE varDBName OWNER TO varDBUser;"
sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE varDBName TO varDBUser;"
# pgroonga ext set 
sudo -u postgres psql teldrive -c "CREATE EXTENSION IF NOT EXISTS pgroonga;"
# db pw chg
sudo -u postgres psql -c "ALTER USER varDBUser WITH PASSWORD 'varDBPw';"
# allow 0.0.0.0
export postgresqlconf="$(sudo -u postgres psql -c "SHOW config_file;"|grep "/etc/")"
vi2 $postgresqlconf
change $postgresqlconf "#listen_addresses" "listen_addresses = '*'" line
# allow 0.0.0.0 db
export pg_hbaconf="$(sudo -u postgres psql -c "SHOW hba_file;"|grep "/etc")"
vi2 $pg_hbaconf
echo "host    varDBName    varDBUser    0.0.0.0/0            scram-sha-256" | insert $pg_hbaconf "IPv4 local connections"
# firewall add
ufw status
ufw allow 5432/tcp comment 'Allow PostgreSQL access'
#
systemctl restart postgresql 
systemctl status postgresql




%%% {submenu_com}rclone mount [cc]
%%%e {submenu_com}rclone mount [cc]
%% df | grep /mnt | cdir
curl https://rclone.org/install.sh | bash ;; rclone --version
rclone config
# cloud token config 가 Rhost 에 있다면 copy
mkdir -p /root/.config/rclone/ ; scp varHOST:/root/.config/rclone/rclone.conf /root/.config/rclone/ ; vi2 /root/.config/rclone/rclone.conf
mkdir -p /tmp/rclone/Cache /tmp/rclone/Log ; chmod 700 /tmp/rclone ; ls -al /tmp/rclone
vi2 /root/.config/rclone/rclone.conf
yyay fuse3
# var export 
echo "CLOUD='varCLOUD__gdrive' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__gdrive_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
echo "CLOUD='varCLOUD__gcp' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__gcp_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
echo "CLOUD='varCLOUD__onedrive' ; RMOUNT='varRdir__rclone_share' ; LMOUNT='varLdir__onedrive_mount' ; LTMP='/tmp/rclone'" > /tmp/rclone/var.conf
cat /tmp/rclone/var.conf
# after var export // import env && rclone { mkdir,copy,ls } test
# 아래 명령시 에러가 나지 않을경우 마운트가 가능
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone mkdir $CLOUD:$RMOUNT 
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone copy /root/.config/rclone/rclone.conf $CLOUD:$RMOUNT 
. /tmp/rclone/var.conf ; mkdir -p /mnt/$LMOUNT ; rclone lsd $CLOUD: ; rclone ls $CLOUD:$RMOUNT
# rclone mount ( script 종료후에도 마운트 유지 nohup ) 
. /tmp/rclone/var.conf ; nohup rclone mount $CLOUD:$RMOUNT /mnt/$LMOUNT --config /root/.config/rclone/rclone.conf --daemon --allow-other --allow-non-empty --fast-list --drive-skip-gdocs --poll-interval=15s --vfs-cache-mode full --vfs-write-back 5s --bwlimit-file 16M --buffer-size=16M --vfs-read-chunk-size=32M --vfs-read-chunk-size-limit 2048M --vfs-cache-max-size 10G --vfs-cache-max-age 336h --vfs-read-ahead 32M --dir-cache-time=1000h --log-level INFO --log-file $LTMP/Log/rclone.log --cache-dir=$LTMP/Cache --timeout 1h --umask 000 &>/dev/null & sleep 2  ; df | grep /mnt | cdir
tail -n100 $LTMP/Log/rclone.log
# rc.local 에 추가
cat /tmp/rclone/var.conf >> /etc/rc.local ; echo -e "mkdir -p /tmp/rclone/Cache /tmp/rclone/Log ; chmod 700 /tmp/rclone\nmkdir -p /mnt/$LMOUNT ; rclone mkdir $CLOUD:$RMOUNT\nrclone mount $CLOUD:$RMOUNT /mnt/$LMOUNT --config /root/.config/rclone/rclone.conf --daemon --allow-other --allow-non-empty --fast-list --drive-skip-gdocs --poll-interval=15s --vfs-cache-mode full --vfs-write-back 5s --bwlimit-file 16M --buffer-size=16M --vfs-read-chunk-size=32M --vfs-read-chunk-size-limit 2048M --vfs-cache-max-size 10G --vfs-cache-max-age 336h --vfs-read-ahead 32M --dir-cache-time=1000h --log-level INFO --log-file $LTMP/Log/rclone.log --cache-dir=$LTMP/Cache --timeout 1h --umask 000 " >> /etc/rc.local
vi2 /etc/rc.local
#
# unmount // explorer // update
df ;; . /tmp/rclone/var.conf ; umount /mnt/$LMOUNT
explorer /mnt/$LMOUNT
rclone selfupdate --stable




%%% {submenu_com}rclone direct command [rclone]
%%%e {submenu_com}rclone direct command [rclone]
# 폴더를 마운트 하여 작업할경우 임시폴더에 이동후 작업
# 직접 명령으로 임시폴더를 거치지 않고 네트웍 전송
%% echo "rcloud: $rcloud"
rclone config
export rcloud=$(cat /root/.config/rclone/rclone.conf |grep '^\['| awk -F'\\]|\\[' '{print $2}' | pipemenu) ;; export rcloudroot="$(rclone lsd $rcloud:/ | awk '{$1=$2=$3=$4=""; print $0}')" ; echo "$rcloudroot"
# varDIR ls -d
rclone lsd $rcloud:varDIR__@@
# varDIR ls
rclone ls $rcloud:varDIR
# varDIR ls -l
rclone lsl $rcloud:varDIR
# varDIR 트리뷰
rclone lsf $rcloud:varDIR
# varDIR 새폴더 생성
rclone mkdir $rcloud:varNewDIR
# varDIR 빈폴더 삭제 
rclone rmdir $rcloud:varEmptyDIR
# varDIR 폴더내 파일 삭제
rclone delete $rcloud:varDIR
# varDIR 폴더 전체삭제
rclone purge $rcloud:varDIR
# varDIR 복사
rclone copy varPATH $rcloud:varDIR ; push
# varDIR 동기화
rclone sync varPATH $rcloud:varDIR ; push
# mount
mkdir -p $HOME/$rcloud.tmpmount ; rclone mount $rcloud:/ $HOME/$rcloud.tmpmount & ;; cd $rcloud.tmpmount ; ls -al ; readx ; explorer $HOME/$rcloud.tmpmount
# umount 
fuser -km $HOME/$rcloud.tmpmount ;; umount $HOME/$rcloud.tmpmount



%%% {submenu_com}rclone serve [rclones]
%%%e {submenu_com}rclone serve [rclones]
%% echo "sharefoler: $sharefoler"
# rclone 을 이용하여 파일서버 구축
# rclone 이 설치된 곳의 폴더나 rclone.conf 에 정의된 클라우드를 ftp 같은 서버로 만듬
cat /root/.config/rclone/rclone.conf | cgrep1 "\[.*\]"
# 내 폴더를 serve 할때 web:8080 // web:8081
export sharefoler=varSharePath__@@mnt@@share ;; mkdir -p $sharefoler
nohup rclone serve http $sharefoler --addr :varPort__8080 --log-level INFO &
# web 인증 설정 ( auth web // auth webdav )
htpasswd -Bcb $sharefoler/.htpasswd varID varPW ;; cat $sharefoler/.htpasswd | cgrep1 varID
nohup rclone serve http $sharefoler --addr :varPort__8080  --htpasswd $sharefoler/.htpasswd --log-level INFO &
nohup rclone serve webdav $sharefoler --addr :varPort__8081 --htpasswd $sharefoler/.htpasswd --log-level INFO &
nohup rclone serve dlna $sharefoler --addr :varPort__8082 --log-level INFO &
nohup rclone serve ftp $sharefoler --addr :varPort__2121 --user varID --pass varPW --log-level INFO &
nohup rclone serve sftp $sharefoler --addr :varPort__2222 --user varID --pass varPW --log-level INFO &
# script 종료 되도 서비스 유지 ( screen 사용법 -> x [Enter] )
screen -dmS "rclone.serve.web" nohup rclone serve http $sharefoler --addr :varPort__8080  --htpasswd $sharefoler/.htpasswd --log-level INFO &
screen -dmS "rclone.serve.web" sh -c 'nohup rclone serve http $sharefoler --addr :varPort__8080  --htpasswd $sharefoler/.htpasswd --log-level INFO &'
screen -dmS "rclone.serve.webdav" nohup rclone serve webdav $sharefoler --addr :varPort__8081 --htpasswd $sharefoler/.htpasswd --log-level INFO 
screen -dmS "rclone.serve.dlna" nohup rclone serve dlna $sharefoler --addr :varPort__8082 --log-level INFO 
screen -dmS "rclone.serve.ftp" nohup rclone serve ftp $sharefoler --addr :varPort__2121 --user varID --pass varPW --log-level INFO 
screen -dmS "rclone.serve.sftp" nohup rclone serve sftp $sharefoler --addr :varPort__2222 --user varID --pass varPW --log-level INFO 
# 
echo "$(hostname -f):varPort"
nmap localhost
ufw allow varPort
ay screen
# stop
pgrep -af "screen" ;; screen -l
pgrep -af "rclone serve"
kill -9 $(pgrep -af "rclone serve" |awk1)

%%% {submenu_com}tmux [xx]
%%%e {submenu_com}tmux [xx]
# prefix key ctrl-b ( screen -> ctrl-a )
tmux -u 
# tmux 한글깨짐 utf8 set 
echo -e "alias tmux='tmux -u'" >> $HOME/.bashrc
tmux ls
tmux attach 
tmux attach -t $( tmux ls|awk -F: '{print $1}' | pipemenu ) 
tmux kill-session 
tmux kill-session -t $( tmux ls|awk -F: '{print $1}' | pipemenu ) 
tmux kill-server
tmux new-session -u -d 'bashtop' \; new-window 'top' \; new-window 'iftop' \; new-window 'sh -c "pstree; exec bash"'; tmux attach
# 새로운 윈도우 생성: Ctrl-b c (create)
# 다음 윈도우로 이동: Ctrl-b n (next)
# 이전 윈도우로 이동: Ctrl-b p (prev)
# 세로 분할: Ctrl-b %
# 가로 분할: Ctrl-b "
# 패널 이동: Ctrl-b 방향키
# 패널 크기 조절: Ctrl-b Ctrl-방향키
# 스크롤 모드: Ctrl-b [
# 스크롤 모드 종료: q
# 탈출 (detach)하여 현재 세션 종료: Ctrl-b d
#
# install
yyay tmux



# 변수 재사용 5초 타임아웃 
[ -z "$vmslistoutput" ] || (( $(date +%s) - ${vmslistoutput:0:10} >= 5 )) && export vmslistoutput="$(date +%s)$(vmslistview)"; echo ${vmslistoutput:10}



%%% {submenu_virt}proxmox - manage vms [px]
%%%e {submenu_virt}proxmox - manage vms [px]
%% vmslistview|cgrep3136 running
: Local Node Name; echo "* Local Node: $(basename "$(readlink /etc/pve/local 2>/dev/null)" 2>/dev/null)"
{ pct list ;echo; qm list ; } | cgrep1 running
vmslist | cgrep stopped | cgrep1 running
: pct Start/Stop; pct list | cgrepline running ;; for i in varPCTIDs ; do pct varMode__enter__start__stop__reboot__config__unlock $i ; done ;; vmslist | cgrep stopped | cgrep1 running
: qm Start/Stop ; qm list | cgrepline running ;; for i in varVMIDs ; do qm varMode__start__stop__reset__status__config__unlock $i ; done ;; vmslist | cgrep stopped | cgrep1 running
# pct / qemu enter (ssh)
: pct  enter; pct list |cgrepline running ;; pct enter $( pct list | pipemenu1 ) 
: qemu enter; qm list| cgrepline running ;; qssh varVMID varSshID__root
# stop all
pvenode stopall --timeout varTimeOut__180__120__60
# start all ( ex. pvenode startall --vms 100,101,102 --force )
pvenode startall --vms varVMSnospace --force
# vm ip scan func (running)
: ip scan - Running qemu vms - arp-scan ; vmipscan varIFace__vmbr0
: onboot autoStart pct check; pct list | awk '{print $1}' | tail -n +2 | while read ctid; do echo "CT $ctid: $(pct config $ctid | grep onboot)"; done
: onboot autoStart qm  check; qm list | awk '{print $1}' | tail -n +2 | while read vmid; do echo "VM $vmid: $(qm config $vmid | grep onboot)"; done
# proxmox boot -> vm autostart on(1)/off(0)
qm set varVMID --onboot varSET__0__1 
pct set varVMID --onboot varSET__0__1 
# proxmox api - pvesh
pvesh get $( echo cluster/resources cluster/status /nodes /storage | pipemenu )
explorer /etc/pve/


#trash
: qemu ssh ;vmslist | grep qemu | cgrepline running ;; qmip=$( qm agent varVMID network-get-interfaces | gipa | grep -v "127.0.0.1" ); [ "$qmip" ] && ssh root@$qmip




%%% {submenu_virt}proxmox - storage [pxx]
%%%e {submenu_virt}proxmox - storage [pxx]
%% vmslistview|cgrep3136 running
# storage
pvesm status | cgrep1 lvmthin | hl -h
pvesm list $( pvesm status |awk1 |awknr2 |pipemenu )
pvesm scan ;; pvesm scan varA
# trim ( thin-volume diet ) - 운영 vm 들의 root 로 실행
fstrim -a -v
# lvs vm size check
lvs --units g -o lv_name,data_percent | awk '$1 ~ /^vm-/{printf "Estimated used size of LV '\''%s'\'': %.2fGiB\n", $1, ($2 * 10) / 100}'
# mount/unmount - vm pct
pvesm status ; lvs ;; qm set varVMID $( echo -scsi0 -scsi1 -sata0 -sata1 -ide0 -ide1 |pipemenu) varSTGName:varLVName
pvesm status ; lvs ;; qm set varVMID $( echo -scsi0 -scsi1 -sata0 -sata1 -ide0 -ide1 |pipemenu) none
pvesm status ; lvs ;; pct set varVMID $( echo -mp0 -mp1 -mp2 |pipemenu) varSTGName:varLVName,mp=/mnt/disk1
pvesm status ; lvs ;; pct set varVMID $( echo -mp0 -mp1 -mp2 |pipemenu) none
# qm importdisk <vmid> /var/lib/vz/images/your-image.qcow2 local-lvm
pvesm status ; lvs ;; qm importdisk varVMID varQCowPATH varSTGName
# list of storage ( backup / image ) 
pvesh get /storage -output-format=yaml |cgrep backup |cgrep1 storage 
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage'
explorer /etc/pve/
# proxmox api - pvesh
pvesh get $( echo cluster/resources cluster/status /nodes /storage | pipemenu )
# template iso/img list
find /var/lib/vz/template/


#trash
# thin-pool 사용량 체크 (vm 이 사용할 수 있는 thin 전체 용량)
(echo "LV LSize Data% Meta% Used(G) Free(G)"; lvs --units g -o lv_name,lv_size,data_percent,metadata_percent --select 'segtype="thin-pool"' --noheadings | awk '{print $1, $2, $3, $4, ($2 * $3 / 100) "G", ($2 - ($2 * $3 / 100)) "G"}') | column -t

%%% {submenu_virt}proxmox - cluster/node [pxc]
%%%e {submenu_virt}proxmox - cluster/node [pxc]
%% vmslistview|cgrep3136 running
# cluster
pvecm $( echo status nodes | pipemenu ) 
# cluster 하나가 shutdown 되었을때, lock 해제 투표수조정 
!!! pvecm expected 1 
# cluster 동기화 서버 없고, cluster 간헐적 운영시 quorum 섹션 주석처리   
!!! vi2 /etc/corosync/corosync.conf ; systemctl restart corosync
# !!! cluster node etc backup / delete
rbackup varBDIR__@@backup/etc_daily.tgz ; tar cvzf varBDIR__@@backup/etc_daily.tgz /etc/ ; ls -al /backup/etc_daily.*
!!! pvecm delnode varNodename ; ls -al /etc/pve/nodes ; rm -r /etc/pve/nodes/varNodename
systemctl restart pve-cluster
# list of nodes
pvesh get /nodes --output-format json | jq -r '.[].node'
# vmID -> node name check 
find /etc/pve/nodes/*/{qemu-server,lxc} -name 'varVMID'.conf | awk -F/ '{print $5}'
# pveproxy webui restart 
systemctl restart pveproxy ; systemctl status pveproxy 
systemctl status pveproxy 
explorer /etc/pve/
# proxmox api - pvesh
pvesh get $( echo cluster/resources cluster/status /nodes /storage | pipemenu )







%%% {submenu_virt}proxmox-web ssl-set [pvssl]
%%%e {submenu_virt}proxmox-web ssl-set [pvssl]
%% echo "myemail: $myemail mydomain: $mydomain"
# after - publicip & domain set
# 
hostname -f 
# stop temporary :80 port web-service 
netstat -tulnp | grep :80
# email / doamin set
echo "myemail=varEmail" | tee -a ~/go.private
echo "mydomain=varDomain" | tee -a ~/go.private
# 0: Production mode 
pvenode acme account register default $myemail
pvenode acme account register default varEmail
vi2 /etc/pve/priv/acme/default
# domain set
hostname -f ;; pvenode config set --acme domains=$mydomain
hostname -f ;; pvenode config set --acme domains=varDomain
# cert order - port 80 use
pvenode acme cert order
pvenode acme cert order --force
# pveproxy restart
systemctl restart pveproxy
# renew force
pvenode acme cert renew --force
#
pvenode acme account list
pvenode cert info
!!! pvenode acme cert revoke
pvenode help | less -RX



%%% {submenu_virt}proxmox log / fail2ban [pxl]
%%%e {submenu_virt}proxmox log / fail2ban [pxl]
# access log
cat /var/log/pveproxy/access.log | cpipe | less -RX +G
# auth log
journalctl -u pvedaemon --no-pager | grep "authentication" | cpipe | less -RX +G
# common log 
journalctl -u pveproxy -rx
#
# fail2ban
template_view fail2ban_filter_proxmox.conf
!!! template_copy fail2ban_filter_proxmox.conf /etc/fail2ban/filter.d/proxmox.conf
vi2 /etc/fail2ban/filter.d/proxmox.conf
#
template_view fail2ban_jail_proxmox.conf
!!! template_copy fail2ban_jail_proxmox.conf /etc/fail2ban/jail.d/proxmox.conf
vi2 /etc/fail2ban/jail.d/proxmox.conf
#
systemctl reload fail2ban
systemctl status fail2ban
fail2ban-client status
fail2ban-client status proxmox
# file
explorer /etc/fail2ban/filter.d/
explorer /etc/fail2ban/jail.d/




%%% {submenu_virt}proxmox vm dump / backup [pxdump]
%%%e {submenu_virt}proxmox vm dump / backup [pxdump]
%% vmslistview|cgrep3136 running
{ pct list ; qm list ; } | cgrepline running 
# dump selects ex) vzdump 100 101
vzdump varVMIDs --mode snapshot --storage $( pvesh get /storage -output-format=json | jq -r --arg node "$(basename "$(readlink /etc/pve/local)")" '.[] | select( (.nodes == $node) and (.type == "dir") and (.content | contains("backup"))) | .storage' | pipemenu storage ) --compress zstd --notes-template '{{guestname}}' --remove 0 ; bell
# dump running vms
vms="$( { pct list ; qm list ; } | grep running | awk1 | oneline )" ; echo "Dump vms: $vms" ; readx ; vzdump $vms --mode snapshot --storage $( pvesh get /storage -output-format=json | jq -r --arg node "$(basename "$(readlink /etc/pve/local)")" '.[] | select( (.nodes == $node) and (.type == "dir") and (.content | contains("backup"))) | .storage' | pipemenu storage ) --compress zstd --notes-template '{{guestname}}' --remove 0 ; bell
# dump all
vzdump --all   --mode snapshot --storage $(pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'| pipemenu storage ) --compress zstd --remove 0 ; bell
# proxmox etc daily backup -> cronadd
mkdir -p varEtcBackupPATH__@@mnt@@pve@@onedrive@@etc ; echo "59 23 * * * root /bin/bash -c 'tar -cvzf varEtcBackupPATH__@@mnt@@pve@@onedrive@@etc/pve-config-backup.\$(hostname).\$(date +\%Y\%m\%d).tar.gz /var/lib/pve-cluster/config.db /etc/pve > /dev/null 2>&1'" >> /etc/crontab ; vi2 /etc/crontab
# all node storage check
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'
# local node storage check
pvesh get /storage -output-format=json | jq -r --arg node "$(basename "$(readlink /etc/pve/local)")" '.[] | select( (.nodes == $node) and (.type == "dir") and (.content | contains("backup"))) | .storage'




# chg
vzdump varVMIDs --mode snapshot --storage $(pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'| pipemenu storage ) --compress zstd --notes-template '{{guestname}}' --remove 0 ; bell
vms="$( { pct list ; qm list ; } | grep running | awk1 | oneline )" ; echo "Dump vms: $vms" ; readx ; vzdump $vms --mode snapshot --storage $(pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("backup")) .storage'| pipemenu storage ) --compress zstd --notes-template '{{guestname}}' --remove 0 ; bell




%%% {submenu_virt}proxmox snapshot [snap]
%%%e {submenu_virt}proxmox snapshot [snap]
%% vmslistview|cgrep3136 running
# 설치를 하거나 무언가 서버에 조작이 필요할때는 사전에 필히 스냅샷을 찍어둔다.
# 서버에 자원 부하가 적기 때문에 자주해도 부담이 없다.
# 너의 시간과 고생을 아껴줄 것이다. 
pct list ;echo; qm list
# snapshot
pct list | cgrep1 running ;; pct snapshot varPCTID varPCTName__adatetag2 
qm list | cgrep1 running ;; qm snapshot varVMID varVMName__adatetag2
# running vms -> autosnapshot
: pct ; for i in $( pct list | grep running | awk1 ) ; do echo "$i >>> " ; pct snapshot $i daily_auto_$(datetag2) ; done
: qm  ; for i in $( qm list  | grep running | awk1 ) ; do echo "$i >>> " ; qm snapshot $i daily_auto_$(datetag2) ; done
: all ; for i in $( pct list | grep running | awk1 ) ; do echo "$i >>> " ; pct snapshot $i daily_auto_$(datetag2) ; done ; for i in $( qm list | grep running | awk1 ) ; do echo "$i >>> " ; qm snapshot $i daily_auto_$(datetag2) ; done
# list
pct listsnapshot varPCTID
qm listsnapshot varVMID
# rollback
pct list | awk1c ;; pct listsnapshot varPCTID | awk2c ;; pct rollback varPCTID varPCTName ;; pct start varPCTID
qm list | awk1c ;; qm listsnapshot varVMID | awk2c ;; qm rollback varVMID varVMName ;; qm start varVMID
# delete
pct delsnapshot varPCTID varPCTName 
qm delsnapshot varVMID varVMName 




%%% {submenu_virt}proxmox gpu passthrough - intel [pxg]
%%%e {submenu_virt}proxmox gpu passthrough - intel [pxg]
# 공사중
# intel n100 기준 모든 vm 에서 vGPU 사용(igpu) 
# BIOS/UEFI에서 IOMMU (VT-d) 활성화 // secure boot off
# grub 에서 선택적인 gpu 할당(hostos or vm) // hostos fix
vi2 /etc/default/grub
sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT=.*/#&\nGRUB_CMDLINE_LINUX_DEFAULT="quiet intel_iommu=on iommu=pt"/' /etc/default/grub
#
# select gpu ( hostos // vm )
vi2 /etc/grub.d/40_custom
#
explorer /etc/grub.d/
#
!!! update-grub
!!! reboot
# SR-IOV (Single Root I/O Virtualization) vGPU
# https://gall.dcinside.com/mgallery/board/view/?id=svr&no=12618
yyay pve-headers-$(uname -r) intel-gvt-dkms firmware-ipu6 build-* sysfsutils
vi2 /etc/modules
vi2 /etc/modprobe.d/blacklist.conf
echo "vfio\nvfio_iommu_type1\nvfio_pci\nvfio_virqfd" | tee -a /etc/modules
echo "blacklist i915" | tee -a /etc/modprobe.d/blacklist.conf
# vga / audio vender id check 
vi2 /etc/modprobe.d/vfio.conf
lspci -nn | cgrep1 VGA | cgrep Audio
# lscpi -> [8086:????] 형태의 intel vender 장치ID varVGA (참조 amd vender 1002)
echo "options vfio-pci ids=varVGA" >> /etc/modprobe.d/vfio.conf
echo "options vfio-pci disable_idle_d3=1" >> /etc/modprobe.d/vfio.conf
!!! update-initramfs -u
!!! reboot
# gpu check
dmesg | grep IOMMU
ls /dev/dri | cgrep1 renderD128
lspci -nnk | cgrep1 VGA
# proxmox host gpu-top
yyay intel-gpu-toools
intel_gpu_top



%%% {submenu_virt}proxmox gpu passthrough - amd [pxgg]
%%%e {submenu_virt}proxmox gpu passthrough - amd [pxgg]
# 공사중
# amd apu 기준 하나의 vm 에서 gpu passthrough
# BIOS/UEFI에서 IOMMU/SVM enable // secure boot off
# https://god-logger.tistory.com/188
vi2 /etc/default/grub
sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT=.*/#&\nGRUB_CMDLINE_LINUX_DEFAULT="quiet amd_iommu=on iommu=pt video=efifb:off,vesafb:off initcall_blacklist=sysfb_init pcie_acs_override=downstream,multifunction"/' /etc/default/grub
#
# select gpu ( hostos // vm )
vi2 /etc/grub.d/40_custom
#
explorer /etc/grub.d/
#
!!! update-grub
!!! reboot
# 
vi2 /etc/modules
echo "vfio\nvfio_iommu_type1\nvfio_pci\nvfio_virqfd" | tee -a /etc/modules
# 내장 GPU와 오디오 드라이버를 호스트에서 사용하지 않도록 차단
vi2 /etc/modprobe.d/blacklist.conf
echo "blacklist amdgpu\nblacklist snd_hda_intel\nblacklist snd_hda_codec_hdmi" | tee -a /etc/modprobe.d/blacklist.conf
# vga / audio vender id check 
vi2 /etc/modprobe.d/vfio.conf
lspci -nn | cgrep1 VGA | cgrep Audio
# lscpi -> [1002:????] 형태의 amd vender 장치ID varVGA (참조 amd vender 1002)
echo "options vfio-pci ids=varVGA" >> /etc/modprobe.d/vfio.conf
echo "options vfio-pci disable_idle_d3=1" >> /etc/modprobe.d/vfio.conf
!!! update-initramfs -u
!!! reboot
# VBIOS 추출 -> vm 과 host 동기화 (rom)... 위 참고링크 확인
dmidecode -t bios
# gpu check
dmesg | grep IOMMU
ls /dev/dri | cgrep1 renderD128
lspci -nnk | cgrep1 VGA
# proxmox host gpu-top
yyay intel-gpu-toools
intel_gpu_top



%%% {submenu_virt}proxmox upgrade [pxup]
%%%e {submenu_virt}proxmox upgrade [pxup]
# 현재버젼 확인
pveversion
dpkg -l | grep -i "proxmox ve"
vi2 /etc/apt/sources.list.d/pve-install-repo.list
echo "deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription" | tee -a /etc/apt/sources.list.d/pve-install-repo.list   
vi2 /etc/apt/trusted.gpg.d/proxmox-release-bookworm.gpg
wget https://enterprise.proxmox.com/debian/proxmox-release-bookworm.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bookworm.gpg
#
apt update 
# 판올림 없이 프로그램만 업그레이드 
apt -y upgrade
# 판올림 ex) 8.1 -> 8.2 
# 사전 구동중인 vm 종료 혹은 migrate 
!!! apt -y dist-upgrade ;; bell
!!! reboot





%%% {submenu_virt}proxmox helper script [pxh]
%%%e {submenu_virt}proxmox helper script [pxh]
%% vmslistview|cgrep3136 running
# https://community-scripts.github.io/ProxmoxVE/scripts
# Proxmox VE Post Install
: old;bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/misc/post-pve-install.sh)"
bash -c "$(wget -qLO - https://github.com/community-scripts/ProxmoxVE/raw/main/misc/post-pve-install.sh)"
# Proxmox Backup Server Post Install
: old;bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/misc/post-pbs-install.sh)"
bash -c "$(wget -qLO - https://github.com/community-scripts/ProxmoxVE/raw/main/misc/post-pbs-install.sh)"
# Proxmox All template - LXC container create in proxmox
bash -c "$(wget -qLO - https://github.com/community-scripts/ProxmoxVE/raw/main/misc/all-templates.sh)"
# Nginx Proxy Manager LXC IP:81 username admin@example.com password changeme
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/nginxproxymanager.sh)"
# WireGuard LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/wireguard.sh)"
# Home Assistant OS VM IP:8123
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/vm/haos-vm.sh)"
# Docker LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/docker.sh)"
# Transmission LXC (BitTorrent client) user/password transmission IP:9091/transmission
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/transmission.sh)"
# TurnKey File Server LXC (SMB, SFTP, NFS, WebDAV and rsync)
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-fileserver.sh)"
# TurnKey Nextcloud LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-nextcloud.sh)"
# TurnKey OpenVPN LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-openvpn.sh)"
# TurnKey Torrent Server LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-torrentserver.sh)"
# TurnKey Wordpress LXC
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/turnkey/turnkey-wordpress.sh)"
# 
# install
yyay qemu-guest-agent ; systemctl start qemu-guest-agent || /etc/init.d/qemu-ga start
yyay bsdextrautils



%%% {submenu_virt}proxmox vm - backup server [pbs]
%%%e {submenu_virt}proxmox vm - backup server [pbs]
# pbs install ( proxmox-backup-server on new vm/ct(debian11.base) )
# https://pangkin.me/proxmox-backup-server-lxc/
wget https://enterprise.proxmox.com/debian/proxmox-release-bullseye.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bullseye.gpg
echo "deb http://download.proxmox.com/debian/pbs bullseye pbs-no-subscription" >> /etc/apt/sources.list
apt update && apt upgrade -y
apt install -y proxmox-backup 
reboot
# backup-server Removes sub..
bash -c "$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/misc/post-pbs-install.sh)"
# pbs boot after - backup storage mount
#
# nfs mount
apt install -y nfs-common
mkdir -p /data/PBS_NFS ; chown backup:backup /data/PBS_NFS ; chmod 775 /data/PBS_NFS
#mount <NFS_SERVER_IP>:<NFS_SERVER_PATH> /data/PBS_NFS
mount varNFSIP:varNFSpath /data/PBS_NFS
df -h ;; explorer /data/
# boot mount (fstab)
#echo "<NFS_SERVER_IP>:<NFS_SERVER_PATH> /data/PBS_NFS nfs defaults 0 0" >> /etc/fstab
echo "# varNFSIP:varNFSpath /data/PBS_NFS nfs defaults 0 0" >> /etc/fstab && vi2 /etc/fstab
#
# smb mount 비밀번호에 특수기호 없는 smb 전용계정 생성 
apt install -y smbclient keyutils cifs-utils 
mkdir -p /data/PBS_SMB ; chown backup:backup /data/PBS_SMB ; chmod 775 /data/PBS_SMB
mount -t cifs -o "username=varSMBusername,password=varSMBpassword" "//varSMBhost/varRDIR/" /data/PBS_SMB
df -h ;; explorer /data/
# smb fstab add
echo "# //varSMBhost/varRDIR/ /data/PBS_SMB cifs credentials=/root/.smbcredentials,noperm,_netdev 0 0" >> /etc/fstab && vi2 /etc/fstab
echo -e "username=varSMBusername\npassword=varSMBpassword" >> /root/.smbcredentials && vi2 /root/.smbcredentials
# https://pbs.proxmox.com/docs/storage.html
proxmox-backup-manager disk list
# datastore create / 시간지연 screen/tmux 에서 작업 / 완료시 telegram push
df ;; date ; time proxmox-backup-manager datastore create varDataStoreName varPATH ; push
proxmox-backup-manager datastore show varDataStoreName
# 기존 운영중인 datastore path 가 있는 경우 재연결 (PBS 재설치시)
# 기존 운영중인 datastore 제거시 아래 cfg 파일에서 삭제
vi2 /etc/proxmox-backup/datastore.cfg
cat /etc/proxmox-backup/datastore.cfg | push
# webgui
systemctl restart proxmox-backup-proxy ; systemctl status proxmox-backup-proxy
systemctl status proxmox-backup-proxy




# not use
storage="$( for storage in $(pvesm status | awk '/active/ {print $1}'); do pvesm list $storage | grep -q images && echo $storage; done | sort -u )" ; [ -z "$storage" ] && storage="$(pvesm status | awk '/active/ {print $1}')" ; export storage="$storage" ; echo -n "storage scaned: $storage" ; echo



%%% {submenu_virt}proxmox vm - xpenology nas [nas]
%%%e {submenu_virt}proxmox vm - xpenology nas [nas]
%% echo -n "vmid: $newvmid / storage:" ; echo $storage
vmslistview | cgrep1 running
# vm create (cli or gui)
vmslistview ;; export newvmid="varVMID"
qm create $newvmid --name varVMname__nas --ostype l26 --memory 4096 --net0 virtio,bridge=vmbr0 --sockets 1 --cores 4 --kvm 1 --machine q35 --scsihw virtio-scsi-single ; qm list | cgrepl varVMname__nas
# arpl boot loader download https://github.com/wjz304/arpl-i18n/releases
export release_info=$(curl -L --silent "https://api.github.com/repos/wjz304/arpl-i18n/releases/latest") ; export download_url=$(echo "$release_info" | jq -r '.assets[] | select(.name | contains("4GB") and contains("img.zip")) | .browser_download_url') ; echo "release_info: $release_info download_url:$download_url" | courl
cd /var/lib/vz/template/iso ; wget -O arpl.img.zip $download_url ; unzip arpl.img.zip ; rm -f arpl.img.zip ; ls -al /var/lib/vz/template/iso ; export img=arpl.img
# or tcrp boot loader download https://github.com/PeterSuh-Q3/tinycore-redpill/releases
export release_info=$(curl -L --silent "https://api.github.com/repos/PeterSuh-Q3/tinycore-redpill/releases/latest") ; export download_url=$(echo "$release_info" | grep "browser_download_url" | grep "img.gz" | awk -F '"' '{print $4}') ; echo "release_info: $release_info download_url:$download_url" | courl
cd /var/lib/vz/template/iso ; wget -O tcrp.img.gz $download_url ; gunzip tinycore.img.gz ; ls -al /var/lib/vz/template/iso ; export img=tcrp.img
#
# vm disk create 
# storage check
export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo
# vm disk 1 boot, 6 data (max6)
qm importdisk $newvmid /var/lib/vz/template/iso/$img $( echo "$storage" | pipemenu )
qm set $newvmid --ide0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=ide0
qm set $newvmid --varSTG__sata0__sata1__sata2__sata3__sata4__sata5__sata6 $(echo "$storage" | pipemenu):varSIZE__250__500__1000 ; qm config $newvmid 
#
# start 
qm config $newvmid ;echo; qm status $newvmid
qm start $newvmid
#
# hdd detach
qm config $newvmid ;; qm set $newvmid --satavarNUM none
# boot hdd resize ( max 16G )
lvextend -L+'varSIZE__15'G $(find /dev/ -name vm-$newvmid-disk-0) && resize2fs $(find /dev/ -name vm-$newvmid-disk-0)
# boot loader img delete 
rm -f /var/lib/vz/template/iso/$img
# vm delete (if failed / test / unused)
qm stop $newvmid
!!! qm stop $newvmid ; qm destroy $newvmid




%%% {submenu_virt}proxmox vm - opnsense firewall [opn]
%%%e {submenu_virt}proxmox vm - opnsense firewall [opn]
%% echo -n "vmid: $newvmid / storage:" ; echo $storage
vmslistview | cgrep1 running
# vm create (cli or gui)
vmslistview ;; export newvmid="varVMID"
qm create $newvmid --name varVMname__opnsense --ostype l26 --memory 4096 --net0 virtio,bridge=vmbr0 --sockets 1 --cores 4 --kvm 1 --machine q35 --scsihw virtio-scsi-single ; qm list | cgrepl varVMname__opnsense
# boot loader download 
cd /var/lib/vz/template/iso ; wget -O opnsense.img.bz2 https://mirror.ams1.nl.leaseweb.net/opnsense/releases/23.7/OPNsense-23.7-vga-amd64.img.bz2 ; bunzip2 opnsense.img.bz2 ; ls -al /var/lib/vz/template/iso ; export img=opnsense.img
#
# vm disk create 
# storage check
export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo
# vm disk 1 bootloader, 1 os
qm importdisk $newvmid /var/lib/vz/template/iso/$img $( echo "$storage" | pipemenu )
qm set $newvmid --ide0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=ide0
qm set $newvmid --scsi0 $(echo "$storage" | pipemenu):varSIZE__250 ; qm config $newvmid 
# vm wan/lan network add ( 브리지로 내부/외부망 분리한 경우 vmbr1 )
qm set $newvmid --net1 virtio,bridge=vmbr0
qm set $newvmid --net1 virtio,bridge=varVRIDGE__vmbr1
#
# start 
qm config $newvmid ;echo; qm status $newvmid
qm start $newvmid
# live booting 후 login -> installer/opnsense 로그인 하여 scsi0 에 설치 
# 설치후 poweroff 후 ide0 분리 (webui) 후 부팅 
# wan,lan ip 설정후 shell 진입, 방화벽 잠시 끄고 webui 접근 / 방화벽 끄기,켜기
pfctl -d
pfctl -e
#
# boot loader img delete 
rm -f /var/lib/vz/template/iso/$img
# vm delete (if failed / test / unused)
qm status $newvmid
qm ulock $newvmid 
qm stop $newvmid ; qm status $newvmid
!!! qm stop $newvmid ; qm destroy $newvmid



%%% {submenu_virt}proxmox vm - create ubuntu desktop or etc [ubun]
%%%e {submenu_virt}proxmox vm - create ubuntu desktop or etc [ubun]
%% echo -n "newvmid: $newvmid / img: $img / iso: $isourl /  storage:" ; echo $storage
vmslistview | cgrep1 running
# vm create (cli or gui)
vmslistview ;; export newvmid="varVMID"
qm create $newvmid --name varVMname --ostype l26 --memory varMEMm__2048__4096__8192 --sockets 1 --cores 4 --kvm 1 --machine q35 --net0 virtio,bridge=vmbr0 --scsihw virtio-scsi-single ; qm list | cgrepl varVMname
# iso download
# https://releases.ubuntu.com/noble/
# https://releases.ubuntu.com/noble/ubuntu-24.04.2-desktop-amd64.iso
# https://releases.ubuntu.com/noble/ubuntu-24.04.2-live-server-amd64.iso
export isourl="varISOurl" ; export img="$(basename "$isourl")" 
cd /var/lib/vz/template/iso ; wget --limit-rate=varSpeedLimit__5m__10m__100m -c -O $img $isourl ; ls -al /var/lib/vz/template/iso ; bell
# 다운 완료된 img 선택
export img=$( ls -1t /var/lib/vz/template/iso | pipemenu ) 
explorer /var/lib/vz/template/iso
#
# vm disk create 
# storage check
export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo
# bootloader(cdrom -> img.iso mount) // os_disk(ex.ubuntu)
qm set $newvmid --ide0 local:iso/$img,media=cdrom ; qm set $newvmid --boot order=ide0
qm set $newvmid --scsi0 $(echo "$storage" | pipemenu):varSIZE__250 ; qm config $newvmid 
# static or dhcp ip set // ex.) ip=192.168.1.100/24 gw=192.168.1.1
# img install and set ip
ip -br a | awk '$3 != "" {print $1, $3}'
qm set $newvmid --net0 virtio,bridge=varBRG__vmbr0__vmbr1__vmbr2 --ipconfig0 ip=varIP,gw=varGateway
qm set $newvmid --net0 virtio,bridge=varBRG__vmbr0 --ipconfig0 ip=dhcp
#
# start 
qm config $newvmid ;echo; qm status $newvmid
qm start $newvmid
qm $( echo start config status ulock stop | pipemenu ) $newvmid ;; qm status $newvmid
# iso install end 
qm set $newvmid --boot order=scsi0
#
# img delete 
rm -f /var/lib/vz/template/iso/$img
# vm delete (if failed / test / unused)
!!! qm stop $newvmid ; qm destroy $newvmid



%%% {submenu_virt}proxmox vm - iso/lxc download [iso]
%%%e {submenu_virt}proxmox vm - iso/lxc download [iso]
%% find /var/lib/vz/template/iso -type f -exec ls -alh {} \;
# iso download 
cd /var/lib/vz/template/iso ; 
cd varIsoPath;
# ubuntu Server 22.04.3
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O ubuntu-22.04.3-live-server-amd64.iso https://releases.ubuntu.com/22.04.3/ubuntu-22.04.3-live-server-amd64.iso ;push
# ubuntu Desktop 23.10 
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O ubuntu-23.10.1-desktop-amd64.iso https://releases.ubuntu.com/23.10.1/ubuntu-23.10.1-desktop-amd64.iso ;push
# centos7 http://mirror.kakao.com/centos/7.9.2009/isos/x86_64/
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O CentOS-7-x86_64-DVD-2009.iso http://mirror.kakao.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso ;push
# debian12 https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O debian-12.2.0-amd64-DVD-1.iso https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.2.0-amd64-DVD-1.iso ;push
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O debian-12.10.0-amd64-DVD-1.iso https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.10.0-amd64-DVD-1.iso
# hamonios
wget --limit-rate=varSpeedLimit__5m__7m__10m__100m -O hamonikr-kumkang-7.0-LTS-amd64.iso https://invesume.com/linkfile/download_count.php?type=hamonikr-kumkang-7.0-LTS-amd64.iso ;push
#
# pveam lxc image download 
pveam update ; pveam available ; pvesm status ;; pveam download varSTRG__local $( pveam available|awk2 |pipemenu1  ) 
#
#
explorer /var/lib/vz/template/iso
explorer varIsoPath



%%% {submenu_virt}proxmox (vmware.vmdk) to (proxmox) migration [mig]
%%%e {submenu_virt}proxmox (vmware.vmdk) to (proxmox) migration [mig]
%% echo -n "vmid: $newvmid / storage: $storage / vmdk: $vmdk" ; echo 
vmslistview | cgrep1 running
# vm create (cli or gui)
vmslistview ;; export newvmid="varVMID"
qm create $newvmid --name varVMname --ostype l26 --memory 4096 --net0 virtio,bridge=vmbr0 --sockets 1 --cores 4 --kvm 1 --machine q35 --scsihw virtio-scsi-single ; qm list | cgrepl varVMname
#
# storage check
export storage="$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' )" ; echo -n "storage scaned: $storage" ; echo
#
# vmdk exported vmware 이미지 가져오기
# proxmox webui 의 storage - ISO 이미지 업로드 기능을 이용하여 vmdk 확장자에 .iso
# 를 추가하여 웹으로 업로드 가능. /var/lib/vz/template/iso/*.vmdk 기준
cd /var/lib/vz/template/iso ; ls -al 
export vmdk=$( find /var/lib/vz/template/iso -type f -regex ".*\.\(img\|iso\|vmdk\)$" |pipemenu ) 
export vmdk=varVmdkPATH 
# importdisk vmdk -> raw -> device-mapper
qemu-img convert -f vmdk -O raw $vmdk - | qm importdisk $newvmid - $(echo "$storage" | pipemenu)
# disk -> vm에 붙이기 (scsi or sata or ide 선택)
qm set $newvmid --scsi0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=scsi0
qm set $newvmid --sata0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=sata0
qm set $newvmid --ide0 $(qm config $newvmid | awk '$1 ~ /unused0/ {print $2}') ; qm set $newvmid --boot order=ide0
#
# start
qm config $newvmid ;echo; qm status $newvmid
qm start $newvmid
#
# import hdd size-up
lvextend -L+'varSIZE'G $(find /dev/ -name vm-$newvmid-disk-0) && resize2fs $(find /dev/ -name vm-$newvmid-disk-0)
#
# import 후 vmdk 원본 삭제 
rm -f $vmdk
#
# vm delete (if failed / test / unused)
qm stop $newvmid
!!! qm stop $newvmid ; qm destroy $newvmid





%%% {submenu_virt}proxmox node reset [node]
%%%e {submenu_virt}proxmox node reset [node]
pvecm nodes ;echo; pvecm status
# 클러스터에서 node 분리 작업
systemctl stop pve-cluster corosync
pmxcfs -l 
# corosync 구성 파일 검토/백업/삭제
rbackup varBackupDIR__@@backup/etc_daily.tgz ; tar cvzf varBackupDIR__@@backup/etc_daily.$(datetag2).tgz /etc/ 
vi2 /etc/pve/corosync.conf
explorer /etc/corosync/
#
rm -rf /etc/pve/corosync.conf /etc/corosync/*
killall pmxcfs ; systemctl start pve-cluster
# 나머지 node 에서 분리된 node 삭제
pvecm delnode varNodename
rm -rf /etc/pve/nodes/varNodename 
# cluster node down 
# 정족수 부족 -> 읽기전용모드 -> 해제
pvecm expect 1



%%% {submenu_virt}proxmox host - cloud init generic [pxc]
%%%e {submenu_virt}proxmox host - cloud init generic [pxc]
%% echo "tvmid: $tvmid storage: $storage"
ay cloud-init ; qm list
# type2. download the image ubuntu / debian / centos7,9 (include cloud-init)
:ubuntu ; cd /var/lib/vz/template/iso ; wget https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img
:debian ; cd /var/lib/vz/template/iso ; wget https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2
:centos7; cd /var/lib/vz/template/iso ; wget http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2
:alma9  ; cd /var/lib/vz/template/iso ; wget https://repo.almalinux.org/almalinux/9/cloud/x86_64/images/AlmaLinux-9-GenericCloud-latest.x86_64.qcow2
# create a new VM with VirtIO SCSI controller
qm list ;; export tvmid=varNewTemplateID__9000
qm create $tvmid --name varVmName --memory 4096 --net0 virtio,bridge=vmbr0 --scsihw virtio-scsi-pci
# cloud-init 저장할 storage 선택
export storage=$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' |pipemenu) 
# import the downloaded disk to the storage, attaching it as a SCSI drive
qm set $tvmid --scsi0 $storage:0,import-from=$( find /var/lib/vz/template/iso/ -type f | pipemenu ) 
qm set $tvmid --ide2 $storage:cloudinit
qm set $tvmid --boot order=scsi0
qm set $tvmid --serial0 socket --vga serial0
qm set $tvmid --ipconfig0 'ip=dhcp'
# 설정값 출력
qm cloudinit dump $tvmid user
qm template $tvmid
#
# template -> full_clone -> init set (gui or cli)
export vmid=varNewVMID
qm clone $tvmid $vmid --name varVMname
qm set $vmid --sshkey ~/.ssh/id_rsa.pub
qm set $vmid --ipconfig0 'ip=varIP/24,gw=varGateway'
qm set $vmid --ciuser varUser__root --cipassword 'varPW' 
qm set $vmid --nameserver varNAME__168.126.63.1 
# 설정값 출력
qm cloudinit dump $vmid user


%%% {submenu_virt}proxmox host - cloud init custom [pxcc]
%%%e {submenu_virt}proxmox host - cloud init custom [pxcc]
# cloud init 지원 os 체크 (centos6.4 이상, 예전 리눅스는 지원불가)
%% echo "tvmid: $tvmid storage: $storage"
ay cloud-init ; qm list
# type1. template 로 변환할 vmid 선택
qm list ;; export tvmid=$( qm list |awk1 |pipemenu )
# clone -> template chg (원본 vmid 유지희망시)
qm clone $tvmid varNewTemplateID__9000 ; export tvmid=varNewTemplateID__9000
# cloud-init 저장할 storage 선택
export storage=$( pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage' |pipemenu) 
# 
qm set $tvmid --name varVmName
qm set $tvmid --ide2 $storage:cloudinit
qm set $tvmid --boot order=scsi0
qm set $tvmid --serial0 socket --vga serial0
qm set $tvmid --ipconfig0 'ip=dhcp'
# 
qm set $tvmid --sshkey $HOME/.ssh/id_rsa.pub
qm set $tvmid --ciuser varUser__root --cipassword 'varPW' 
qm set $tvmid --nameserver varNAME__168.126.63.1 
# 설정값 출력
qm cloudinit dump $tvmid user
qm template $tvmid




%%% {submenu_virt}proxmox host - backup/restore/vnc [pxb]
%%%e {submenu_virt}proxmox host - backup/restore/vnc [pxb]
# 하드웨어 문제로 host 재설치시 복구진행
# /var/lib/pve-cluster/config.db 백업해둔것으로 복구
# 상시 백업및 안전한 위치에 복사  
cp -a /var/lib/pve-cluster/config.db /var/lib/pve-cluster/config.db.bak.$(datetag2) ; ls -al /var/lib/pve-cluster/
cp -a /etc/pve /etc/pve.bak.$(datetag2) ; ls -al /etc/ | grep "pve"
# proxmox install && restore
cp -a /etc/pve /etc/pve.bak
cp -a varPathetcpve /etc/
systemctl stop pve-cluster
cp /var/lib/pve-cluster/config.db /var/lib/pve-cluster/config.db.bak
cp varPathConfig.db /var/lib/pve-cluster/
systemctl start pve-cluster
# vm data 마운트
# 
# proxmox host backup script 
# https://github.com/DerDanilo/proxmox-stuff
wget -O $HOME/prox_config_backup.sh https://raw.githubusercontent.com/DerDanilo/proxmox-stuff/master/prox_config_backup.sh
sed -i 's|^DEFAULT_BACK_DIR=.*|DEFAULT_BACK_DIR="varBackupPATH"|g' $HOME/prox_config_backup.sh
vi2 $HOME/prox_config_backup.sh
bash $HOME/prox_config_backup.sh
echo "59 22 * * 0 root $HOME/prox_config_backup.sh" >> /etc/crontab ; vi2 /etc/crontab
# restore script
wget -O $HOME/prox_config_restore.sh https://raw.githubusercontent.com/DerDanilo/proxmox-stuff/master/prox_config_restore.sh
vi2 $HOME/prox_config_restore.sh
ls -altr $( cat $HOME/prox_config_backup.sh | grep 'DEFAULT_BACK_DIR=' | awk -F'=' '{print $2}' |sed -e 's/"//g' )
bash $HOME/prox_config_restore.sh varBackupFilePath
#
# vnc server
ay tigervnc-standalone-server 
vncpasswd
# xwindow check & install 
ls /usr/bin/*wm ; ls /usr/share/xsessions/
ay $( echo mate-desktop-environment-core xfce4 dbus-x11 | pipemenu )
# select installed x-session 
tigervncserver -xstartup /usr/bin/mate-session -geometry 1280x800 -localhost no :1
tigervncserver -xstartup /usr/bin/startxfce4 -geometry 1280x800 -localhost no :1
tigervncserver -xstartup /usr/bin/xterm -geometry 1280x800 -localhost no :1
tigervncserver -kill :1
# browser install
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 
dpkg -i google-chrome-stable_current_amd64.deb && apt install -f 
google-chrome --no-sandbox
# x disable (vnc 안쓸때 부하 감소)
systemctl list-unit-files --type=service | grep dm.service
systemctl disable --now lightdm




%%% {submenu_virt}proxmox host - recover deleted vm [pxr]
%%%e {submenu_virt}proxmox host - recover deleted vm [pxr]
%% echo "vmid: $vmid vg: $vg"
# /etc/lvm/archive/*.vg /etc/pve/qemu-server/vm-*.conf
# lvm metadata 는 /etc/lvm/archive/*.vg 의 최근 백업 파일에서 복구, /etc/ 백업에서 vm-*.conf 를 복구
# recover vm name set ex) vm-105
lvs ;; vmid=varVMID__105 ; export vmid="vm-$vmid" ; export vg=$( lvs |grep $vmid|awk '{print $2}' |head -n1)
# vgcfgrestore list
vgcfgrestore --list $vg
cd /etc/lvm/archive ; ls -lt 
# 삭제한 당일 즉시 적당한 복구 파일 선택 ex) vgname_00160-955052724.vg
vgfile=varVGfile 
#
# recover 전 백업 
vgcfgbackup varVGname -f /backup/vgcfg.backup.$(datetag2).vg
vi2 $( ls -1 /backup/vgcfg.backup.*.vg | pipemenu ) 
# has unexpected transaction id *** error 발생시 현재꺼 백업후 vi 수정후 복구 
vgcfgrestore -f $( ls -1 /backup/vgcfg.backup.*.vg | pipemenu ) varVGname --force
#
# recover test - last backup file or specified file
vgcfgrestore --test $vg
vgcfgrestore --test -f $vgfile $vg
# recover force 
vgcfgrestore $vg --force
vgcfgrestore -f $vgfile $vg --force
# inactive 복구 lvm 체크
pvs;echo;vgs;echo;lvs
lvscan 
# inactive -> active
lvscan | grep inactive | awk '{print $2}' | tr -d "'" | xargs -I {} lvchange -ay {}
# (주의) 복구 실패 lvremove
!!! lvscan ; readx ; lvscan | grep inactive | awk '{print $2}' | tr -d "'" | xargs -I {} lvremove {}
#
# 생성/삭제/복구 샘플
vgcfgbackup varVGname -f /backup/vgcfg.backup.$(datetag2).vg
lvs ;; export vg=$(lvs|tail -n1|awk '{print $2}'); pool=$(lvs|tail -n1|awk '{print $5}'); echo "vg: $vg, thin-pool: $pool" 
lvcreate -n lvtest1 -L 1G $vg ; lvs | cgrep1 lvtest1
lvcreate -V 1G -T $vg/$pool -n lvtest1 ; lvs | cgrep1 lvtest1
lvremove /dev/$vg/lvtest1 ; lvs
vgcfgrestore $vg ; lvs
vgcfgrestore $vg --force ; lvs
# 복구가 되지 않은 경우 파일 탐색후 지정 
cd /etc/lvm/archive ; ls -lt
for i in $( ls -1tr|tail -n10 ) ; do echo $i ; grep "varTEXT__lvtest1" $i ;done
vi2 $( ls -1tr|tail -n10 |pipemenu ) 
vgcfgrestore -f varVGfile $vg --force ; lvs
lvscan
lvchange -ay $vg/lvtest1
# device-mapper: reload ioctl on (253:29) failed -> 복구불가
# thin volume 은 대부분 복구가 불가능한 것으로 추정




%%% {submenu_virt}proxmox host - tailscale vpn server [pxt]
%%%e {submenu_virt}proxmox host - tailscale vpn server [pxt]
# WireGuard를 기반으로 한 VPN 서비스 
# proxmox 설치 네트워크에 외부 접근 용이
curl -fsSL https://pkgs.tailscale.com/stable/debian/buster.noarmor.gpg | sudo tee /usr/share/keyrings/tailscale-archive-keyring.gpg >/dev/null
echo "deb [signed-by=/usr/share/keyrings/tailscale-archive-keyring.gpg] https://pkgs.tailscale.com/stable/debian bookworm main" | sudo tee /etc/apt/sources.list.d/tailscale.list
apt update ; ay tailscale
tailscale up
# 내부 네트워크 확인 (ex. 192.168.100.0/24)
route -n |cip
tailscale up --advertise-routes=192.168.100.0/24 --accept-routes=192.168.100.0/24 --snat-subnet-routes=false
iprange=$( route -n | awk '$3 == "255.255.255.0" {print $1 "/24"}' | pipemenucancel ) ;; tailscale up --advertise-routes=$iprange varIPrange --accept-routes=$iprange --snat-subnet-routes=false
# Tailscale 인증 URL이 출력되면 브라우저에서 접속하여 Proxmox 호스트를 Tailscale 계정에 인증
# (https://login.tailscale.com/admin/machines)에 접속 Proxmox 노드의 "라우팅 설정" 탭이동
# "서브넷 라우팅 활성화" 스위치 on
#
vi2 /etc/sysctl.conf
echo 'net.ipv4.ip_forward = 1' | tee -a /etc/sysctl.conf
echo 'net.ipv6.conf.all.forwarding = 1' | tee -a /etc/sysctl.conf
sysctl -p /etc/sysctl.conf
#
tailscale status
tailscale ping varIP


%%% {submenu_virt}proxmox host - dhcp server [pxd]
%%%e {submenu_virt}proxmox host - dhcp server [pxd]
%% echo "iprange: $iprange vmbrN: $vmbrN"
# linux bridge vmbrN[1-9] 생성 (webgui or cli) NAT # vmbr0 와 다른 아이피 대역 선택 
# vm 에서 네트워크 vmbrN 을 선택하면 NAT 환경의 dhcp 자동 할당된 ip 획득  
cp -a /etc/network/interfaces /etc/network/interfaces.backup
iprange24=$( echo 10.0.0 10.0.1 10.0.2 192.168.0 192.168.10 192.168.100 | pipemenu ) ; iprange="${iprange24}.1/24"
iprange24=varNetworkID__192.168.0 ; iprange="${iprange24}.0/24"
vmbrN=varVmbrN__vmbr9
echo -e "auto $vmbrN\niface $vmbrN inet static\n     address $iprange\n     bridge-ports none\n     bridge-stp off\n     bridge-fd 0\n" >> /etc/network/interfaces
# NAT 설정 vmbr0 <-> vmbrN 통신 가능하도록 
echo -e "post-up echo 1 > /proc/sys/net/ipv4/ip_forward\npost-up   iptables -t nat -A POSTROUTING -s '$iprange' -o vmbr0 -j MASQUERADE\npost-down iptables -t nat -D POSTROUTING -s '$iprange' -o vmbr0 -j MASQUERADE\n" >> /etc/network/interfaces
vi2 $( ls -1 /etc/network/interfaces* | pipemenu1 )
diff /etc/network/interfaces.backup /etc/network/interfaces
# 네트워크 먹통 대비 복구 가능한 스크립트로 네트워크 재시작
declare -f rrnet
!!! rrnet yes
!!! systemctl restart networking 
#
# nat 하부 포트 포워딩 (ssh 2222/ wireguard 51820)
echo -e "post-up   iptables -t nat -A PREROUTING -i vmbr0 -p tcp --dport 2222 -j DNAT --to varVMIP:22\npost-down iptables -t nat -D PREROUTING -i vmbr0 -p tcp --dport 2222 -j DNAT --to varVMIP:22\n" >> /etc/network/interfaces
echo -e "post-up   iptables -t nat -A PREROUTING -i vmbr0 -p udp --dport 51820 -j DNAT --to varVMIP:51820\npost-down iptables -t nat -D PREROUTING -i vmbr0 -p udp --dport 51820 -j DNAT --to varVMIP:51820\n" >> /etc/network/interfaces
# NAT table 설정 체크 
iptables -t nat -L -n -v
iptables-save -t nat 
GREEN=$(tput setaf 6);RESET=$(tput sgr0);iptables-save -t nat | awk -v green="$GREEN" -v reset="$RESET" '/^-A/ {print $0; gsub("-A", "-D"); print green "iptables -t nat " $0 reset}'
#
# dhcp install 
ay isc-dhcp-server
echo "INTERFACESv4=\"$vmbrN\"" >> /etc/default/isc-dhcp-server
vi2 /etc/default/isc-dhcp-server
# ip range select 
template_view dhcp.yml 
template_copy dhcp.yml /etc/dhcp/dhcpd.conf.new 
vi2 /etc/dhcp/dhcpd.conf.new
vi2 /etc/dhcp/dhcpd.conf
cp -a /etc/dhcp/dhcpd.conf.new /etc/dhcp/dhcpd.conf
#
systemctl restart isc-dhcp-server ; systemctl status isc-dhcp-server
systemctl status isc-dhcp-server
# dhcp 서버가 구동된후 # dhcp 서버를 쓸 vm 의 네트워크 브릿지를 vmbrN 로 변경 (webgui)



%%% {submenu_virt}proxmox host - open-vswitch [ovs]
%%%e {submenu_virt}proxmox host - open-vswitch [ovs]
# install
ay openvswitch-switch
brctl show
# bridge cre
ovs-vsctl add-br varBRIDGE__ovsbr0
ovs-vsctl del-br varBRIDGE
ip l | cgrep DOWN | cgrep1 UP | cip
# 원격작업시 서버 다운될수 있으니 주의 
# webgui 에서 설정하여 오류 점검 
!!! ip l ;; ovs-vsctl add-port varBRIDGE varInterface ;pp; [ $(pingcheck) == "n" ] && for i in $( ovs-vsctl list-ports varBRIDGE ) ; do echo $i ; ovs-vsctl del-port varBRIDGE $i ; done ; [ $(pingcheck) == "n" ] && systemctl restart networking.service
!!! ip l ;; ovs-vsctl del-port varBRIDGE varInterface
# monitor
ovs-vsctl show
ovs-vsctl list-br
ovs-vsctl list bridge
ovs-vsctl list-ports varBRIDGE
ovs-vsctl list port
ovs-ofctl show varBRIDGE
ovs-ofctl dump-flows varBRIDGE
# start/stop
systemctl enable --now openvswitch-switch
systemctl disable --now openvswitch-switch
systemctl status openvswitch-switch


%%% {submenu_virt}kvm hypervisor [kvm]
%%%e {submenu_virt}kvm hypervisor [kvm]
# kvm support check cpu
# nested vm -> proxmox hypervisor vm -> (cpu-var 'host' select)
egrep -c '(vmx|svm)' /proc/cpuinfo
# virt install
!!! yy qemu-kvm libvirt virt-install bridge-utils qemu-guest-agent
!!! ay qemu-kvm libvirt-daemon-system libvirt-daemon virtinst bridge-utils libosinfo-bin
!!! yum groupinstall -y virtualization-client virtualization-platform virtualization-tools
# daemon
systemctl enable --now libvirtd ; systemctl status libvirtd
lsmod | grep -i kvm
# virt-install centos7
# 기본 NAT 네트워크 환경 -> Bridge 네트워크로 변경하여 설치 (vnc 접근 용이)
ipa;;virt-install --name centos7 --ram 2048 --disk path=/var/lib/libvirt/images/centos7.img,size=20 --vcpus 2 --os-variant centos7.0 --network bridge=varBRG__virbr0 --graphics none --console pty,target_type=serial --location 'http://mirror.kakao.com/centos/7/os/x86_64/' --extra-args 'console=ttyS0,115200n8 serial' 
# basic installed -> template copy
virt-clone --original centos7 --name template --file /var/lib/libvirt/images/centos7.template.img
# virt-install debian12
ipa;;virt-install --name debian12 --ram 4096 --disk path=/var/lib/libvrit/images/debian12.img,size=20 --vcpus 2 --os-variant debian11 --network bridge=varBRG__virbr0 --graphics none --console pty,target_type=serial --location 'http://deb.debian.org/debian/dists/bookworm/main/installer-amd64' --extra-args 'console=ttyS0,115200n8 serial' 
# list / start / shutdown / poweroff
virsh list --all
virsh list --all ;; virsh start $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu )
virsh list --all ;; virsh start $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu ) --console
virsh list --all ;; virsh console $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu )
virsh list --all ;; virsh shutdown $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu )
virsh list --all ;; virsh destroy $( virsh list --all|awk '$1 ~ /[0-9]/ {print $2}' | pipemenu )
# vm remove 
!!! virsh undefine varVM ; rm /var/lib/libvirt/images/varVM\.img
explorer /var/lib/libvirt/images/
# img resize
cd /var/lib/libvirt/images ; ls -al
qemu-img resize varIMG.qcow2 + "varSIZE"G
#
ip addr show varBRG
# swap off
!!! swapoff -a && sed -i '/swap/s/^/#/' /etc/fstab




%%% {submenu_com}Logical Volume Manager [lvm]
%%%e {submenu_com}Logical Volume Manager [lvm]
%% echo -n "sdx:$sdx // HDD: " ; lsblk -d -n -o name | oneline
# 물리 Disk 장착후 
fdisk -l 
# 파티션 생성후 type LVM 타입으로 변경 8e 
lsblk -n -o maj:min,type,name | awk '$2 ~ /^(disk|part)$/ {print }'
: sdx set ; sdx=$( lsblk -n -o maj:min,type,name | awk '$2 ~ /^disk$/ {print $3}' |pipemenucancel) ;; export $sdx 
echo $sdx ; fdisk -l /dev/$sdx ;; parted -s /dev/$sdx print
# 파티션 정보 백업 (새디스크는 불필요)
sfdisk -d /dev/$sdx > ~/$sdx.partition_table.txt ;; cat ~/$sdx.partition_table.txt | cpipe
# 파티션 생성 (mbr or gpt lvm) - 파티션1번 생성후 lvm 지정 (fdisk t->8e)
!!!: fdisk-mbr ; fdisk /dev/$sdx
!!!: parted-gpt; parted /dev/$sdx mklabel gpt ;; parted /dev/$sdx mkpart primary 0% 100% ;; parted /dev/$sdx set 1 lvm on ;; partprobe /dev/$sdx
# 물리볼륨생성 (ex. pvcreate /dev/sdb1)
!!! pvcreate /dev/${sdx}1
pvdisplay | cpipe
pvs
# 볼륨그룹생성 /dev/vgname/ (ex. vgcreate vg-homegroup /dev/sdb1 /dev/sdc1 /dev/sdd1)
pvdisplay ;; vgcreate varVGname varPVs
# 볼륨그룹확장 (현재 볼륨그룹에 새로 추가한 pv ex. /dev/sdc1 추가) 
!!! vgextend varVGname varNewPV
eval varVGScmd__vgdisplay__vgdisplay@space@-v__vgs
# 논리볼륨  생성 /dev/vgname/lvname (ex. lvcreate -n lv-homefree -L 10000G vg-homegroup)
vgs ;; lvcreate -n varLVname -L varSIZE varVGname
# LVM-Thin 프로비저닝 씬풀
vgs;lvs ;; lvcreate -L varSIZE -T varVGname/varThinPool
vgs;lvs ;; lvcreate -l 100%FREE -T varVGname/varThinPool
# LVM_Thin 논리볼륨 생성 
!!! lvcreate -V varSIZE -T varVGname/varThinPool -n varLVname
lvdisplay | cpipe | less -RX
lvs
# 마운트할경우 포맷 // mount // fstab
lsblk -f 
ls -1 /usr/sbin/mkfs*
!!! mkfs.varFtype__ext4__ext3__btrfs__xfs /dev/varVGname/varLVname 
echo "#/dev/varVGname/varLVname varMountDIR ext4 defaults 1 2" >> /etc/fstab 
vi2 /etc/fstab
# lvextend -L [+|-]새로운 크기 [M|G|T] /dev/volume_group_name/logical_volume_name
!!! s=varSIZE ; lvextend -L+${s}G varLVpath
!!! lvextend -l +100%FREE varLVpath
!!! resize2fs varLVpath
# thin-pool 사용량 체크 (vm 이 사용할 수 있는 thin 전체 용량)
(echo "LV LSize Data% Meta% Used(G) Free(G)"; lvs --units g -o lv_name,lv_size,data_percent,metadata_percent --select 'segtype="thin-pool"' --noheadings | awk '{print $1, $2, $3, $4, ($2 * $3 / 100) "G", ($2 - ($2 * $3 / 100)) "G"}') | column -t



%%% {submenu_virt}qemu-img os-image dump/convert [qemui]
%%%e {submenu_virt}qemu-img os-image dump/convert [qemui]
# qemu-img convert
# dd dump varDevice(ex. /dev/sda) -> varDevice.raw
dd if=varDevice of=/backup/$(basename varDevice).raw
# dd dump -> qcow2
dd if=varDevice | qemu-img convert -p -f raw -O qcow2 /dev/stdin /backup/$(basename varDevice).qcow2
# raw device -> qcow2 device ex.) /dev/vg-950/vm-101-disk-1 
qemu-img convert -p -f raw -O qcow2 varDevice /backup/$(basename varDevice).qcow2
# raw img(dd,raw,img) -> qcow2
qemu-img convert -p -f raw -O qcow2 /backup/varIMG /backup/varIMG.qcow2
# raw img(dd,raw,img) -> vmdk 
qemu-img convert -p -f raw -O vmdk /backup/varIMG /backup/varIMG.vmdk
# vmdk -> qcow2
qemu-img convert -pO qcow2 -f vmdk /backup/varVMDK /backup/varVMDK.qcow2
# 
# booting img -> import disk vm (ide0)
#
# usb 에 img 파일을 굽지 않고, ide0 에 import 하며 img live booting
# ex) qm importdisk 100 /mnt/pve/smb/template/iso/OPNsense-23.7-vga-amd64.img disk2
# ex) qm set 100 --ide0 disk2:vm-110-disk-1 ; qm set 110 --boot order=ide0
pvesh get /storage -output-format=json | jq -r '.[] | select(.content | contains("images")) .storage'
qm importdisk varVMID varIMG varSTORAGE
qm set varVMID --ide0 $(qm config varVMID | awk '$1 ~ /unused0/ {print $2}') ; qm set varMVID --boot order=ide0









%%% {submenu_virt}minecraft [mc]
%%%e {submenu_virt}minecraft [mc]
screen -ls 
# screen retach
screen -ls ;; screen -x $( screen -ls |grep tach |pipemenu1 )
# start // restart
echo "eula=true" > /root/Minecraft/eula.txt ; screen -dmS varNAME__mc /root/Minecraft/run.sh nogui ; screen -x varNAME__mc 
screen -ls ;; screen -S varNAME__mc -X quit ; screen -ls ; screen -dmS varNAME__mc /root/Minecraft/run.sh nogui && screen -x varNAME__mc
# stop // stop force // java running kill
screen -ls ;; screen -S varNAME__mc -X quit ; screen -ls
ps -ef|grep "$(basename $(readlink /root/Minecraft))"|awk '{print $2}'|xargs kill -
ps -ef|grep [j]ava|awk '{print $2}'|xargs kill 2>/dev/null ; sleep 2 ; screen -ls
# bungeecord start // restart // stop
screen -dmS bungeecord /root/bungeecord/run.sh nogui && screen -x bungeecord
screen -S bungeecord -X quit && screen -dmS bungeecord /root/bungeecord/run.sh nogui && screen -x bungeecord
screen -S bungeecord -X quit 
#
# port chg (default:25565)
sed -i -E "s/(^server-port=).*/\1varPORT__25565/g" /root/Minecraft/server.properties ; cat /root/Minecraft/server.properties|grep server-port
explorer /root/$(ls -1 /root|grep Minecraft|pipemenu1 )
# 
# screen dump view
screen -S $( screen -ls |grep tach |pipemenu1 ) -X hardcopy -h /root/_screendump ; cat /root/_screendump | cip |less -RX +G ; rm -f /root/_screendump





%%% {submenu_virt}minecraft install [mci]
%%%e {submenu_virt}minecraft install [mci]
# paper server install
dir="/root/Minecraft.paper" ; link="https://api.papermc.io/v2/projects/paper/versions/1.20.1/builds/43/downloads/paper-1.20.1-43.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ -L "/root/Minecraft" ] && rm /root/Minecraft ; ln -s $dir /root/Minecraft ; [ ! -f $file ] && wget $link ; echo "java -Xms1G -Xmx10G -Djava.awt.headless=true -jar $dir/$file" > $dir/run.sh ; chmod 700 run.sh 
# 
# forge server install
dir="/root/Minecraft.forge" ; link="https://maven.minecraftforge.net/net/minecraftforge/forge/1.19.2-43.2.3/forge-1.19.2-43.2.3-installer.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ -L "/root/Minecraft" ] && rm /root/Minecraft ; ln -s $dir /root/Minecraft ; [ ! -f $file ] && wget $link ; java -jar $file  -installServer ; echo "-Xms1G -Xmx10G" > user_jvm_args.txt
# 
# bungeecord https://www.spigotmc.org/wiki/bungeecord-installation/
dir="/root/Minecraft.bungeecord" ; link="https://ci.md-5.net/job/BungeeCord/lastSuccessfulBuild/artifact/bootstrap/target/BungeeCord.jar" ; file=${link##*/} ; [ ! -d $dir ] && mkdir $dir ; cd $dir ; [ ! -L "/root/bungeecord" ] && ln -s $dir /root/bungeecord ; [ ! -f $file ] && wget $link ; echo "java -Xms1G -Xmx1G -Djava.awt.headless=true -jar $dir/$file" > $dir/run.sh ; chmod 700 run.sh
# 
vi2 $(echo "/root/Minecraft.bungeecord/config.yml /root/Minecraft/server.properties"|pipemenu )
# java & etc install
aptupup ; yyay openjdk-17-jdk wget screen


%%% >Lamp (apache,php,mysql) [la]
%%%e >Lamp (apache,php,mysql) [la]
{submenu_lamp}



%%% >linux_commands & utils - find vi swap.. [c]
%%%e >linux_commands & utils - find vi swap.. [c]
{submenu_com}


%%% >proxmox / kvm / minecraft virt [v]
%%%e >proxmox / kvm / minecraft virt [v]
{submenu_virt}
%% able pvesh && vmslistview|cgrep3136 running



%%% >docker / docker compose [dk] 
%%%e >docker / docker compose [dk] 
{submenu_docker}
%% dockersvcorg | column -t 
%% able docker && dockerps=$(docker ps|awknr2 2>/dev/null) && [ "${dockerps}" ] && echo && echo "$dockerps"| maxl 20 20 0 0 0 0 0 0 0 15 15 15 0 0 0 0 0|stripe |column -t






%%% ollama local llm - gemma3 [lama]
%%%e ollama local llm - gemma3 [lama]
# install https://ollama.ai/download/linux
curl -fsSL https://ollama.ai/install.sh | sh
ollama --version ; ollama --help
# start / stop 
systemctl enable --now ollama
systemctl status ollama
systemctl disable --now ollama
# gemma3 model download && local cli exec // 4b - cpu powered llm
# model: https://ollama.com/search
ollama pull gemma3:varSIZE__4b__1b__27b__12b
# everywhere "chat or ai or hi or hello" [Enter] -> ollama run gemma3
ollama run gemma3
ollama list




%%% {submenu_hidden}nvm / nodejs [js]
%%%e {submenu_hidden}nvm / nodejs [js]
# nvm (node verison manager)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
source $HOME/.nvm/nvm.sh && nvm --version
nvm --version
# nodejs 
nvm install 14.4.0
nvm use 14.4.0
nvm ls
node -v 
# nvm set/unset
explorer $HOME/.nvm/
vi $HOME/.bashrc -c /NVM
#
#
# or system nodejs install
yyay nodejs 
node -v 
apt remove nodejs
# nodejs v14 or v20 install
apt remove nodejs libnode-dev
curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash -
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
apt-get install -y nodejs
node -v 
# npm (node package manager)
npm -v 





%%% {submenu_lamp}webmail - squirrelmail [sq]
%%%e {submenu_lamp}webmail - squirrelmail [sq]
# squirrelmail - https://squirrelmail.org/download.php
cd varWebmailDir__@@homein
wget -O sq.tgz https://squirrelmail.org/countdl.php?fileurl=http%3A%2F%2Fprdownloads.sourceforge.net%2Fsquirrelmail%2Fsquirrelmail-webmail-1.4.22.tar.gz
wget -O sq.tgz https://squirrelmail.org/countdl.php?fileurl=http%3A%2F%2Fsnapshots.squirrelmail.org%2Fsquirrelmail-20231208_0200-SVN.stable.tar.gz
wget -O sq.tgz https://squirrelmail.org/countdl.php?fileurl=http%3A%2F%2Fsnapshots.squirrelmail.org%2Fsquirrelmail-20231208_0200-SVN.devel.tar.gz
tar xvzf sq.tgz && rm -f sq.tgz
mv squirrelmail* sq ; ls -al 
cd sq ; ls -al 
# locale download
wget -O lc.tgz https://squirrelmail.org/countdl.php?fileurl=http%3A%2F%2Fprdownloads.sourceforge.net%2Fsquirrelmail%2Fall_locales-1.4.18-20090526.tar.gz
tar xvzf lc.tgz && rm -f lc.tgz
ls -al locale
# 
./configure
explorer varWebmailDir


%%% {submenu_lamp}webmail - roundcube [cube]
%%%e {submenu_lamp}webmail - roundcube [cube]
# roundcube - https://roundcube.net/
cd varWebmailDir__@@homein
wget -O rc.tgz https://github.com/roundcube/roundcubemail/releases/download/1.6.5/roundcubemail-1.6.5-complete.tar.gz
tar xvzf rc.tgz && rm -f rc.tgz
mv roundcubemail-1.* rc ; ls -al 
cd rc ; ls -al
# web install 
# http://yourdomain.com/rc/installer/


%%% {submenu_com}nagios cli monitoring [na]
%%%e {submenu_com}nagios cli monitoring [na]
# HOST 의 web/ pop/ imap/ ftp/ ssh/ smtp/ mysql 데몬 구동 체크 
# debian/ubuntu
ay monitoring-plugins
for i in $( dpkg -l |grep monitoring-plugins|awk2) ;do echo;echo $i ; dline ; dpkg -L $i ; done| cgrep "check_" | less -RX
# centos
yy epel-release nagios-plugins-all
for i in $( rpm -qa|grep nagios ) ; do rpm -ql $i ; done | grep "check_"
# cp main check_*
cd /usr/lib64/nagios/plugins/ || cd /usr/lib/nagios/plugins/ ; ls -al 
mkdir -p /root/checkup/ ; cp -a check_http check_pop check_imap check_ftp check_ssh check_smtp check_mysql check_tcp check_ping check_dns check_load /root/checkup/
# 호스트별로 필요한 체크리스트만 뽑아서 softlink
# /root/checkup/yourdomain/check_you_wants
h='varHOST'; mkdir -p "/root/checkup/$h"; scripts=""; PS3="Select for '$h' (num): "; select opt in $(find /root/checkup -maxdepth 1 -name 'check_*' -not -name 'check_tcp' \( -type f -o -type l \) -executable -printf "%f\n" | sort ; echo all ; echo done) ; do case $opt in done) break ;; all) scripts=$(find /root/checkup -maxdepth 1 -name 'check_*' -not -name 'check_tcp' \( -type f -o -type l \) -executable -printf "%f " | sort); scripts="${scripts% }"; echo " -> all selected"; break ;; "") echo "Invalid choice '$REPLY'" ;; *) scripts="$scripts $opt"; echo " -> added $opt" ;; esac; done ; if [[ -n "$scripts" ]]; then echo; echo "Linking selected:"; for s in ${scripts# }; do ln -sv "/root/checkup/$s" "/root/checkup/$h/$s"; done ; echo; ls -l "/root/checkup/$h/" | grep check_; else echo "No scripts selected."; fi
# mysql 모니터링 할 경우 해당 host 에 가서 user 생성 // 안할경우 tcp 3306 포트만 체크
mysql -e "CREATE USER IF NOT EXISTS 'nagios_check'@'%' IDENTIFIED BY 'pw'; GRANT USAGE ON *.* TO 'nagios_check'@'%'; FLUSH PRIVILEGES;" ; ufw allow 3306/tcp ; ufw reload 
change /etc/mysql/mariadb.conf.d/50-server.cnf "bind-address            = 127.0.0.1" "bind-address = 0.0.0.0" line
# 
# 호스트별로 선택한 체크리스트로 점검
while true; do date;  P=/root/checkup; PLUGINS=/usr/lib/nagios/plugins; GREEN='\e[1;32m'; RED='\e[1;31m\a'; YELLOW='\e[1;33m'; RESET='\e[0m'; find "$P" -mindepth 1 -maxdepth 1 -type d | while read -r host_dir; do h=$(basename "$host_dir"); printf "%-20s |" "$h"; find "$host_dir" -maxdepth 1 -type l -executable | while read -r check_link; do check_name=$(basename "$check_link"); target_host="$h"; if [[ "$check_name" == "check_mysql" ]]; then status="?"; color="$RED"; mysql_args=("-H" "$target_host" "-u" "nagios_check" "-p" "pw"); timeout 2 "$PLUGINS/check_mysql" "${mysql_args[@]}" &>/dev/null; mysql_ec=$?; if [ "$mysql_ec" -eq 0 ]; then status="OK"; color="$GREEN"; else timeout 1 "$PLUGINS/check_tcp" -H "$target_host" -p 3306 &>/dev/null; tcp_ec=$?; if [ "$tcp_ec" -eq 0 ]; then status="M(TCP)"; color="$YELLOW"; else if [ "$mysql_ec" -eq 124 ]; then status="T/O(C)"; elif [ "$mysql_ec" -eq 1 ]; then status="WARN"; elif [ "$mysql_ec" -eq 2 ]; then status="CRIT"; else status="UNK"; fi; color="$RED"; fi; fi; echo -ne " ${color}${check_name}:${status}${RESET}"; else status="?"; color="$RED"; cmd_args=(); case "$check_name" in check_load) cmd_args=("-w" "5,4,3" "-c" "10,8,6");; check_tcp) cmd_args=("-H" "$target_host");; check_ping) cmd_args=("-H" "$target_host" "-w" "100,20%" "-c" "500,60%" "-p" "1" "-t" "1");; *) cmd_args=("-H" "$target_host");; esac; "$PLUGINS/$check_name" "${cmd_args[@]}" &>/dev/null; ec=$?; case $ec in 0) status="OK"; color="$GREEN";; 1) status="WARN";; 2) status="CRIT";; *) status="UNK";; esac; echo -ne " ${color}${check_name}:${status}${RESET}"; fi; done; echo; done; echo -n ">>> Quit -> [Anykey] " ; for i in $(seq 1 57); do read -p"." -t1 -n1 x && echo && break; done ; [ "$x" ] && break ; done
explorer /root/checkup/











curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose && ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose



%%% {submenu_docker}docker install / reset [dki]
%%%e {submenu_docker}docker install / reset [dki]
%% dockersvc
yyay apt-transport-https ca-certificates curl gnupg lsb-release
# gpg key add // repo add
: debian_gpg ;curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ; echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list ; vi2 /etc/apt/sources.list.d/docker.list
: ubuntu_gpg ;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ;echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list ; vi2 /etc/apt/sources.list.d/docker.list
# docker install
aptupup ; yyay docker.io  
# group user add
cat /etc/group|grep  "," ;; usermod -aG varGroup__docker varUSER ; vi2 /etc/group
# 
# docker compose install
yyay docker-compose-plugin
curl -L https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose ; ln -s /usr/local/bin/docker-compose /usr/bin/
docker-compose --version
systemctl status docker ; docker --version
#
# docker volume / images list
docker volume ls | awknr2 | awk2
docker images | awknr2 | awk1 
# prune
!!! docker container prune
!!! docker image prune -a
!!! docker network prune
!!! docker volume prune
# docker all stop 
docker stop $( docker ps -a --filter "status=running" |awk1|awknr2 ) ; docker ps -a 
# unused all prune
!!! docker system prune -a 
# 
systemctl disable --now docker



%%% {submenu_docker}docker ps [dkp]
%%%e {submenu_docker}docker ps [dkp]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# docker ps // start // stop 
docker ps 
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker restart $( docker ps -a --filter "status=running" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
# rm
!!! docker ps -a ;; docker rm $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
# image
docker images
!!! docker image rm $( docker images | awk 'NR>1 {print $1}' | pipemenu1cancel ) ; echo ; docker images
# pull
docker pull varCTName__nginx
# volume
docker volume create varDATA__portainer_data
docker volume inspect $( docker volume ls | awknr2|awk2|pipemenu) 
!!! docker volume rm  $( docker volume ls | awknr2|awk2|pipemenu) 
cd /var/lib/docker/volumes ; explorer /var/lib/docker/volumes
# exec -it (interative tty container) 
docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varSH__bash__sh__ash
# inspect
docker ps -a ;; docker inspect $( docker ps -a --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
# top // logs
docker ps ;; docker top $( docker ps --format "{{.Names}}"|pipemenu1 )
docker ps ;; docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )
# network 
docker network ls
docker network ls ;; docker network inspect $( docker network ls | awk 'NR>1 {print $1}' | pipemenu1 ) |cip
#



%%% {submenu_docker}docker search [dks]
%%%e {submenu_docker}docker search [dks]
# stars rank docker-images
curl -s "https://hub.docker.com/v2/repositories/library/?page_size=100" |  jq -r '.results[] | [.name, .star_count, .pull_count, .description] | @tsv' | sort -k 2 -nr|  column -s $'\t' -t | stripe | less -r
docker search varSearch__nginx
docker search varSearch__ubuntu__centos__debian__wordpress__rhymix__cms
# pull image ( 1-100 )
docker pull $( curl -s "https://hub.docker.com/v2/repositories/library/?page_size=100" |  jq -r '.results[] | [.name, .star_count ] | @tsv' | sort -k 2 -nr | awk1 | pipemenucancel )
docker images
!!! docker image rm $( docker images | awk 'NR>1 {print $1}' | pipemenu1cancel ) ; echo ; docker images


%%% {submenu_docker}docker run [dkr]
%%%e {submenu_docker}docker run [dkr]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# portainer 
docker pull portainer/portainer-ce:latest
docker run -d --name portainer --restart on-failure -p varWPORT__9000:9000 -p varBPORT__8000:8000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
# nginx
docker run -d --name nginx -p varPORT__8080:80 nginx
mkdir -p /opt/docker ; docker run -d --name nginx -p varPORT__80:80 -v /opt/docker:/usr/share/nginx/html nginx
# mysql 
docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=varRootPW__wppass -e MYSQL_DATABASE=wp -e MYSQL_USER=wp -e MYSQL_PASSWORD=varPASS__wppass -v mysql_data:/var/lib/mysql mysql
# wordpress
docker run -d --name wp -p varPORT__8888:80 --link mysql:wp -e WORDPRESS_DB_HOST=wp -e WORDPRESS_DB_USER=wp -e WORDPRESS_DB_PASSWORD=varPASS__wppass -e WORDPRESS_DB_NAME=wp -v wordpress_data:/var/www/html wordpress
# minecraft
docker run -d --name mcserver --rm -e MEMORYSIZE='varMEM__1G' -v mc_data:/data:rw -p varPORT__25565:25565 -i marctv/minecraft-papermc-server:latest
# phpmyadmin ( depend on running db ) 
docker run --name mypma --rm -d --link $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ):db -p varPORT__3307:80 phpmyadmin/phpmyadmin
# phpmyadmin ( all host ) 
docker run --name mypmaall --rm -d -e PMA_ARBITRARY=1 -p varPORT__3300:80 phpmyadmin
# derkades/webdav
mkdir -p varMountPath__@@data@@webdav ; docker run -d --name webdav-instance --restart=unless-stopped -v varMountPath__@@data@@webdav:/data -p varPORT__8010:80 -e USERNAME=varUSER__admin -e PASSWORD=varPASS__gosh derkades/webdav
# wetty web-ssh 
docker run --name Wetty -d --rm -p 3000:3000 wettyoss/wetty --ssh-host $publicip --ssh-port 22 --base
#
# docker ps // start // stop // rm
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
!!! docker ps -a ;; docker rm $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps



%%% {submenu_docker}docker linux [dkl]
%%%e {submenu_docker}docker linux [dkl]
%% dockersvc
# linux docker image
docker run -it ubuntu bash
docker run -it centos bash
docker run -it debian bash
docker run -it fedora bash
# node.js ...
docker run -it node bash
docker run -it python bash
docker run -it mysql bash
docker run -it redis bash
docker run -it nginx bash




%%% {submenu_docker}docker teldrive [dkt]
%%%e {submenu_docker}docker teldrive [dkt]
%% echo "tg-uploads-encryption-key: ${tguploadsencryptionkey}"
%% echo "tg-jwtsecret: ${jwtsecret}"
%% echo "tg-app-id: ${telegramappid}"
%% echo "tg-app-hash: ${telegramapphash}"
# telegram api app_id, app_hash
# https://my.telegram.org/auth?to=myapp
# 차단될 수 있으니, 주사용 telegram 아이디는 주의
# teldrive daemon 운영 희망시 --> tel [Enter]
mkdir -p varDIR__@@data@@teldrive ; cd varDIR ; ls -al
mkdir -p varDIR__@@data@@teldrive@@{teldrive_data,postgres_data} ; cd varDIR ; ls -al
explorer varDIR
# teldrive
docker network create teldrive-net
docker run -d --name postgres-db --net teldrive-net -p 5432:5432 -v ./postgres_data:/var/lib/postgresql/data -e POSTGRES_USER=teldrive -e POSTGRES_PASSWORD=password -e POSTGRES_DB=teldrive iquiw/pgroonga-on-postgres:latest
docker run -d --name teldrive -p 8080:8080 --net teldrive-net -v ./teldrive_data:/data teldrive/teldrive:latest --db-data-source "postgres://teldrive:password@postgres-db:5432/teldrive?sslmode=disable" --jwt-secret "$jwtsecret" --tg-app-id "$telegramappid" --tg-app-hash "$telegramapphash" --tg-uploads-encryption-key "$tguploadsencryptionkey"
#
docker restart teldrive
docker stop postgres-db ; docker rm postgres-db
docker stop teldrive ; docker rm teldrive 
docker logs postgres-db
docker logs teldrive
# 
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1cancel )
docker exec -it $( docker ps -a --format "{{.Names}}"|pipemenu1cancel ) varCMD__bash__sh__ash
# env
echo "tguploadsencryptionkey=$(openssl rand -hex 32)" >> ~/go.private.env
echo "jwtsecret=$(openssl rand -hex 32)" >> ~/go.private.env
echo "telegramappid=varAppID" >> ~/go.private.env
echo "telegramapphash=varAppHash" >> ~/go.private.env
source ~/go.private.env
env | sort | cpipe | less -rX



%%% {submenu_docker}docker compose ansible webui semaphore [dkse]
%%%e {submenu_docker}docker compose ansible webui semaphore [dkse]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@semaphore"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/semaphore}/
cd ${varl1:-/data/semaphore} ; ls -al ${varl1:-/data/semaphore} 
cat ${varl1:-/data/semaphore}/docker-compose.yml
#
!!! template_copy semaphore.yml ${varl1:-/data/semaphore}/docker-compose.yml ; cat ${varl1:-/data/semaphore}/docker-compose.yml
vi2 ${varl1:-/data/semaphore}/docker-compose.yml
# IP:3000 admin / changeme
cd ${varl1:-/data/semaphore}; docker-compose ps
cd ${varl1:-/data/semaphore}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/semaphore}; docker-compose logs -f 
cd ${varl1:-/data/semaphore}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/semaphore}; docker-compose down
!!! cd ${varl1:-/data/semaphore}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker logs --tail 50 -f $( docker ps --format "{{.Names}}"|pipemenu1 )




%%% {submenu_docker}docker compose nagios [dkna]
%%%e {submenu_docker}docker compose nagios [dkna]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@nagios"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/nagios}/{nagios/{etc,var},custom-plugins,nagiosgraph/{var,etc}}
cd ${varl1:-/data/nagios} ; ls -al ${varl1:-/data/nagios} 
cat ${varl1:-/data/nagios}/docker-compose.yml
#
!!! template_copy nagios.yml ${varl1:-/data/nagios}/docker-compose.yml ; cat ${varl1:-/data/nagios}/docker-compose.yml
vi2 ${varl1:-/data/nagios}/docker-compose.yml
# nagiosadmin / nagios
cd ${varl1:-/data/nagios}; docker-compose ps
cd ${varl1:-/data/nagios}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/nagios}; docker-compose logs -f 
cd ${varl1:-/data/nagios}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/nagios}; docker-compose down
!!! cd ${varl1:-/data/nagios}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 




%%% {submenu_docker}docker compose Rocket.Chat [dkro]
%%%e {submenu_docker}docker compose Rocket.Chat [dkro]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@rocketchat"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/rocketchat}/{uploads,data/db,data/dump}
cd ${varl1:-/data/rocketchat} ; ls -al ${varl1:-/data/rocketchat} 
cat ${varl1:-/data/rocketchat}/docker-compose.yml
#
template_edit rocketchat.yml
template_view rocketchat.yml
!!! template_copy rocketchat.yml ${varl1:-/data/rocketchat}/docker-compose.yml ; vi2 ${varl1:-/data/rocketchat}/docker-compose.yml
!!! curl -L https://go.rocket.chat/i/docker-compose.yml -o ${varl1:-/data/rocketchat}/docker-compose.yml
vi2 ${varl1:-/data/rocketchat}/docker-compose.yml
#
cd ${varl1:-/data/rocketchat}; docker-compose ps
cd ${varl1:-/data/rocketchat}; docker-compose up -d --remove-orphans
cd ${varl1:-/data/rocketchat}; docker-compose logs -f 
cd ${varl1:-/data/rocketchat}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varCMD__sh
cd ${varl1:-/data/rocketchat}; docker-compose down
!!! cd ${varl1:-/data/rocketchat}; docker-compose down -v
#
cd ${varl1:-/data/rocketchat}; docker-compose exec mongo mongosh --eval "rs.initiate()"
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 



%%% {submenu_docker}docker compose wg-easy wireguard [dkw]
%%%e {submenu_docker}docker compose wg-easy wireguard [dkw]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@wireguard"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/wireguard}/data
cd ${varl1:-/data/wireguard}/data ; ls -al ${varl1:-/data/wireguard} ${varl1:-/data/wireguard}/data
cat ${varl1:-/data/wireguard}/docker-compose.yml
#
!!! template_copy wireguard.yml ${varl1:-/data/wireguard}/docker-compose.yml ; vi2 ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's/ WG_HOST=.*/ WG_HOST='"$publicip"'/' ${varl1:-/data/wireguard}/docker-compose.yml
hostname ; readx ; sed -i 's/ WG_HOST=.*/ WG_HOST='"$(hostname)"'/' ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's/PASSWORD=.*$/PASSWORD='varPASSWORD'/' ${varl1:-/data/wireguard}/docker-compose.yml
sed -i 's|- /data/wireguard/data|- '"${varl1:-/data/wireguard}"'/data|g' ${varl1:-/data/wireguard}/docker-compose.yml
vi2 ${varl1:-/data/wireguard}/docker-compose.yml
#
cd ${varl1:-/data/wireguard}/data ; docker-compose ps
cd ${varl1:-/data/wireguard}/data ; docker-compose up -d
# key // eth0(vpn->outbound->proxmox->vmbr0.edit) check
vi2 ${varl1:-/data/wireguard}/data/wg0.conf
cd ${varl1:-/data/wireguard}; docker-compose exec wg genkey | tee wg pubkey
cd ${varl1:-/data/wireguard}; docker-compose logs -f 
cd ${varl1:-/data/wireguard}/data ; docker-compose down
!!! cd ${varl1:-/data/wireguard}/data ; docker-compose down -v
#
echo "http://$publicip:51821"
# nat table check 
GREEN=$(tput setaf 6);RESET=$(tput sgr0);iptables-save -t nat | awk -v green="$GREEN" -v reset="$RESET" '/^-A/ {print $0; gsub("-A", "-D"); print green "iptables -t nat " $0 reset}'
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 


%%% {submenu_docker}docker compose rhymix/nginx/mariadb [dkrm]
%%%e {submenu_docker}docker compose rhymix/nginx/mariadb [dkrm]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@rhymix"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/rhymix}
cd ${varl1:-/data/rhymix}; ls -al ${varl1:-/data/rhymix}
cd $( dirname ${varl1:-/data/rhymix} ) ; git clone https://github.com/devjiro76/rhymix_docker.git rhymix 
# 서비스 포트 수정 
vi2 ${varl1:-/data/rhymix}/docker-compose.yml
explorer ${varl1:-/data/rhymix}/
cd ${varl1:-/data/rhymix}; vi2 init.sh
# php7.1 -> 7.4up
!!! template_copy php74.docker.yml ${varl1:-/data/rhymix}/dockers/php-fpm/Dockerfile
cd ${varl1:-/data/rhymix}; sh init.sh
# /usr/share/nginx/html/common/manual/server_config/rhymix-nginx.conf: 최하단 location / 범위 주석
cd ${varl1:-/data/rhymix}; vi2 web/common/manual/server_config/rhymix-nginx.conf
#
cd ${varl1:-/data/rhymix}; docker-compose ps
cd ${varl1:-/data/rhymix}; docker-compose up -d
cd ${varl1:-/data/rhymix}; docker-compose logs -f 
cd ${varl1:-/data/rhymix}; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Image}}"|pipemenu1cancel ) varCmd__sh
docker run -it $( docker ps -a --filter "status=running" --format "{{.Image}}"|pipemenu1cancel ) varCmd__sh
cd ${varl1:-/data/rhymix}; docker-compose down
!!! cd ${varl1:-/data/rhymix}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 



%%% {submenu_docker}docker compose wordpress / phpmyadmin [dkwp]
%%%e {submenu_docker}docker compose wordpress / phpmyadmin [dkwp]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@wordpress"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/wordpress}/{db,data}
cd ${varl1:-/data/wordpress}; ls -al ${varl1:-/data/wordpress}
cat ${varl1:-/data/wordpress}/docker-compose.yml
#
# template -> wp:latest / mysql:latest / phpmyadmin
template_edit wordpress.yml
template_view wordpress.yml
!!! template_copy wordpress.yml ${varl1:-/data/wordpress}/docker-compose.yml ; cat ${varl1:-/data/wordpress}/docker-compose.yml
sed -i 's|VOLUMEPATH|'"${varl1:-/data/wordpress}"'/data|g' ${varl1:-/data/wordpress}/docker-compose.yml
sed -i 's|- "8080:80"|- "varPORT:80"|g' ${varl1:-/data/wordpress}/docker-compose.yml
vi2 ${varl1:-/data/wordpress}/docker-compose.yml
#
cd ${varl1:-/data/wordpress}; docker-compose ps
cd ${varl1:-/data/wordpress}; docker-compose up -d
cd ${varl1:-/data/wordpress}; docker-compose logs -f 
cd ${varl1:-/data/wordpress}; docker-compose down
!!! cd ${varl1:-/data/wordpress}; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps 


%%% {submenu_docker}docker compose immich [dkim]
%%%e {submenu_docker}docker compose immich [dkim]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@im"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/im}/photos ; cd $varl1 
git clone https://github.com/immich-app/immich.git ; push ; ls -al
explorer ${varl1:-/data/im}
cd ${varl1:-/data/im}/immich
cd ${varl1:-/data/im}/immich/docker ; cp example.env .env 
# 환경파일 수정 
sed -i 's|UPLOAD_LOCATION=.*$|UPLOAD_LOCATION='"${varl1:-/data/im}"'/varUPLOAD__photos|g' ${varl1:-/data/im}/immich/docker/.env
vi2 ${varl1:-/data/im}/immich/docker/.env
# 버젼 업데이트: docker down -> .env 버젼수정 -> docker pull -> docker up -d
cd ${varl1:-/data/im}/immich/docker ; docker-compose down && docker-compose pull && docker-compose up -d
#
cd ${varl1:-/data/im}/immich/docker ; docker-compose ps
cd ${varl1:-/data/im}/immich/docker ; docker-compose up -d
cd ${varl1:-/data/im}/immich/docker ; docker-compose restart $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel )
cd ${varl1:-/data/im}/immich/docker ; docker-compose down
cd ${varl1:-/data/im}/immich/docker ; docker-compose pull
!!! cd ${varl1:-/data/im}/immich/docker ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps





%%% {submenu_docker}docker compose traefik [dktf]
%%%e {submenu_docker}docker compose traefik [dktf]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@traefik"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/traefik}/data
cd ${varl1:-/data/traefik}/data ; ls -al ${varl1:-/data/traefik} ${varl1:-/data/traefik}/data
cat ${varl1:-/data/traefik}/docker-compose.yml
#
# template -> 
!!! template_copy traefik.yml ${varl1:-/data/traefik}/docker-compose.yml ; cat ${varl1:-/data/traefik}/docker-compose.yml
vi2 ${varl1:-/data/traefik}/docker-compose.yml
#
cd ${varl1:-/data/traefik}/data ; docker-compose ps
cd ${varl1:-/data/traefik}/data ; docker-compose up -d
cd ${varl1:-/data/traefik}/data ; docker-compose restart $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel )
cd ${varl1:-/data/traefik}/data ; docker-compose down
!!! cd ${varl1:-/data/traefik}/data ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps




%%% {submenu_docker}docker compose guacamole [dkg]
%%%e {submenu_docker}docker compose guacamole [dkg]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@guacamole"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/guacamole}/data
cd ${varl1:-/data/guacamole}/data ; ls -al ${varl1:-/data/guacamole} ${varl1:-/data/guacamole}/data
# git clone 
git clone "https://github.com/boschkundendienst/guacamole-docker-compose.git" 
cd guacamole-docker-compose && ./prepare.sh
cd ${varl1:-/data/guacamole}/data ; mv guacamole-docker-compose/* ..
cat ${varl1:-/data/guacamole}/docker-compose.yml
#
vi2 ${varl1:-/data/guacamole}/docker-compose.yml
#
# guacamole guacd nginx postgres 
# https://publicip:8443 (guacadmin/guacadmin)
#
cd ${varl1:-/data/guacamole}/data ; docker-compose ps
cd ${varl1:-/data/guacamole}/data ; docker-compose up -d
cd ${varl1:-/data/quacamole}/data ; docker-compose restart $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel )
cd ${varl1:-/data/guacamole}/data ; docker-compose down
!!! cd ${varl1:-/data/guacamole}/data ; docker-compose down -v
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps



%%% {submenu_docker}docker compose home assistant os [dkha]
%%%e {submenu_docker}docker compose home assistant os [dkha]
%% dockersvc
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@haos"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/haos}/config
cd ${varl1:-/data/haos}/ ; ls -al ${varl1:-/data/haos}/ 
#
# template 
!!! template_copy haos.yml ${varl1:-/data/haos}/docker-compose.yml ; cat ${varl1:-/data/haos}/docker-compose.yml
vi2 ${varl1:-/data/haos}/docker-compose.yml
# http://yourdomain.com:8123
cd ${varl1:-/data/haos}/ ; docker-compose ps
cd ${varl1:-/data/haos}/ ; docker-compose up -d
cd ${varl1:-/data/haos}/ ; docker-compose logs -f 
cd ${varl1:-/data/haos}/ ; docker-compose down
!!! cd ${varl1:-/data/haos}/ ; docker-compose down -v
cd ${varl1:-/data/haos}/ ; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varSH__bash
#
curl $( echo localhost localhost/index.php $HOSTNAME |pipemenu):varPORT__80 





%%% {submenu_docker}docker compose nginx-proxy-manager [dknpm]
%%%e {submenu_docker}docker compose nginx-proxy-manager [dknpm]
%% dockersvc
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@npm"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/npm}/{data,letsencrypt} 
cd ${varl1:-/data/npm}/ ; ls -al ${varl1:-/data/npm}/ 
explorer ${varl1}
# https://github.com/NginxProxyManager/nginx-proxy-manager
# template -> nginx-proxy-manager.yml
template_view nginx-proxy-manager.yml
!!! template_copy nginx-proxy-manager.yml ${varl1:-/data/npm}/docker-compose.yml ; cat ${varl1:-/data/npm}/docker-compose.yml
vi2 ${varl1:-/data/npm}/docker-compose.yml
# http://yourdomain.com:81 -> admin@example.com // changeme
cd ${varl1:-/data/npm}/ ; docker-compose ps
cd ${varl1:-/data/npm}/ ; docker-compose up -d
cd ${varl1:-/data/npm}/ ; docker-compose logs -f 
cd ${varl1:-/data/npm}/ ; docker-compose down
!!! cd ${varl1:-/data/npm}/ ; docker-compose down -v
cd ${varl1:-/data/npm}/ ; docker-compose exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) varSH__bash
#
curl $( echo localhost localhost/index.php $HOSTNAME |pipemenu):varPORT__80 







%%% {submenu_docker}docker compose next-cloud [dkc]
%%%e {submenu_docker}docker compose next-cloud [dkc]
%% dockersvc
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@nextcloud"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/nextcloud}/{nextcloud,apps,config,data,theme}
cd ${varl1:-/data/nextcloud}/ ; ls -al ${varl1:-/data/nextcloud}/ ${varl1:-/data/nextcloud}/*
cat ${varl1:-/data/nextcloud}/docker-compose.yml
#
# template -> nextcloud,mariadb,tikaserver,elasticsearch
!!! template_copy nextcloud.yml ${varl1:-/data/nextcloud}/docker-compose.yml ; cat ${varl1:-/data/nextcloud}/docker-compose.yml
# 
vi2 ${varl1:-/data/nextcloud}/docker-compose.yml
#
cd ${varl1:-/data/nextcloud}/ ; docker-compose ps
cd ${varl1:-/data/nextcloud}/ ; docker-compose up -d
cd ${varl1:-/data/nextcloud}/ ; docker-compose down
cd ${varl1:-/data/nextcloud}/ ; docker-compose exec nextcloud bash
!!! cd ${varl1:-/data/nextcloud}/ ; docker-compose down -v
#
curl $( echo localhost localhost/index.php localhost/phpmyadmin localhost:3300 $HOSTNAME |pipemenu) 
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps





%%% {submenu_docker}docker compose caddy [dkca]
%%%e {submenu_docker}docker compose caddy [dkca]
%% dockersvc
%% [ "$mydomain" ] && echo "mydomain: $mydomain"
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
# 공사중
# 내도메인 정보 환경파일에 넣거나 직접 입력 
[ ! "$mydomain" ] && echo "mydomain=varMyDomain" >> ~/go.private.env && . ~/go.private.env
export mydomain=varMyDomain
# 설치경로를 varl1 에 설정하고 진행 
exportvar varl "varDataPATH__@@data@@caddy"; cd $varl1
unsetvar varl 
mkdir -p ${varl1:-/data/caddy}/site 
cd ${varl1:-/data/caddy}
ls -al ${varl1:-/data/caddy}/ ${varl1:-/data/caddy}/*
cat ${varl1:-/data/caddy}/docker-compose.yml
#
# template -> caddy.yml Caddyfile
!!! template_copy caddy.yml ${varl1:-/data/caddy}/docker-compose.yml ; cat ${varl1:-/data/caddy}/docker-compose.yml
!!! template_copy caddyfile.yml ${varl1:-/data/caddy}/Caddyfile ; cat ${varl1:-/data/caddy}/Caddyfile
sed -i 's|example.com|varYourDomain|g' ${varl1:-/data/caddy}/Caddyfile ; cat ${varl1:-/data/caddy}/Caddyfile
!!! rbackup ${varl1:-/data/caddy}/site/index.html && echo -e "hi caddy" > ${varl1:-/data/caddy}/site/index.html ; cat ${varl1:-/data/caddy}/site/index.html
#
vi2 ${varl1:-/data/caddy}/docker-compose.yml
vi2 ${varl1:-/data/caddy}/Caddyfile
vi2 ${varl1:-/data/caddy}/site/index.html
#
cd ${varl1:-/data/caddy}; docker-compose ps
cd ${varl1:-/data/caddy}; docker-compose up -d
cd ${varl1:-/data/caddy}; docker-compose down
cd ${varl1:-/data/caddy}; docker-compose logs -f
!!! cd ${varl1:-/data/caddy}; docker-compose down -v
#
docker exec -it $( docker ps -a --filter "status=running" --format "{{.Names}}"|pipemenu1cancel ) ash
#
curl $( echo https://localhost localhost/index.html http://$mydomain https://$mydomain| pipemenu) 
#
docker ps
docker start $( docker ps -a --filter "status=exited" --filter 'status=created' --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps
docker stop $( docker ps --format "{{.Names}}"|pipemenu1cancel ) ;echo; docker ps















%%% {submenu_com}ansible 관리 자동화 [ansible]
%%%e {submenu_com}ansible Management Automation [ansible]
# python3 와 ssh 를 이용하여 서버관리 자동화
# 가상환경의 경우 ansible 위치 조정 
source ansible_venv/bin/activate
echo "source ansible_venv/bin/activate" >> ~/.bashrc
# 
# hosts
rbackup /etc/ansible/hosts ; mkdir -p /etc/ansible/ ; echo "127.0.0.1" > /etc/ansible/hosts
# example hosts
echo -e "google.byus.net\n\n[web]\ng1.byus.net\ng2.byus.net\nhh.byus.net\n\n[db]\nhh.byus.net" >> /etc/ansible/hosts ; cat /etc/ansible/hosts
vi2 /etc/ansible/hosts
# hosts 에 지정된 서버는 ssh 공개키를 심어서 비번없이 로그인이 가능한 상태로 설정
#
ansible all -m ping 
ansible web -m ping
# 
ansible all -a "bash -c 'hostname && pstree && sleep 2'"
ansible all -a "bash -c 'varCommands'"
# 서버 모든 정보 확인 
ansible web -m setup
ansible all -m setup -a "filter=ansible_dist*"
# install sample
!!! template_copy playbook.yml ~/nginx_install.yml ; cat ~/nginx_install.yml 
vi2 varPlaybookPATH__@@root@@nginx_install.yml ; ansible-playbook varPlaybookPATH__@@root@@nginx_install.yml
# script exec sample
!!! template_copy playbook_script.yml ~/playbook_script.yml ; cat ~/playbook_script.yml
echo "pstree; ps -ef |grep -E \"ssh|go.sh\"" > /root/pstree.sample.sh
vi2 varPlaybookPATH__@@root@@playbook_script.yml ; ansible-playbook varPlaybookPATH__@@root@@playbook_script.yml 
#
vi2 varPlaybookPATH ;; ansible-playbook varPlaybookPATH
#
#
ansible --version  
explorer $HOME/ansible_venv/
# install
yyay python3 
yyay ansible
# 가상환경일때 install
yyay python3-venv
python3 -m venv ansible_venv
pip install ansible




%%% {submenu_com}GitHub / Git [git]
%%%e {submenu_com}GitHub / Git [git]
# clone
cd varDIR__@@root
git clone varProjectURL
# init && push
mkdir -p $HOME/varProjectDIR__git_project && cd $HOME/varProjectDIR__git_project
cd $HOME/varProjectDIR
git init ; ls -al
git remote add origin https://github.com/varName/varProjectDIR
git add .
git commit -m "varCommit"
git branch -M main 
git push -u origin main
# edit
git add varFILE
git commit -m "varCommitEdit"
git push -u origin main
# branch
git branch
git branch varNewBranch
git checkout -b varBranch
git branch -d varBranch
# push_branch
git add .
git commit -m "varCommitEdit"
git push -u origin varBranch
#
# install && config https://github.com/ (account+)
yyay git ; echo ; git --version
git config --global user.name varName
git config --global user.email varEmail
git config --list
explorer $HOME/.gitconfig







%%% {submenu_hidden}java/ php/ perl/ python [java]
%%%e {submenu_hidden}java/ php/ perl/ python [java]
# apache2-utils
htpasswd -nb varAdmin__admin varPW__web_auth_pw || yyay apache2-utils
# java
yyay openjdk-17-jdk
# jdk8 repo
sudo echo "deb http://ftp.debian.org/debian stretch-backports main" | sudo tee -a /etc/apt/sources.list.d/stretch-backports.list ;
sudo echo "deb http://deb.debian.org/debian oldoldstable main" | sudo tee -a /etc/apt/sources.list.d/bookworm-oldoldstable.list
echo "deb http://deb.debian.org/debian/ oldoldstable main" >> /etc/apt/sources.list 
add-apt-repository ppa:webupd8team/java
vi2 /etc/apt/sources.list 
aptupup
yyay -t stretch-backports openjdk-8-jdk
yyay openjdk-8-jdk
yyay oracle-java8-installer
# default java setting
which java
update-alternatives --list java
sudo update-alternatives --config java
# linux_version check
lsb_release -a


%%% {submenu_sys}annyung3 linux (centos7 base) [an3]
%%%e {submenu_sys}annyung3 linux (centos7 base) [an3]
# centos7 minimal 설치후 an3 로 변경
# https://joungkyun.gitbook.io/annyung3-installation-guide/chapter1
yum install -y perl
cd ; curl -o bootstrap $( echo http://mirror.oops.org/pub/AnNyung/3/inst/bootstrap http://ftp.kr.freebsd.org/pub/AnNyung/3/inst/bootstrap | pipemenu) 
bash $HOME/bootstrap
vi2 $HOME/bootstrap
vi2 /usr/share/AnNyung/functions
yum -y update
# oops-firewall 
yum -y install kmod-geoip
# geoip download & database
cd /usr/share/GeoIP ; curl -O http://mirror.oops.org/pub/Security/GeoIP-Legacy/GeoIPCountryWhois.csv ; curl -O http://mirror.oops.org/pub/Security/GeoIP-Legacy/GeoIPv6.csv ; /usr/bin/geoip-csv2bin 1 ; ls -al
# ex) RU/CN ban , ssh KR only
echo "%-A INPUT -m geoip --src-cc RU -j DROP" >> /etc/oops-firewall/user.conf 
echo "%-A INPUT -m geoip --src-cc CN -j DROP" >> /etc/oops-firewall/user.conf 
echo "%-A INPUT -p tcp --dport 22 -m geoip ! --src-cc KR -j DROP" >> /etc/oops-firewall/user.conf
vi2 /etc/oops-firewall/user.conf
systemctl restart oops-firewall
systemctl enable oops-firewall ; systemctl start oops-firewall ; systemctl status oops-firewall
systemctl status oops-firewall
# repo list 
for repo in $(yum repolist 2>/dev/null | awk '$1 == "*" {print $2}' | sed 's/:$//'); do filename=$(echo $repo | sed 's/://g') ; yum --disablerepo='*' --enablerepo="$repo" list available 2>/dev/null > "/root/${filename}.repo.list.txt" ; done ; cat /root/AN*.list.txt | sort -u > /root/AN.repo.list.txt.all ; ls -al /root/*.repo.list.txt*
vi2 $( ls -1 /root/*.list.txt /root/*.list.txt.all | pipemenu )
grep -i "varSearch" /root/*.repo.list.txt | cgrep varSearch
yum -y install varPackage
yy lynx wget curl 
explorer /etc/yum.repos.d/


%%% {submenu_sys}annyung2 linux (centos6 base) vault.repo set [an2]
%%%e {submenu_sys}annyung2 linux (centos6 base) vault.repo set [an2]
# fast mirror enable -> 0 
vi2 /etc/yum/pluginconf.d/fastestmirror.conf 
# 기존 repolist 백업 
mkdir -p /etc/yum.repos.d/backup-repo && mv /etc/yum.repos.d/CentOS-*.repo* /etc/yum.repos.d/backup-repo/
# fast jp server set
!!! template_copy centos-vault.repo /etc/yum.repos.d/centos-vault.repo
vi2 /etc/yum.repos.d/centos-vault.repo
# or default vault server set
!!! template_copy vault.repo /etc/yum.repos.d/centos-vault.repo
vi2 /etc/yum.repos.d/centos-vault.repo
# epel6 기존 백업및 archive repo 갱신
mv /etc/yum.repos.d/epel*.repo* /etc/yum.repos.d/backup-repo/
!!! template_copy epel6.repo /etc/yum.repos.d/epel6.repo
vi2 /etc/yum.repos.d/epel6.repo
# 
yum clean all ; yum repolist
yum update
explorer /etc/yum.repos.d/
# centos6 ranger install (epel6 base)
yy zstd ranger 
# centos6 ranger install (python2 base)
yy git 
cd /backup ; git clone https://github.com/ranger/ranger.git
cd ranger ; git checkout v1.8.1 ; make install






%%% {submenu_sys}annyung1 linux (centos5 base) [an]
%%%e {submenu_sys}annyung1 linux (centos5 base) [an]
pkgdb -v
pkgsysupdate -v
pkgkernel -v
pkgkernel -i varKernel__kernel-bigmem
!!! pkgkernel -r varA 
pkginfo -l > /root/pkginfo.txt ; cat /root/pkginfo.txt | less -RX 
vi2 /root/pkginfo.txt
# pkg install
pkgadd -u $( cat /root/pkginfo.txt |grep "설치 안됨"|awk '{print $1}'|sort -u| pipemenu )
pkgadd -u varPKGname
rpm -ql varPKGname
# apm
pkginfo -l -v varPKGname__apache
pkginfo -l -v php
pkginfo -l -v mysql
# daemon set
ntsysv
vi2 /etc/sysconfig/mysql
vi2 /etc/sysconfig/i18n
vi2 /etc/sysconfig/hwconf
explorer /etc/
# etc
[ ! "$(grep "/bin/pass" /etc/shells)" ] && echo "/bin/pass" >> /etc/shells



%%% {submenu_sys}epel repo add [epel]
%%%e {submenu_sys}epel repo add [epel]
# EPEL 는 RHEL/CentOS의 일부가 아니지만 모니터링등 많은 오픈 소스
# 패키지를 제공하여 주요 Linux 배포판용으로 설계. 
#
# CentOS 7
yum install epel-release
# CentOS 6 (expired) -> epel6 기존 백업및 archive repo 갱신
mkdir -p /etc/yum.repos.d/backup-repo ; mv /etc/yum.repos.d/epel*.repo* /etc/yum.repos.d/backup-repo/
!!! template_copy epel6.repo /etc/yum.repos.d/epel6.repo
vi2 /etc/yum.repos.d/epel6.repo
# RHEL 9
subscription-manager repos --enable codeready-builder-for-rhel-9-$(arch)-rpms
dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
# RHEL 8
subscription-manager repos --enable codeready-builder-for-rhel-8-$(arch)-rpms
dnf install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm
# Rocky/AlmaLinux 9
dnf config-manager --set-enabled crb
dnf install epel-release
# Rocky/AlmaLinux 8
dnf config-manager --set-enabled powertools
dnf install epel-release
#
yum clean all ; yum repolist
yum update




%%% {submenu_com}irc chat [irc]
%%%e {submenu_com}irc chat [irc]
irssi
# irssi config
mkdir -p ~/.irssi/ ; echo -e 'servers = (\n  {\n    address = "varIRCServer__irc.dankun.net";\n    chatnet = "Dankun";\n    port = "6667";\n    password = "";\n    use_ssl = "no";\n    ssl_verify = "no";\n    autoconnect = "yes";\n  }\n);\n\nchatnets = {\n  Dankun = {\n    type = "IRC";\n    nick = "varNick";\n    autosendcmd = "/join #gosh";\n  };\n};\n\nsettings = {\n  core = { real_name = "varNick"; user_name = "varNick"; nick = "varNick"; };\n};' > ~/.irssi/config
vi2 ~/.irssi/config
# irc client install
yyay irssi 


%%% {submenu_com}termux (android-linux) [ter]
%%%e {submenu_com}termux (android-linux) [ter]
# https://f-droid.org/repo/com.termux_118.apk
termux-wake-lock ; termux-setup-storage 
( whoami ; ifconfig ; curl ifconfig.me ) | push
whoami ; passwd
# termux 실행시 sshd / crond 구동 .bashrc
echo -e 'termux-wake-lock\n(( $(ps -ef|grep -c [s]shd ) == 0 )) && sshd\n(( $(ps -ef|grep -c [c]rond ) == 0 )) && crond\n' >> $HOME/.bashrc ; echo -e 'export VISUAL=vim; export EDITOR="$VISUAL"' >> ~/.bashrc ; echo -e "alias l='ls'\nalias ll='ls -l'\nalias la='ls -al'\nalias go='bash $HOME/go.sh'" >> $HOME/.bashrc 
ln -s /data/data/com/termux/files/usr $HOME/root ; ln -s /data/data/com/termux/files/usr/etc $HOME/etc ; ln -s /data/data/com/termux/files/usr/var $HOME/var ; ln -s /data/data/com/termux/files/usr/spool/cron $HOME/cron ; ln -s /data/data/com/termux/files/usr/tmp $HOME/tmp 
# ssh
vi2 $( echo $HOME/.bashrc $HOME/.ssh/config $HOME/etc/ssh/sshd_config $HOME/cron/$(whoami) | pipemenu )
!!! pkill sshd; sshd
ps -ef|grep -E "sshd|crond|autossh"
(( $(ps -ef|grep -c [s]shd ) == 0 )) && sshd ; (( $(ps -ef|grep -c [c]rond ) == 0 )) && crond ; (( $(ps -ef|grep -c [a]utossh ) == 0 )) && [ -f $HOME/.termux/boot/autossh.sh ] && bash $HOME/.termux/boot/autossh.sh
# pkg
pkg update -y ; pkg upgrade -y
pkg list-all > $HOME/pkglist.txt ; vi2 $HOME/pkglist.txt
cat $HOME/pkglist.txt |grep varSEARCH
pkg install -y varPKG
pkg install -y vim wget proot openssh termux-api autossh termux-services python ranger
pkg list-installed
# termux-setup-storage
explorer /data/data/com.termux/files/home/storage/downloads/ 
# 외부에서 스마트폰 ssh 접속 key set
ssh-copy-id -p 8022 -i id_rsa.pub varTerMuxHOST
ssh -p 8022 varTermuxUser@varTerMuxHOST
# 역터널링 설정(외부에서 폰:8022 접속) 공인ip접근시 공유기포트포워딩
ssh -f -N -R varPORT__2222:localhost:8022 root@varRemotehost -o ServerAliveInterval=60 -o ServerAliveCountMax=1440 
# 역터널링 접속 스크립트 전송
echo "ssh $(whoami)@localhost -p varPORT__2222" | ssh root@varRemotehost "cat > $HOME/termux.con.sh"
# 리모트 서버에서 termux 서버 접속 
cat $HOME/termux.con.sh && readx &&  eval $(cat $HOME/termux.con.sh )
# 역터널링 해제 ( 리모트 or termux 로컬 )
lsof -i:varPORT__2222 | awknr2 | awk2 | xargs kill 
lsof -i:varPORT__8022 | awknr2 | awk2 | xargs kill 
# 역터널링 autossh runit sv add 
mkdir -p /data/data/com.termux/files/usr/var/service/autossh/ && echo -e "#!/data/data/com.termux/files/usr/bin/sh\nexec autossh -M 0 -N -R varPORT__2222:localhost:8022 root@varRemotehost" > /data/data/com.termux/files/usr/var/service/autossh/run ; chmod +x /data/data/com.termux/files/usr/var/service/autossh/run
# runit
svc=$( echo autossh crond sshd | pipemenu ) ;; sv-enable $svc ; sv up $svc
svc=$( echo autossh crond sshd | pipemenu ) ;; sv-disable $svc ; sv down $svc
svc=$( echo autossh crond sshd | pipemenu ) ;; sv status $svc
pkg install -y runit
explorer /data/data/com.termux/files/usr/var/service/





# out
export rootpart=varRhostRootpartiton ; export rootpartnew=${rootpart//sda/sdb}
export bootpart=varRhostBootpartiton__@@dev@@sda1 ; export bootpartnew=${bootpart//sda/sdb}
: !검토 tgz ; echo "time ssh $rhost \"tar czfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / \" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | tar xzfp - -C /mnt/$(basename $rootpartnew)/"


%%% {submenu_sys}물리서버->가상서버 online migration [p2v]
%%%e {submenu_sys}Physical Server to Virtual Server Online Migration [p2v]
%% echo "host:$rhost boot:$bootpart bootnew:$bootpartnew root:$rootpart rootnew:$rootpartnew rootpartsize=${rootpartsize}M"
# 가상서버에 쓰일 sda 를 임시 리눅스 sdb 에 연결후 임시 리눅스에서 p2v 작업
# 물리서버 호스트/부트파티션/루트파티션 설정 (ex.abc.com /dev/sda1 /dev/sda7)
export rhost=varRhost
ssh $rhost "fdisk -l;echo;df" ; echo ; fdisk -l /dev/sdb
# root boot 지정
export rootpart=$( ssh $rhost "df" | awk '$6 == "/" {print $1}') ; export rootpartnew=${rootpart//sda/sdb} ; export bootpart=$( ssh $rhost "df" | awk '$6 == "/boot" {print $1}') ; export bootpartnew=${bootpart//sda/sdb} ; export rootpartsize=$( ssh $rhost "df -m" |awk '$6 == "/" {print $3}') 
# MBR copy
fdisk -l ; df 
!!! ssh $rhost "dd if=/dev/sda bs=512 count=1" | dd of=/dev/sdb bs=512 count=1
# MBR partition table copy 
# 디스크 사이즈가 정확히 일치하지 않는경우, Extended/End 파티션 체크
!!! ssh $rhost "sfdisk -d /dev/sda" > /root/sda.partition_table.sfdisk ; cat /root/sda.partition_table.sfdisk
vi2 /root/sda.partition_table.sfdisk 
sfdisk /dev/sdb < /root/sda.partition_table.sfdisk
fdisk /dev/sdb
# boot partiiion copy (무압축/zstd)
!!! time ssh $rhost "dd if=$bootpart bs=4M" | dd of=$bootpartnew bs=4M ; push
!!! time ssh $rhost "dd if=$bootpart bs=4M | zstd" | zstd -d | dd of=$bootpartnew bs=4M ; push
# root/ boot mount
varMKFsType__mkfs.ext3 $rootpartnew 
mkdir -p /mnt/$(basename $rootpartnew)/ ; mount $rootpartnew /mnt/$(basename $rootpartnew) ; ls -al /mnt/$(basename $rootpartnew) ; mkdir -p /mnt/$(basename $rootpartnew)/{boot,proc,mnt,sys,tmp} ; mount $bootpartnew /mnt/$(basename $rootpartnew)/boot ; ls -al /mnt/$(basename $rootpartnew)/boot ; df
# sda mount partiation create ex) boot,clone,tmp,var,home 
export sdap=$( ssh $rhost "df" | grep "/dev/sda" | awk '{print $NF}' | sed -e 's/\///g' -e '/^$/d' | paste -sd, )
export exclude=$( ssh $rhost "df" | grep "/dev/sd" | awk '{if ($NF != "/") print "--exclude="$NF}' | paste -sd' ' - )
echo "$sdap" ; echo ; echo "$exclude"
eval "mkdir -p /mnt/$(basename $rootpartnew)/{$sdap}" ; explorer /mnt/$(basename $rootpartnew)/
# 별도 마운트 파티션을 제외한 sda root partition copy -> 검토/zstd/gzip
: !검토 zst ; echo "time ssh $rhost \"tar cfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / | zstd\" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | zstd -d | tar xfp - -C /mnt/$(basename $rootpartnew)/"
!!! : !zstd copy ; eval "time ssh $rhost \"tar cfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / | zstd\" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | zstd -d | tar xfp - -C /mnt/$(basename $rootpartnew)/" ; push
!!! : !gzip copy ; eval "time ssh $rhost \"tar czfp - $exclude --exclude=/proc --exclude=/lost+found --exclude=/.err --exclude=/mnt --exclude=/sys / \" | { pv -s ${rootpartsize}M 2>/dev/null || cat ; } | tar xzfp - -C /mnt/$(basename $rootpartnew)/" ; push
# 별도 마운트 파티션 mkfs && 수동 마운트후 copy (ncp func) / swap 파티션체크
ssh $rhost "df;echo" ;echo $sdap ;; mkdir -p /mnt/$(basename $rootpartnew)/$(basename varF) ; explorer /mnt/$(basename $rootpartnew)/
varMKFsType__mkfs.ext3 varPartition ; mount varPartition /mnt/$(basename $rootpartnew)/$(basename varF)
!!! time ssh $rhost 'cd varF/ && tar cfp - *| zstd' | { pv 2>/dev/null || cat ; } | zstd -d| tar xfp - -C /mnt/$(basename $rootpartnew)/$(basename varF) ; push
!!! time ssh $rhost 'cd varF/ && tar cfp - *| gzip' | { pv 2>/dev/null || cat ; } | gunzip | tar xfp - -C /mnt/$(basename $rootpartnew)/$(basename varF) ; push
: label 82 swapon ; fdisk -l /dev/sdb ;; mkswap varP
# lilo 혹은 grub 에서 더이상 진행이 안될경우 rescue-mode (boot cd) 로 진입하여 mbr 재설정 
# dd 로 sda img 를 뜨거나 (느린속도) / offline 에서 clonezilla 로 sda img 를 떠서 p2v 도 가능함 










%%% {submenu_hidden}역터널링 / 터널링 [tn]
%%%e {submenu_hidden}Reverse Tunneling / Tunneling [tn]
# R 역터널링: ex) 핸드폰이 lte 모드일때 핸폰에서 역터널링 접속을 해두면, 원격에서 
# 핸드폰 termux 로 ssh 접속이 가능함 ssh localhost -p 2222 (서버->클라이언트접속)
ssh -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
# 터널링만 유지 (터널링이 끊어지면 24시간 동안 재접속시도)
ssh -f -N -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost -o ServerAliveInterval=60 -o ServerAliveCountMax=1440 
# 마찬가지로 외부에서 접속이 안되는 서버 포트 열기 (ex.rdp)
# 윈도우의 경우 putty 로 터널링 연결가능 
ssh -R varRemotePORT__3389:localhost:varLocalPORT__3389 root@varRemotehost
# 접속 유지에 특화 autossh 
# autossh (-M 모니터링포트 -M 0 -> keep-alive)
autossh -M varMonitorPort__0 -f -N -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
# 터널링 끊기
lsof -i:varPORT__2222 
lsof -i:varPORT__2222 | awknr2 | awk2 | xargs kill 
# L 터널링 (클라이언트->서버접속)
ssh -L varLcalPORT__2222:localhost:varRemotePORT__8022 root@varRemotehost
# D 터널링 (SOCKS 프록시) 브라우저 설정후 이용
ssh -D varProxyPORT__8080 root@varRemotehost
# LD / RD 터널링 (혼합)
ssh -D varProxyPORT__8080 -L varLocalPORT__2222:localhost:varRemotePORT__8022 root@varRemotehost
ssh -D varProxyPORT__8080 -R varRemotePORT__2222:localhost:varLocalPORT__8022 root@varRemotehost
#
yyay autossh



%%% {submenu_hidden}패키지 관리 snap / git / pip [aa]
%%%e {submenu_hidden}Package Management snap / git / pip [aa]
%% echo -n "Able:" ; { which snap ; which git ; which pip ; } 2>/dev/null | tr "\n" " " ; echo
# snap install
yy epel-release
yyay snapd
systemctl enable --now snapd.socket
ln -s /var/lib/snapd/snap /snap
# git install
yyay git ; echo ; git --version
# pip  install
yyay python3 python3-pip ; ln -s /usr/bin/pip3 /usr/bin/pip






%%% {submenu_sys}tmp 폴더와 파일 / 난수 [tmp]
%%%e {submenu_sys}tmp Folder and Files / Random Number [tmp]
# tmpfile 생성 
: ${TMPDIR:=/tmp}; tmpfile=$(mktemp ${TMPDIR%/}/my_tmp_file.XXXXXX) || { echo "Failed to create temp file"; exit 1; } ; echo $tmpfile ; ls -al $tmpfile ; rm -f $tmpfile
# tmpdir 생성
: ${TMPDIR:=/tmp}; tmpdir=$(mktemp -d ${TMPDIR%/}/my_tmp_dir.XXXXXX) || { echo "Failed to create temp directory"; exit 1; } ; echo $tmpdir ; ls -ld $tmpdir ; rm -rf $tmpdir
# 임의의 6자리 숫자 생성 (인증키용) 
echo $(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))$(($RANDOM % 10))
echo $RANDOM ; echo $RANDOM$RANDOM|cut -c -6 ; echo $RANDOM$RANDOM|rev|cut -c -6|rev 
printf "%.06d\n" "$(shuf -i 0-999999 -n 1)"
printf '%.06s\n' "$(head -n3 /dev/urandom | tr -dc 0-9)"
# 난수 알파벳 생성 (6바이트 3바이트)
openssl rand -base64 6 ; openssl rand -base64 3 ; printf '%.6s\n' "$(openssl rand -base64 6)"
# 고유ID 
uuidgen;uuidgen;uuidgen
# 영어와숫자로된 6자리 난수
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc A-Za-z0-9)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc a-z0-9)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc a-z)"
printf '%.6s\n' "$(head -n3 /dev/urandom | tr -dc 0-9)"
# 임의의 단어 난수
shuf -n 1 /usr/share/dict/words
shuf -n 1 /usr/share/dict/korean
# 단어를 배열에 넣고 출력 (메모리사용/속도지연)
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)]; }' /usr/share/dict/words
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)]; }' /usr/share/dict/korean
# 줄수를 가져와 랜덤줄수 sed (파일2회i/o)
f="/usr/share/dict/words"; l=$(wc -l < "$f"); r=$(( ($RANDOM$RANDOM) % l + 1)); sed -n "${r}p" "$f"
f="/usr/share/dict/korean"; l=$(wc -l < "$f"); r=$(( ($RANDOM$RANDOM) % l + 1)); sed -n "${r}p" "$f"
#
# 단어 난수2개 이어쓰기
shuf -n 2 /usr/share/dict/korean | tr -d '\n'; echo
awk 'BEGIN { srand(); } { lines[NR] = $0; } END { print lines[int(rand() * NR + 1)] lines[int(rand() * NR + 1)]; }' /usr/share/dict/korean
f="/usr/share/dict/korean"; l=$(wc -l < "$f"); r1=$(( ($RANDOM$RANDOM) % l + 1)); r2=$(( ($RANDOM$RANDOM) % l + 1)); word1=$(sed -n "${r1}p" "$f"); word2=$(sed -n "${r2}p" "$f"); printf "%s%s\n" "$word1" "$word2"
# 영단어 패키지 설치 
yy words || ay wamerican
curl http://byus.net/koreane.txt -o /usr/share/dict/korean
curl http://byus.net/koreanu.txt -o /usr/share/dict/korean



%%% {submenu_hidden}중복실행방지 코드삽입 [dup]
%%%e {submenu_hidden}Code Insertion to Prevent Duplicate Execution [dup]
# 시스템 감시 용도의 스크립트등 중복으로 실행되면 안되는 경우 
# 아래의 runlockadd 함수를 스크립트에 삽입하여, 중복실행을 방지합니다.
# ex) cron 1분 간격 실행, load 가 높아 1분 안에 종료 않는 경우 중복 실행 방지
#
# test
export tmpscript="${TMPDIR:=/tmp}/tmp.sh"
echo -e "#!/bin/bash\ntop" > $tmpscript ; chmod 700 $tmpscript ; RED1 ; cat $tmpscript ; RST 
runlockadd $tmpscript; echo; RED1 ; cat $tmpscript.1 ; RST ; echo ; YEL1; cat $tmpscript ; RST 
cdiff $tmpscript.1 $tmpscript
screen -dmS test-top $tmpscript ;; ps -ef|grep tmp.sh ;; readx ; $tmpscript
# test end
ps -ef|grep tmp.sh|awk2 |xargs kill 
unset tmpscript
#
# 
declare -f runlockadd
runlockadd varScriptPATH ; vi2 varScriptPATH



%%% {submenu_hidden}bash 변수 사용예제 [var]
%%%e {submenu_hidden}bash Variable Usage Examples [var]
# 변수 디폴트값 출력혹은 설정
unset var; echo "Result: ${var:=default}"; echo "\$var = $var"
unset var; echo "Result: ${var:-default}"; echo "\$var = $var"
unset var; echo "Result: ${var:+default}"; echo "\$var = $var"
unset var; echo "Result: ${var:?error}"; echo "\$var = $var" 2>/dev/null
# 변수 길이
var="value"; echo "Result: ${#var}"; echo "After: \$var = $var"
# 변수 자르기
var="hello"; echo ${var#?}; echo ${var%${var#?}} ; echo ${var:0:1}
var="/path/to/file.txt"; echo "Result: ${var#*/}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var##*/}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var%/*}"; echo "After: \$var = $var"
var="/path/to/file.txt"; echo "Result: ${var%%/*}"; echo "After: \$var = $var"
# dirname / basename 
echo "$0 // $(dirname $0) //  $(basename "$0" )  // $(basename "$0" .sh)"
echo "$0 // ${0%/*} // ${0##*/} // $( t=${0##*/}; echo ${t%.*})"
# 변수 편집 // realpath
var="/root/./home/user"; echo "Result: ${var//\/\./}"; echo "After: \$var = $var"
var="/root/../home/user/./folder"; echo "Before: \$var = $var"; var=$(echo "$var" | sed -e 's/\/\.\//\//g' | awk -F'/' -v OFS="/" '{top=1; for (i=2; i<=NF; i++) {if ($i == "..") {top--; delete stack[top];} else if ($i != "") {stack[top]=$i; top++;}} for (i=0; i<top; i++) {printf "%s", stack[i]; printf i==top-1?"":OFS;}}');echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(readlink -f "$var"); echo "Result: $result" ;echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(realpath "$var");echo "Result: $result";echo "After: \$var = $var"
var="/root/../home/user/./folder";result=$(cd "$(dirname "${var}")" ; echo $(pwd));echo "Result: $result";echo "After: \$var = $var"
# 변수 배열 ; 배열 출력
array=($(seq 1 5)); for i in "${array[@]}"; do echo $i; done
# printf
printf "%-15s %5d\\n" "Apples" 5
printf "%.2f\\n" 3.141592
printf "%x\\n" 15
printf "%+10s\\n" "hello"
printf "%.5s\\n" "abcdefghijk"
printf "Hello\\tworld! \\n"
# 서브쉘과 현재쉘 변수 
c=0 ; ( a=1; b=2 ; c=$(( a + b )) ) ; echo $c
c=0 ; { a=1; b=2 ; c=$(( a + b )); } ; echo $c
# 간접변수참조
a=b ; b=c ; echo ${!a}




%%% {submenu_hidden}awk/sed 변수 사용예제
%%%e {submenu_hidden}awk/sed Variable Usage Examples
# 네모
awk 'BEGIN{OFS=""; ORS="\n"; for(i=1; i<=5; i++){for(j=1; j<=5; j++)$j="#"; print}}'
# 세모
awk 'BEGIN{OFS=""; ORS="\n"; for(i=1; i<=5; i++){for(j=1; j<=i; j++)$j="#"; print}}'
# 여러 개의 연속된 공백을 하나의 공백으로 
df | sed 's/ \+/ /g'
df | awk '{$1=$1}1'




%%% {submenu_hidden}dialog [dia]
%%%e {submenu_hidden}dialog [dia]
# msgbox
dialog --title "Message" --msgbox "This is a sample message box." 10 50
height=$(($(tput lines)*70/100)) ; width=$(($(tput cols)*70/100)); dialog --title "Message" --msgbox "This is a sample message box." $height $width
# yesno
dialog --stdout --title "Question" --yesno "Do you want to continue?" 10 50 ; echo "You chose: $?"
# inputbox
dialog --stdout --title "Inputbox - To take input from you"  --backtitle "Linux Shell Script Tutorial" --inputbox "Enter your name please" 8 60 
# checklist
CHOICES=$(dialog --stdout --checklist "Choose toppings:" 10 40 3 1 Cheese on 2 "Tomato Sauce" off 3 Anchovies off ); fclear; echo "You chose: $CHOICES"
# menulist
CHOICE=$(dialog --stdout --title "Menu" --menu "Choose an option:" 10 30 3 1 "Option 1" 2 "Option 2" 3 "Option 3" ); fclear; echo "You chose: $CHOICE"
# radiolist
CHOICE=$(dialog --stdout --title "Radio Menu" --radiolist "Choose an option:" 10 30 3 1 "Option 1" off 2 "Option 2" off 3 "Option 3" off ); fclear; echo "You chose: $CHOICE"
# progress
for i in `seq 1 100`; do echo $i; sleep 0.02; done | dialog --gauge 'File copy progress'  10 60
# update example
dialog --title "System Update" --yesno "Do you want to update the system?" 10 60; response=$?; case $response in 0) echo "System update in progress..." && sudo apt-get update && sudo apt-get upgrade;; 1) echo "Update cancelled.";; esac
# proxmox pct example
vmid=$(dialog --title "VMID Selection" --menu "Choose VMID from the following list:" 22 76 16 $(pct list | awk 'NR>1 {print $1,$3"__"$2}') 3>&1 1>&2 2>&3); fclear; cmd=$(dialog --title "PCT Command" --menu "Choose command" 22 76 5 1 "Start" 2 "Stop" 3 "Reboot" 4 "Config" 5 "Enter" 3>&1 1>&2 2>&3); fclear; case $cmd in 1) cmd="start";; 2) cmd="stop";; 3) cmd="reboot";; 4) cmd="config";; 5) cmd="enter";; esac; fclear; if [ -n "$vmid" ]; then fclear && echo "Executing 'pct $cmd $vmid'" && pct $cmd $vmid; else fclear && echo "No VMID selected."; fi ; echo ; pct list |cgrep1 running
# proxmox qm example
vmid=$(dialog --title "VMID Selection" --menu "Choose VMID from the following list:" 22 76 16 $(qm list | awk 'NR>1 {print $1,$2"__"$3}') 3>&1 1>&2 2>&3); fclear; cmd=$(dialog --title "QM Command" --menu "Choose command" 22 76 4 1 "Start" 2 "Stop" 3 "Reset" 4 "Config" 3>&1 1>&2 2>&3); fclear; case $cmd in 1) cmd="start";; 2) cmd="stop";; 3) cmd="reset";; 4) cmd="config";; esac; fclear; if [ -n "$vmid" ]; then fclear && echo "Executing 'qm $cmd $vmid'" && qm $cmd $vmid; else fclear && echo "No VMID selected."; fi ; echo ; qm list |cgrep1 running
# fdialog (행변수) / fdialog1 (열변수)
declare -f fdialog;echo; declare -f fdialog1
/bin/df -h | fdialog
ls -1 / | fdialog
ls -ld /* | grep ^d | awk '{dir=$NF; $NF=""; print dir,$0}' | fdialog
ls -ld /* | grep ^d | awk '{dir=$NF; $NF=""; print dir,$0}' | fdialogw
ls | fdialog1
eval $( echo env top htop bashtop neofetch iftop dfmonitor | fdialog1 ) 
# install
yyay dialog


%%% {submenu_hidden}luit compile [luit]
%%%e {submenu_hidden}luit compile [luit]
# ubuntu 24. which luit ... "" - source compile
# encoding chg
git clone https://git.launchpad.net/ubuntu/+source/luit
cd luit
sudo apt update
sudo apt install build-essential pkg-config git autoconf automake libtool xutils-dev
sudo apt install libx11-dev libfontenc-dev zlib1g-dev
./configure
make
sudo make install
which luit
luit -encoding EUC-KR ssh varADD



%%% {submenu_hidden}telegram cli [tg]
%%%e {submenu_hidden}telegram cli [tg]
# https://github.com/vysheng/tg
cd ~/ ; git clone --recursive https://github.com/vysheng/tg.git && cd tg
# http://core.telegram.org/api
sudo apt-get install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython-dev make 
cd ~/tg/ ; ls -al 
explorer ~/tg/
# make 
./configure
make



%%% {submenu_hidden}test menu [test]
%%%e {submenu_hidden}test menu [test]
# test menu ---> conf [Enter] && play 
# 쉼표 하나는 쭉 실행. 쉼표 두개는 앞에거 실행후 뒤에꺼 실행
# 실행전 var 변수가 보이면 변수값 요청 
printarr shortcutarr # scr
echo "$shortcutstr" ;; echo "$shortcutstr" | cgrep varA  # sc
ls -d /var/log/* ; tail -f varLogFile
ls -d /var/log/* ;; tail -f varLogFile
tail -f $( ls -d /var/log/* | pipemenu1 ) 
echo varVAR__abc ; echo varVAR
echo varVAR__abc ;; echo varVAR
echo varVAR__abc.conf ;; echo varVAR
echo varVAR.conf ;; echo varVAR__.conf
echo varVAR__abc@@dd ;; echo varVAR
echo varVAR__a@space@b ;; echo varVAR
echo $( echo "a b c" | pipemenu what you want )
echo $( echo "a b c" | pipemenu )
echo $( echo "a b c" | pipemenucancel )
# var default value -> space_add @space@
systemctl varVAR__disable@space@--now__enable@space@--now atd ;; systemctl status atd
bell
# VAR set ? 
echo varVAR ; echo varVAR
echo varVAR ;; echo varVAR
: abc : def ; echo varVAR
# space -> , chg 
echo "varVMSnospace"
echo "hihihi hohooho hahaha" ; echo $lastarg
echo "hihihi hohooho hahaha" ;; echo $lastarg
#
vara=abcc ;; varVAR=$vara ;; echo "varVAR -> $varVAR"
# Caution commands
!!! echo varVAR ;; echo varVAR
# VAR reuse or bug check or setpass
echo varVAR__ ;; echo varVAR__reuse ;; echo varVAR___
echo varVAR__a__b__c  ;; echo varVAR
echo varVAR__i@space@love@space@you__b__c  ;; echo varVAR
echo "varVAR__100__200__300"G ; stg="varVAR" ; echo "your stg set : ${stg}G"
echo "varVAR__\"100\""
# var export
a=varA ; echo $a
a=varA ;; echo $a
export a=varA ;; echo $a
echo $a
env | sort | cpipe | less -rX


%%% {submenu_hidden}test menu 2page [test2]
%%%e {submenu_hidden}test menu 2page [test2]
# 활성변수확인
declare -p
set
# 지역변수
declare -p | grep -v 'declare -x'
# 환경변수
declare -p | grep 'declare -x'
# gosh변수 ex) varVAR
a=varVARa ;; echo "varVARa" ;; echo $a
b=varVARb ;; echo "varVARb" ;; echo $b
declare -p | grep "^declare -x var[A-Z]"
declare -p | grep "^declare -x var[A-Z]" | awk3
# save & exit 
declare -p | grep '^declare -x var' > ~/.go.private.var ; chmod 600 ~/.go.private.var
# save incremental
declare -p | grep '^declare -x var' >> ~/.go.private.var ; chmod 600 ~/.go.private.var
# load 동일한 변수가 기록된 경우 가장 나중에 기록된 변수가 활성화
echo "varVARa:$varVARa // varVARb:$varVARb" # load 전 
cat ~/.go.private.var
# 변수를 가져와야 하나, 서브쉘에서 source 가 되어 부모쉘에서 쓸수가 없음
# go.sh 에서 source 불러오면 작동가능
source ~/.go.private.var 
declare -p | grep 'varVAR'
echo "varVARa:$varVARa // varVARb:$varVARb" # load 전 
# gosh변수 저장 -> 스크립트 재시작시 불러오기
saveVAR
# go.sh auto load
loadVAR
ff saveVAR ;; ff loadVAR
echo -e "사과\n바나나\n오렌지\n사과\n바나나\n포도" | seen
echo -e "사과\n바나나\n오렌지\n사과\n바나나\n포도" | lastseen
echo "varPKG__lynx__power_up__enable@space@--now__space@space@power__screen__bat__at__net-tools__apt-file__all"
echo "$(echo $base $basefile $readlinkf |pipemenucancel)" 
echo "varA varAA varAAA"

%%% {submenu_hidden}test3 [test3]
%%%e {submenu_hidden}test3 [test3]
echo "only one menu ; direct execute ; kiss me?"

%%% {submenu_hidden}test menu 4page [test4]
%%%e {submenu_hidden}test menu 4page [test4]
%% echo "VAR1: $VAR1 VAR2: $VAR2"
# @@ -> / 
echo "varVAR__@@etc@@fstab__@@etc@@network"
# direct / -> not var Element
echo "varVAR__/etc/fstab__/etc/network"
echo "varVAR__abc.com__bbc.com"
echo "varVAR.abc.com"
#
# HereDocument auto var chg // cat << EOF > file // cf. cat << 'EOF' > file
template_edit heredocutest.conf
# 환경변수가 보이면 자동으로 변환 되어 출력 'EOF' 대신 EOF 로 해야 작동 
export VAR1="change1" ; export VAR2="change2" 
# 변수값 직접 지정
export VAR1="varVAR1" ; export VAR2="varVAR2"
template_view heredocutest.conf 
!!! template_copy heredocutest.conf ~/heredocutest.conf ;; cat ~/heredocutest.conf | cgrep1 VAR1 change
change ~/heredocutest.conf VAR1 varvarvar ;; cat ~/heredocutest.conf
vi ~/heredocutest.conf
rm -f ~/heredocutest.conf
hash_add gos "for" 2
hash_remove gos "for" 2
hash_remove gos "for" 3
hash_remove gos "for" 
cat gos


%%% {submenu_hidden}update log [log]
%%%e {submenu_hidden}update log [log]
# 250320 local llm gemma3 -> after install -> everywhere 'hi'
# 250321 b / bb shortcut -> move back or 2back
# 250321 shortcut use everywhere
# 250322 saveVAR func -> exit & exec gosh -> reuse varVAR ~/.go.private.var
# 250323 menu move logic improve (relay menu)
# 250324 array use -> exec go.sh drop -> menufunc {sub} {title} // stop restart go.sh
# 250324 cat go.my.env >> go.env / Add server-specific go.my.env
# 250325 varVAR default value -> mult select or all select available
# 250326 assh func edited >> euc-kr encoding add ( old server ssh -> kr crash )
# 250326 .go.env tmpfile read/write >> disk -> mem chg ( i/o down ) /dev/shm/.go.tmp
# 250326 No match, trying .bashrc alias: cmd_choice & choice
# 250326 last if choice cmd_choice ---> if -> case chg 
# 250327 cmd 메뉴 탈출 bug check (재귀호출로 인한 bug -> break / continue 로 해결)
# 250328 change insert eprintf func add
# 250329 varVAR path "/" add && varVAR__ bug fix 
# 250331 hash_add hash_remove func ex) hash_add filename "search" -> "^#....search"
# 250401 nagios edit
# 250401 teldrive daemon add [tel] // teldrive docker [dkt] // teldrive rclone [telr]
# todo menu move bug fix
# todo menufunc $scut use
conf





%%% {submenu_hidden}go.sh GitHub push [gosh]
%%%e {submenu_hidden}go.sh GitHub push [gosh]
%% echo "GITHUB_TOKEN: $GITHUB_TOKEN"
# go.sh github push
cd ~ ; git clone https://github.com/forsys02/linux_console_manager.git
cd ~/linux_console_manager
explorer ~/linux_console_manager
#
git status
git diff go.env /script/go.env
git diff go.sh /script/go.sh
cp -a /script/go.{env,sh} ~/linux_console_manager/ && git add go.env go.sh && git commit -m "update"
git push origin main
# auto push (do not write id/token)
export GITHUB_TOKEN="varTOKEN" 
git push https://forsys02:${GITHUB_TOKEN}@github.com/forsys02/linux_console_manager.git main
#
shfmt -i 4 -s -w $gofile
#### all_in_one ####
shfmt -i 4 -s -w /script/go.sh ; cd ~/linux_console_manager ; cp -a /script/go.{env,sh} ~/linux_console_manager/ ; git add go.env go.sh && git commit -m "update" && git push https://forsys02:${GITHUB_TOKEN}@github.com/forsys02/linux_console_manager.git main
# auth
git remote -v
# Personal Access Token
# -> github.com login, Settings -> Developer settings -> Personal access tokens -> Generate new token
# env add
echo "GITHUB_TOKEN=varTOKEN" >> ~/go.private.env && . ~/go.private.env
vi2 ~/go.private.env





%%% {submenu_hidden}debug menu [debug]
%%%e {submenu_hidden}debug menu [debug]
### gosh debug 
#
# shell-check 
apt install shellcheck
shellcheck $gofile | cgrep warning | cgrep1 info style | less -RX
#
# re-format (Google Shell Style Guide)
apt install shfmt
shfmt -i 4 -s $gofile | less -RX
shfmt -i 4 -s $gofile > ~/go.sh.shfmt
cdiff $gofile ~/go.sh.shfmt
vi2 ~/go.sh.shfmt
# backup ymdhms
cp -a $gofile ~/go.sh.$(datetag2)
!!! cp -a ~/go.sh.shfmt $gofile
# write now
!!! shfmt -i 4 -s -w $gofile
#
# func list 
grep -E '^[a-zA-Z0-9_]+\(\) \{' $gofile | awk '{print $1}' | tr -d '()' |sort -u | paste -s -d' ' -
# func view 
declare -f $(grep -E '^[a-zA-Z0-9_]+\(\) \{' $gofile | awk '{print $1}' | tr -d '()' |sort -u | pipemenu) 















%%% {submenu_hidden}ansi code [ansi]
%%%e {submenu_hidden}ansi code [ansi]
%% echo ; { echo -e "\033[0m TcBc: Reset \033[0m [0m] \033[1m Tc: Bold \033[1m [1m] \033[3m Tc: Italic \033[0m [3m]\n\033[4m Tc: Underline \033[0m [4m] \033[7m Bc: Invert \033[0m [7m] \033[9m Tc: Strike \033[0m [9m]\n\033[22m Bold off \033[0m [22m] \033[23m Italic off \033[0m [23m] \033[24m Under off \033[0m [24m]\n\033[27m Invert off \033[0m [27m] \033[29m Strike off \033[0m [29m] \033[30m Tc: Blk \033[0m [30m]\n\033[31m Tc: Red \033[0m [31m] \033[32m Tc: Grn \033[0m [32m] \033[33m Tc: Yel \033[0m [33m]\n\033[34m Tc: Blu \033[0m [34m] \033[35m Tc: Mag \033[0m [35m] \033[36m Tc: Cyn \033[0m [36m]\n\033[37m Tc: Wht \033[0m [37m] \033[39m Default Tc \033[0m [39m] \033[40m Bc: Blk \033[0m [40m]\n\033[41m Bc: Red \033[0m [41m] \033[42m Bc: Grn \033[0m [42m] \033[43m Bc: Yel \033[0m [43m]\n\033[44m Bc: Blu \033[0m [44m] \033[45m Bc: Mag \033[0m [45m] \033[46m Bc: Cyn \033[0m [46m]\n\033[1;47m Bc: Wht \033[0m [1;47m] \033[49m Default Bc \033[0m [49m]" ;echo "-";echo "-";echo; paste <(for i in `seq 40 47`; do echo -e "\033[01;37;${i}m ABCDEFG [1;37;${i}m] \033[0m"; done) <(for i in `seq 40 47`; do echo -e "\033[01;4;37;${i}m ABCDEFG [1;4;37;${i}m] \033[0m"; done) <(for i in `seq 30 37`; do echo -e "\033[0;4;5;${i};47m ABCDEFG [0;4;5;${i};47m] \033[0m"; done); } | column -t ; echo -e "\033[0m" 
#
for code in $(seq 0 107); do printf "\\e[${code}m%s\\e[0m\\n" "ANSI Code $code"; done |less -RX
echo -e "\\e[1;33;44m e escape code \\e[0m"
echo -e "\\033[1;33;44m 0133 8bit 27 escape code \\e[0m"
echo -e "\\x1b[1;33;44m x1b 16bit 27 escape code \\e[0m"
# 안시 제거
echo -e "\\033[1;3m2;2;3m\\033[0m" | perl -p -e 's/\\e\[[0-9;]*[MKHJm]//g' 2>/dev/null



%%% SSL 인증서 LetsEncrypt [ssl]
%%%e SSL Certificate LetsEncrypt [ssl]
%% envvarl=$( env | grep "varl[0-9]*" ) ; [ "$envvarl" ] && { GRN1 ; echo -n $envvarl ; RST ; }
%% [ "$mydomain" ] && echo "MyDomain: $mydomain"
# 내도메인 정보 환경파일에 넣거나 직접 입력 
[ ! "$mydomain" ] && echo "mydomain=varMyDomain" >> ~/go.private.env && . ~/go.private.env
export mydomain=varMyDomain
# dns-01 챌린지 과정중 나오는 txt 레코드 복사후 도메인 네임서버 등록사에 가서 등록
# ex) _acme-challenge.yourdomain.com.  IN  TXT "Somewhat long key string"
# 레코드 등록에 시간이 소요될 수 있으며 챌린지 실패시 시간 간격을 두어 재시도
# txt 레코드는 총 2회 인증 요청됨 (인증실패가 계속되면 일정시간 블락)
certbot certonly --manual -d $mydomain -d *.$mydomain --agree-tos --no-bootstrap --manual-public-ip-logging-ok --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory
# webroot key 로 인증하여 인증서 발급 // 와일드카드 인증서는 webroot 방식으로는 불가
certbot certonly --webroot -w varWWWrootPath__@@var@@www@@html -d $mydomain -d www.$mydomain -d varSubDom__m.$mydomain --agree-tos -m "varYourEmail"
# 발급받은 인증서는 3개월간 유효 (2개월후부터 갱신가능)
ls -al /etc/letsencrypt/live/$mydomain/ ; cat /etc/letsencrypt/live/$mydomain/fullchain.pem ; cat /etc/letsencrypt/live/$mydomain/privkey.pem
# 유효기간 확인 및 스케즐 등록 
certbot certificates 
certbot certificates ;; alarm 00001100varExdate__61 "$mydomain SSL 인증서 발급 varExdate__61일이 지났습니다. 수동 갱신하세요." ;
# 인증서 자동 갱신 crontab 일요일 새벽 3시 dry-run 으로 체크요망 
echo "0 3 * * 0 /usr/bin/certbot renew --webroot -w /var/www/html/ -quiet" >> /etc/crontab
# 자동 갱신을 위해선 doamin txt key 인증받은것과 마찬가지로 인증이 필요하며
# 아래 방법은 웹루트에 토큰파일을 자동으로 심어서 인증받는 방법으로 갱신 
certbot renew --webroot -w varWWWrootPath__@@var@@www@@html --dry-run
# 인증서 수동 갱신 (3개월이전)
certbot renew --force-renewal --manual
# nginx apply sample
echo -e "server { \n    listen 443 ssl default_server;\n    http2 on;\n    server_name $mydomain *.$mydomain;\n    root /source;\n    ssl_certificate /etc/letsencrypt/live/$mydomain/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/$mydomain/privkey.pem;\n}\n"
# apache2 apply sample
vi2 /etc/apache2/sites-available/$mydomain.conf
echo -e "<VirtualHost *:443>\n  ServerName $mydomain\n  ServerAlias *.$mydomain\n  DocumentRoot /var/www/html\n  SSLEngine on\n  SSLCertificateFile /etc/letsencrypt/live/$mydomain/fullchain.pem\n  SSLCertificateKeyFile /etc/letsencrypt/live/$mydomain/privkey.pem\n  CustomLog ${APACHE_LOG_DIR}/access.log combined\n  ErrorLog ${APACHE_LOG_DIR}/error.log\n</VirtualHost>\n"
systemctl reload nginx || systemctl reload apache2
# install
yyay certbot




%%% {submenu_sys}인코딩/ 디코딩/ 암호화/ 복호화 [enc]
%%%e {submenu_sys}Encoding/Decoding/Encryption/Decryption [enc]
# web - url{en,de}coding
echo "varWORD" | od -t x1 -A n | tr " " %
echo "varENCWORD" | echo -en "$(sed 's/+/ /g; s/%/\\x/g')"
#
# base64 {en,de}coding 이진 데이터를 ASCII 문자열로 변환 (메일의첨부파일등) 
echo "varWORD" | base64
echo "varENCWORD" | base64 --decode
# base64 (perl) 
echo "varWORD" | perl -MMIME::Base64 -ne 'print encode_base64($_);'
echo "varENCWORD" | perl -MMIME::Base64 -ne 'print decode_base64($_)'
#
# 암호화/복호화 
key=varKEY__mykey; echo -n "varWORD" | openssl enc -aes-256-cbc -e -k $key -A -a -pbkdf2 -iter 100000 ; echo
key=varKEY__mykey; echo -n "varENCWORD" | openssl enc -aes-256-cbc -d -k $key -A -a -pbkdf2 -iter 100000 ; echo
# old_openssl
key=varKEY__mykey; echo -n "varWORD" | openssl enc -des-ede3-cbc -e -k $key -A -a ; echo
key=varKEY__mykey; echo -n "varENCWORD" | openssl enc -des-ede3-cbc -d -k $key -A -a ; echo
# encrypt / decrypt func
declare -f encrypt ; echo ; declare -f decrypt
echo varWORD | encrypt varKEY__key
echo varEncWORD | decrypt varKEY__key
echo varWORD | encrypt varKEY__key | decrypt varKEY__key 



%%% {submenu_sys}>히든메뉴 [hid]
%%%e {submenu_sys}>Hidden Menu [hid]
{submenu_hidden}


%%% 텔레그램과 푸시알람 [te]
%%%e Telegram and Push Notifications [te]
%% env | grep telegram_
%% [ "$( atqq )" ] && CYN && atqq && RST
%% ps -ef |grep [a]larm_task|awknf8|cgrep "alarm_task_$input"|grep -v "awk"
# 스크립트 에서 텔레그램봇으로 메세지를 전송 
# 최초 사용시 텔레그램 정보(챗봇ID,토큰) 입력
# ex) push varMSG // echo varMSG | push // push
# 스크립트의 결과를 텔레그램으로 받고 싶을때 사용 
push varMSG__var.hello
echo "varMSG__pipe.hello" | push
w | push
# 결과를 명령어와 에러유무를 메세지를 받고 싶을때
eval "sleepdot 10 ; echo i love gosh !!!" ; push "Task ended command: $_  result: $?"
# 결과를 화면과 메세지로 받고 싶을때
sleepdot 10 ; pstree | push
# make 같은 오랜 작업 완료를 메세지로 받고 싶을때 -> 알람용도 
# 인수도 없고 파이프도 없을 경우 $HOSTNAME push 
sleepdot 30 ; push
#
# 지정한 시간에 텔레그램으로 푸시 발송
# go.sh 메인화면에서 ex) "005 [Enter]" 타이머 설정가능
# 0060 은 60분후 푸시 00001300 은 13시에 푸시
# alarm 명령어 생략해도 실행 가능 ( 메인/서브 메뉴 선택화면에서 패턴 인식 ) 
alarm 001  
alarm 005 라면타임
alarm 0060 10분 휴식
alarm $( echo 0010 0030 0060 00120 00180 | pipemenu ) 
alarm varTIMESET_0000xy_or_00xy varMSG
# timer 00 // alarm 0000 
alarm 00001700 퇴근 17시에 합시다.
alarm 000020001 내일 20시 축구.
# 알람삭제
atqq ;; atrm varATNUM
# 
# 환경변수 수정
echo "telegram_chatid=varChatID" >> ~/go.private.env 
echo "telegram_token=varToken" >> ~/go.private.env && chmod 600 ~/go.private.env
vi2 ~/go.private.env
#
yyay at curl






%%% 설명서 / 업데이트 [help]
%%%e Manual / Update [help]
%% export PATH=$PATH:$(cd "$(dirname "${0}")" ; echo $(pwd)) ; echo "PATH: $PATH"
%% printf "basefile: $basefile // base: $base \n"
# 리눅스 콘솔에서 서버 관리를 용이하게 할수 있도록 메뉴 구성 
# wget http://byus.net/go.sh && bash go.sh 로 바로 시작가능
# 파일구성 go.sh // go.env // opt. explorer.sh(0.01ver)
# /bin/gosh 로 soft link 생성되어, 최초 실행후 gosh [Enter] 로 진입가능
# go.env 파일에 콘솔 명령어들을 입력 하여 메뉴 화면 구성 
# go.env 수정시 메인메뉴에서 conf [Enter] 하면 백업후 vi 수정모드 
# %%% 로 메인 메뉴 시작 - 빈줄로 메뉴 끝 // %% - 서브 메뉴 시작시 사전 명령 실행
# 메뉴 단축키 지원 [a-zzz] 형식 // 모든 메뉴 선택창에서 단축키 이동지원
# 콘솔에서 직접 입력 명령 그대로 최대한 사용 // 난 객관식 체질인분 환영
# ;; 로 이어진 명령들은 순차적으로 실행 (앞의 결과를 보고 뒤의 변수를 입력 가능)
# var[A-Z][a-zA-Z0-9_.@]* 는 사용자 변수로 직접 입력 지원 
# varABC__default : 사용자변수 끝에 __기본값 형태로 default 값 사전설정 가능 (ex varPORT__22)
# 변수 기본값에 경로가 필요한 경우 -> @ 2개 -> / 로 변환됨 
# 명령문에 있는 모든 varABC 가 치환된 후에, bash 에게 전달. 
# ~/go.private.env 개인 환경변수 파일 불러와 이용이 가능. 
# 개인 환경변수 -> var=abc 형태로 등록하며, 스크립트 실행후 env 로 확인가능.
# !!! 는 주의명령으로 명령 실행여부를 한번더 확인 
# 함수 지정하여 호출하여 사용 // go.sh 하단에 함수 설정 예) awk1() { awk '{print $1}' ; }
# 함수 vi2 는 파일 rotate 백업후 vi 를 진행하는 함수 (a a.1.bak ... a.4.bak)
# bash2 기준으로 대부분의 리눅스에서 에러 없이 구동되도록 호환성 유지
# 현재 콘솔 한글 환경을 추적하여 euc-kr/utf8 한글 메뉴 지원 (강제변경지원:ko) 
# locale 을 체크하여 kr 환경이 아닌경우, 영어메뉴 출력 (console)
# redhat / centos / debian / ubuntu 기준 주요 명령어 기재
# 메인메뉴에서 update [Enter] 로 최신 스크립트 다운로드 가능 
# 제작: 손희태 (forsys02@gmail.com)
# https://github.com/forsys02/linux_console_manager
: go.sh update ; update
: go.sh update - github; cd $base ; rbackup go.{sh,env} && rm -f go.{sh,env} ; wget --clobber --no-cache https://raw.githubusercontent.com/forsys02/linux_console_manager/refs/heads/main/go.{sh,env} && bash go.sh
# $(env) add/edit -> export var (ex. myname=tina)
: edit ; go=$( echo $(which $0) $(dirname $(which $0))/go.env $(dirname $(which $0))/go.my.env ~/go.private.env ~/.go.private.var | pipemenucancel ) ;; [ "$go" != ":_Cancel" ] && vi2 "$go"
# your private go.env -> init go.my.env
echo -e "\n\n%%% varTitle_Eng__mymenu [varScut__my]\n%%%e varTitle_Eng [varScut]\nconf\nconfmy\nyour_command_here" >> $base/go.my.env && tail $base/go.my.env && echo -e "\nrestart $basefile" && readx && exec $basefile $scut
# go.sh 내장 함수의 내용을 보고 싶을때 ex) ff func_name
declare -f varFunc__vi2
declare -f varFunc__update__rbackup__cper__ff__cip__cgrep__idpw__rollback__bell




